{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/pure/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/pure/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/pure/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/README.md","path":"fonts/README.md","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/pure/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/pure/source/images/thumb-default.png","path":"images/thumb-default.png","modified":1,"renderable":1},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","path":"images/xingqiu-qrcode.jpg","modified":1,"renderable":1},{"_id":"themes/pure/source/js/application.js","path":"js/application.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/application.min.js","path":"js/application.min.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/plugin.js","path":"js/plugin.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":1,"renderable":1},{"_id":"themes/pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":1,"renderable":1},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","path":"images/donate/wechatpayimg.png","modified":1,"renderable":1},{"_id":"themes/pure/source/images/donate/alipayimg.png","path":"images/donate/alipayimg.png","modified":1,"renderable":1},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","path":"images/favatar/SzsFox-logo.png","modified":1,"renderable":1},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","path":"images/favatar/chuangzaoshi-logo.png","modified":1,"renderable":1},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","path":"images/favatar/idesign-logo.png","modified":1,"renderable":1},{"_id":"source/images/Jietu20200525-170153.jpg","path":"images/Jietu20200525-170153.jpg","modified":1,"renderable":0},{"_id":"source/images/Jietu20200525-160258.jpg","path":"images/Jietu20200525-160258.jpg","modified":1,"renderable":0},{"_id":"source/images/Jietu20200529-212414.jpg","path":"images/Jietu20200529-212414.jpg","modified":1,"renderable":0},{"_id":"source/images/Jietu20200525-170710.jpg","path":"images/Jietu20200525-170710.jpg","modified":1,"renderable":0},{"_id":"source/images/Jietu20200529-212609.jpg","path":"images/Jietu20200529-212609.jpg","modified":1,"renderable":0},{"_id":"source/images/Jietu20200807-100039.jpg","path":"images/Jietu20200807-100039.jpg","modified":1,"renderable":0},{"_id":"source/images/VNode_object.jpg","path":"images/VNode_object.jpg","modified":1,"renderable":0},{"_id":"source/images/VNodes_createElement_return.jpg","path":"images/VNodes_createElement_return.jpg","modified":1,"renderable":0},{"_id":"source/images/browser_navigator.png","path":"images/browser_navigator.png","modified":1,"renderable":0},{"_id":"source/images/browser_render.png","path":"images/browser_render.png","modified":1,"renderable":0},{"_id":"source/images/eventloop.jpg","path":"images/eventloop.jpg","modified":1,"renderable":0},{"_id":"source/images/micro_and_macro.jpg","path":"images/micro_and_macro.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"cf26f7b9cc5dcd3366aab7137d2627b70acf5da9","modified":1636183626381},{"_id":"source/images/Jietu20200529-212414.jpg","hash":"2e115d90d78aae62cc715f74a304dd5ef124a135","modified":1636184060490},{"_id":"source/images/Jietu20200525-160258.jpg","hash":"0cd9beb726aa3459bc12db8048caa387a9328c91","modified":1636184060322},{"_id":"source/images/Jietu20200525-170710.jpg","hash":"dbe657b4f947eac6e581d8eb7d51bfaa3dd74377","modified":1636184060440},{"_id":"source/images/Jietu20200525-170153.jpg","hash":"bdc8ea8ed1a7a5c3720c2c1b5bc3882caf824593","modified":1636184060386},{"_id":"source/images/Jietu20200529-212609.jpg","hash":"c3789b845d4cff85955cf615942d0bb366ce104a","modified":1636184060514},{"_id":"source/images/Jietu20200807-100039.jpg","hash":"314abea0d48224cf6b1725ffc904b03fe9020173","modified":1636184060546},{"_id":"source/images/VNode_object.jpg","hash":"cd4667bc3c1be5badc68b93a7704ed98d86e8013","modified":1636182500960},{"_id":"source/images/VNodes_createElement_return.jpg","hash":"11219750eef053179695bcc154f5e5f1e85d92d2","modified":1636182500974},{"_id":"source/images/micro_and_macro.jpg","hash":"811fdac93af77d0b1e18fc436609a9aecdd2fae7","modified":1636182500954},{"_id":"source/images/eventloop.jpg","hash":"548988804cf04be5770e65ced240c74428023ca0","modified":1636182500945},{"_id":"source/_posts/2019/babel7.md","hash":"0c42bb7bb697fb37f0343c0b75c8bc797c793cb3","modified":1636183845361},{"_id":"source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1636037579667},{"_id":"source/_posts/2019/es-cjs-module.md","hash":"a741c1a3586f1b13a2bcb81cbac844ca41bed8c4","modified":1636183854214},{"_id":"source/_posts/2019/es-module.md","hash":"c57eafba79d8fe436d48e90271fff8c21d8c5030","modified":1636183874755},{"_id":"source/_posts/2019/webpack-inject-plugins.md","hash":"b3f781de5ca20fb521db272215bcbb7794cb80ce","modified":1636183952720},{"_id":"source/_posts/2019/ts-react.md","hash":"354a18d6b6d73f13902192eee0f7e3c04f71ecf2","modified":1636183934482},{"_id":"source/_posts/2019/node-process.md","hash":"1a156d682e7fa7bb430755a7b475fcd80f1a2520","modified":1636183886651},{"_id":"source/_posts/2019/react-purecompent-diff.md","hash":"ebd112d33d0190a73b0c7d5a385f74df847559f3","modified":1636183905034},{"_id":"source/_posts/2018/about-select-element.md","hash":"7b8dc9a6c5d245822dfddae1b84277caf68d0414","modified":1636183297793},{"_id":"source/_posts/2018/async-sync.md","hash":"9bb3aa502260abe04d32872e395ab12c17cf98b6","modified":1636183303735},{"_id":"source/_posts/2018/event-loop.md","hash":"1b07bd07ec4ba5cd106f6fd2716f6273a7afa137","modified":1636183362994},{"_id":"source/_posts/2018/life-circle-in-vue.md","hash":"1d9723633513c13843cdffafa8bef104545e955b","modified":1636183316570},{"_id":"source/_posts/2018/less-module-in-webpack.md","hash":"e7156eae36774d90328e6d1327fa9d8503a4c123","modified":1636183310841},{"_id":"source/_posts/2018/promise.md","hash":"80fcf86a61b4d79bbd2f20335b6935daf01cd005","modified":1636183321339},{"_id":"source/_posts/2018/render-in-vue.md","hash":"2bf437334a66524bf1329ec78545a7d77c8e89e6","modified":1636183324135},{"_id":"source/_posts/2020/URL输入到页面渲染流程.md","hash":"f343edc02150605b6d8fbd0a7248edbb2db67e33","modified":1636184181906},{"_id":"source/_posts/2020/原型和继承初识.md","hash":"ac867e26262ee0fbb3c510b59402838b7319f2c5","modified":1636184171575},{"_id":"source/_posts/2018/thread-process.md","hash":"306f1ecaf0ca1808890612b78083af4f36117126","modified":1636183326703},{"_id":"source/_posts/2020/实现promise_v1.md","hash":"0a4bd7ce6192a6cc2c893010665414611e868ed5","modified":1636184117136},{"_id":"source/_posts/2020/探究原型.md","hash":"525487c11f863aaad87755982796a4601b051258","modified":1636184154647},{"_id":"source/_posts/2020/探究继承.md","hash":"c732a4ee759c20ada537d11c257afee01784bf37","modified":1636184144757},{"_id":"source/_posts/2020/实现promise_v2.md","hash":"3671f50e8e6272d38744cc9f27e974d7bf94dad6","modified":1636184135757},{"_id":"source/_posts/2020/搞懂redux.md","hash":"9aad36bcb85aa13185095cba1523b2d16c803938","modified":1636184100566},{"_id":"source/images/browser_render.png","hash":"a690ac85045146ec132d424b7ec6fb95acf80a54","modified":1636184060294},{"_id":"themes/pure/.gitignore","hash":"dbb41a2f30c98cb9de173d82736c46266c901cda","modified":1636033848311},{"_id":"themes/pure/_config.yml","hash":"0f210813370f99472eaf485f4971a6c42fc069bd","modified":1636185050619},{"_id":"themes/pure/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1636033848311},{"_id":"themes/pure/README.md","hash":"5861cec81712af9197a210fd5212d007aad8b0de","modified":1636033848312},{"_id":"themes/pure/README.cn.md","hash":"a634af4addbb57088935e060e8ec6035ea7bab76","modified":1636033848311},{"_id":"themes/pure/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1636033848316},{"_id":"themes/pure/_config.yml.example","hash":"4714f87fdb6d4a6ea5ece84f4fe37f922337f14d","modified":1636033848312},{"_id":"themes/pure/package.json","hash":"a61723eead5cae2c4d9f0f05cf40d2de7c286fee","modified":1636033848359},{"_id":"themes/pure/languages/en.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1636033848317},{"_id":"themes/pure/languages/zh-CN.yml","hash":"057ebc043f09449af9768791c89c86dfc2938365","modified":1636033848318},{"_id":"themes/pure/languages/zh-TW.yml","hash":"6d27c3114be539b8783ffce944f68b2e26a8c3b9","modified":1636033848318},{"_id":"themes/pure/layout/archive.ejs","hash":"ded5d953b35666e30f4c6e48e2d2c62af8d95ebf","modified":1636033848357},{"_id":"themes/pure/layout/books.ejs","hash":"6c64719cd7071b5319b01339aa524fdaab391385","modified":1636033848357},{"_id":"themes/pure/layout/about.ejs","hash":"516539264db53b18720d1cedcd78f054342316b4","modified":1636183716120},{"_id":"themes/pure/layout/layout.ejs","hash":"a29ab2e881954a252bfc0dc1a7eb5aa52768dd2a","modified":1636033848358},{"_id":"themes/pure/layout/categories.ejs","hash":"22a2bc1712dd9ba1a3027e875d636132d334fb00","modified":1636033848357},{"_id":"themes/pure/layout/page.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1636033848358},{"_id":"themes/pure/layout/index.ejs","hash":"07825d8d8b21eb7b694f5585567b9df5c5a91a60","modified":1636033848358},{"_id":"themes/pure/layout/category.ejs","hash":"3ca5651bbce7b0c280c906468f2eb18c2e55ebcb","modified":1636033848357},{"_id":"themes/pure/layout/links.ejs","hash":"77c5d1561e2c606c5b3bb39610133d84324074df","modified":1636033848358},{"_id":"themes/pure/layout/repository.ejs","hash":"fe4b3e051a8b0debe9ee22c2cc2cc935d92ee23f","modified":1636033848359},{"_id":"themes/pure/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1636033848375},{"_id":"themes/pure/layout/post.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1636033848358},{"_id":"themes/pure/layout/tags.ejs","hash":"29f19a6ed10f8b1f069259a7aeaaacddcfaa2ed4","modified":1636033848359},{"_id":"themes/pure/source/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1636033848378},{"_id":"themes/pure/layout/tag.ejs","hash":"df60564c162f7ad3422f8959dfea19351857a7cd","modified":1636033848359},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1636033848310},{"_id":"themes/pure/layout/_common/header.ejs","hash":"3d739d1e2b2991927c08ec222db123830a44a519","modified":1636033848319},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/bug_report.md","hash":"83d211c67c12e8c1f6e9f796cfd0cecbf5160e15","modified":1636033848310},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/custom.md","hash":"84208538d48505ee8e49812cb336eb9882e08dc7","modified":1636033848310},{"_id":"themes/pure/layout/_common/footer.ejs","hash":"cdc48ec70d9202b947f2a9334234d038d7014a7d","modified":1636033848318},{"_id":"themes/pure/layout/_common/script.ejs","hash":"0031114d2a58f8601c2869f78ceedc75a10be90d","modified":1636033848319},{"_id":"themes/pure/layout/_common/head.ejs","hash":"a48ef0fa22712b29ec044b9e5134461f3a21c10d","modified":1636033848318},{"_id":"themes/pure/layout/_search/index.ejs","hash":"f8d5a9c3f777250f5fb6512bba585307f784d5cd","modified":1636033848349},{"_id":"themes/pure/layout/_common/social.ejs","hash":"a35a2610e9da762df96587b76b51470507a88cad","modified":1636033848319},{"_id":"themes/pure/layout/_search/index-mobile.ejs","hash":"c726e234c0166da69fdfbd3dd613a5eaf4c80258","modified":1636033848349},{"_id":"themes/pure/layout/_search/baidu.ejs","hash":"67aab280a3ea34429f086cc5c3de7de17727c567","modified":1636033848349},{"_id":"themes/pure/layout/_search/insight.ejs","hash":"4af3e92ef98bedba9680d45699cb04dde4640536","modified":1636033848349},{"_id":"themes/pure/layout/_widget/archive.ejs","hash":"af8ad7f62877764b75d5272d9d899fd6c8e3845c","modified":1636033848350},{"_id":"themes/pure/layout/_widget/board.ejs","hash":"acd27451be52703e670ce0b313f2da6fa24071e4","modified":1636033848356},{"_id":"themes/pure/layout/_search/swiftype.ejs","hash":"4baeca36e410181300ae7d47ba1fb4755bcfcff0","modified":1636033848350},{"_id":"themes/pure/layout/_widget/tagcloud.ejs","hash":"3291108e5411c48b2c5b3e17adace6ffa90d1c29","modified":1636033848357},{"_id":"themes/pure/layout/_widget/recent_posts.ejs","hash":"8942d60311797a591ba2d157c5cdd23e85ceb694","modified":1636033848356},{"_id":"themes/pure/layout/_widget/category.ejs","hash":"331b7642a0f58b9088b937436ab39076a4c5dd7e","modified":1636033848356},{"_id":"themes/pure/layout/_widget/tag.ejs","hash":"487628925da5fcac91463cdad3d9e55d071bd5ed","modified":1636033848356},{"_id":"themes/pure/layout/_script/analytics.ejs","hash":"e756a81f8c20a187fb863b9689f2f1fa15e2f4e1","modified":1636033848346},{"_id":"themes/pure/layout/_script/comment.ejs","hash":"6f951510bab9dc15474b6664e0329defccf29a30","modified":1636033848346},{"_id":"themes/pure/layout/_script/fancybox.ejs","hash":"8f1be01e70a15b2c31ae57d8c6bce54622ebf8a7","modified":1636033848348},{"_id":"themes/pure/layout/_script/douban.ejs","hash":"ee21c4e7ccac26ff2ab6d1d178447fd11fea4d7e","modified":1636033848347},{"_id":"themes/pure/layout/_script/pv.ejs","hash":"fb9b5f16029f2ccef4b83cf4facfdcdd748b65b4","modified":1636033848348},{"_id":"themes/pure/layout/_script/mathjax.ejs","hash":"f618393ab971b2faa80d541f2e6a553d9ace9816","modified":1636033848348},{"_id":"themes/pure/layout/_partial/archive-book.ejs","hash":"977f97f3636947006ad738e502858c46d4cd5ec7","modified":1636033848320},{"_id":"themes/pure/layout/_script/repository.ejs","hash":"14f2e7d4c1055ff6a5f5867dc0e9a9f6f4c28fe1","modified":1636033848348},{"_id":"themes/pure/layout/_script/search.ejs","hash":"7be33dc260ce788aa1a2cd3bd0386d95057533cb","modified":1636033848349},{"_id":"themes/pure/layout/_partial/archive-category.ejs","hash":"9c364fd6b5172890784141802f5f466241d233fd","modified":1636033848320},{"_id":"themes/pure/layout/_partial/archive-link.ejs","hash":"fe4d9bf526d8176683cea89b8561ced571374db0","modified":1636033848320},{"_id":"themes/pure/layout/_partial/archive-list.ejs","hash":"c66c86d6a6a90e00494c380603426fc0f4006311","modified":1636033848322},{"_id":"themes/pure/layout/_partial/archive-tag.ejs","hash":"5de90244c3cedad531cccc03c40e5f9a3aef3c61","modified":1636033848323},{"_id":"themes/pure/layout/_partial/archive-post.ejs","hash":"13039fec017332029122ef99901755fcecbfc8ea","modified":1636033848323},{"_id":"themes/pure/layout/_partial/article.ejs","hash":"0f9b71de0087d1f777d92c5a0f3873971aec5a5b","modified":1636033848324},{"_id":"themes/pure/layout/_partial/archive-repository.ejs","hash":"e39dc762d9fe238cede462532e40eaa3d8651122","modified":1636033848323},{"_id":"themes/pure/layout/_partial/article-about.ejs","hash":"7b80319daeb63401d1745b81cd9a6d1d21a4fb60","modified":1636033848324},{"_id":"themes/pure/layout/_partial/archive.ejs","hash":"4d6793f50d41fbd47dc50aa36b24d496006bba6c","modified":1636033848323},{"_id":"themes/pure/layout/_partial/sidebar-toc.ejs","hash":"152538ceceb0fdef65c46470ebf0189f7b891c5b","modified":1636033848341},{"_id":"themes/pure/layout/_partial/sidebar.ejs","hash":"2aa8a9f90838e7c105e75e6d3d03cbf860bb1239","modified":1636033848341},{"_id":"themes/pure/layout/_partial/item-post.ejs","hash":"9f755b0da1ea928dece32c2050d8a04b3a9fb13b","modified":1636033848324},{"_id":"themes/pure/layout/_partial/pagination.ejs","hash":"41a319642da5af07d6cfb8525796aa610b721879","modified":1636033848324},{"_id":"themes/pure/layout/_partial/sidebar-about.ejs","hash":"46da1ee327b8af107335146bd8fc131eee6c9c4f","modified":1636033848341},{"_id":"themes/pure/source/fonts/README.md","hash":"c5772b99ad81291fb137b330813f866bdceea0a3","modified":1636033848378},{"_id":"themes/pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1636033848381},{"_id":"themes/pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1636033848381},{"_id":"themes/pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1636033848379},{"_id":"themes/pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1636033848384},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1636033848384},{"_id":"themes/pure/source/images/avatar.jpg","hash":"5ca5fc15f52d394a64628689562183a4b40521dc","modified":1636185379002},{"_id":"themes/pure/source/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1636033848388},{"_id":"themes/pure/_source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1636033848313},{"_id":"themes/pure/_source/_data/links.yml","hash":"aa443a4508550820c77c2a4f6abff1d38ad85054","modified":1636033848313},{"_id":"themes/pure/source/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1636033848388},{"_id":"themes/pure/_source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1636033848314},{"_id":"themes/pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1636033848388},{"_id":"themes/pure/_source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1636033848315},{"_id":"themes/pure/_source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1636033848314},{"_id":"themes/pure/_source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1636033848314},{"_id":"themes/pure/_source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1636033848313},{"_id":"themes/pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"f314be7860c1d5930f1600d010e3120ba5c85325","modified":1636033848342},{"_id":"themes/pure/layout/_script/_analytics/google-analytics.ejs","hash":"54f1dc9375cbdb65464e0ac1b58847aa5e8bc6a5","modified":1636033848342},{"_id":"themes/pure/_source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1636033848316},{"_id":"themes/pure/_source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1636033848316},{"_id":"themes/pure/layout/_script/_search/insight.ejs","hash":"3543c11d060feaf9381b5d87564b01ffef0e0a59","modified":1636033848346},{"_id":"themes/pure/layout/_script/_search/baidu.ejs","hash":"9b60ffa2e2725a993e9cecfb81ddedd9b9361011","modified":1636033848346},{"_id":"themes/pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"77defb41a1613a758ff5a6a5128c6107fc584190","modified":1636033848342},{"_id":"themes/pure/layout/_script/_comment/gitalk.ejs","hash":"fb01f1631c3ae7fe6211dc03233506cb344229be","modified":1636033848343},{"_id":"themes/pure/layout/_script/_comment/valine.ejs","hash":"acf81f9a59dc45f197d723f70484de5fcd166577","modified":1636033848345},{"_id":"themes/pure/layout/_script/_comment/disqus.ejs","hash":"a051e3eddc75586e69131c29ab8c89d69626e0fd","modified":1636033848343},{"_id":"themes/pure/layout/_script/_comment/gitment.ejs","hash":"a64852076483395738a398deb4c10bdb0f3b7b71","modified":1636033848345},{"_id":"themes/pure/layout/_script/_comment/livere.ejs","hash":"5ab997d5ee4475d2f89f882fab4a52648dbe0e30","modified":1636033848345},{"_id":"themes/pure/layout/_partial/post/comment.ejs","hash":"3c0da69fcea6ccfd97b82d50e740107a88eec5c4","modified":1636033848335},{"_id":"themes/pure/layout/_partial/post/date.ejs","hash":"7d4979652998abf92a64bfae8157b70d6e514057","modified":1636033848335},{"_id":"themes/pure/layout/_script/_comment/youyan.ejs","hash":"095649a173573d03b5845c2e331ec7be976b152a","modified":1636033848346},{"_id":"themes/pure/layout/_partial/post/copyright.ejs","hash":"0a99c99992fb1e97bf5a57e05179f5680d69dcc8","modified":1636033848335},{"_id":"themes/pure/layout/_partial/post/category.ejs","hash":"fcee6b4aef8b6c4627831ff8dbb2d73478511426","modified":1636033848331},{"_id":"themes/pure/layout/_partial/post/pv.ejs","hash":"ec3ccf322432afc2761f860c5a3000ac34d46e4c","modified":1636033848339},{"_id":"themes/pure/layout/_partial/post/tag.ejs","hash":"39f53ead07f75c181a7ba93e586dd1b8171620f1","modified":1636033848339},{"_id":"themes/pure/layout/_partial/post/donate.ejs","hash":"a251dc34d660601a2e8b7d98b3bfe2b9023dbbce","modified":1636033848338},{"_id":"themes/pure/layout/_partial/post/nav.ejs","hash":"95eabc0fe4033ec61b240a16eeaf7dc62a9e3da1","modified":1636033848339},{"_id":"themes/pure/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1636033848339},{"_id":"themes/pure/layout/_partial/post/wordcount.ejs","hash":"bd06c4c8449ed96aabf655fe1ae3be1f0707b81e","modified":1636033848341},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1636033848383},{"_id":"themes/pure/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1636033848341},{"_id":"themes/pure/layout/_partial/post/thumbnail.ejs","hash":"080d5c5f3e95accf51893a7092695fe32d34a087","modified":1636033848340},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1636033848383},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1636033848384},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1636033848383},{"_id":"themes/pure/source/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1636033848382},{"_id":"themes/pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1636033848364},{"_id":"themes/pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1636033848362},{"_id":"themes/pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1636033848365},{"_id":"themes/pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1636033848363},{"_id":"themes/pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1636033848366},{"_id":"themes/pure/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1636033848389},{"_id":"themes/pure/source/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1636033848392},{"_id":"themes/pure/source/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1636033848390},{"_id":"themes/pure/source/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1636033848376},{"_id":"themes/pure/source/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1636033848377},{"_id":"themes/pure/source/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1636033848381},{"_id":"themes/pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1636033848391},{"_id":"themes/pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1636033848375},{"_id":"source/images/browser_navigator.png","hash":"d337c7e412bfc7f3c2dec22def7efed437e4472b","modified":1636184060274},{"_id":"public/content.json","hash":"cc64b019d2bbd0efd6a3dc49e6fe407182145996","modified":1636186858125},{"_id":"public/atom.xml","hash":"62262f89cba7c7991335d8466bfd392c01bf1cf1","modified":1636186858125},{"_id":"public/sitemap.xml","hash":"4b952447fd9696c8cce1a80161557506bb25ba7b","modified":1636186858125},{"_id":"public/about/index.html","hash":"1f7c4d7fd96fcf7c700ef7d48fb2b4b50fcab623","modified":1636186858125},{"_id":"public/tags/index.html","hash":"bded2fe2735e3127db232435542fd701eeab8c85","modified":1636186858125},{"_id":"public/2020/12/30/2020/URL输入到页面渲染流程/index.html","hash":"f9f09b69079f4fd532bf020eb4f83da8bd66e68f","modified":1636186858125},{"_id":"public/archives/index.html","hash":"2ead5ccd6799a5ad90b103be4ec1a83162ce79ff","modified":1636186858125},{"_id":"public/archives/page/2/index.html","hash":"8bcb8111d64eb820d5414e087d1fbbddba2def6d","modified":1636186858125},{"_id":"public/archives/page/3/index.html","hash":"f4813b7bca305aa6c83dadfd4bbb9cafa50a3584","modified":1636186858125},{"_id":"public/archives/2018/index.html","hash":"a2b7549dcc7e2db513d7301c5518f252c2c17f08","modified":1636186858125},{"_id":"public/archives/2018/12/index.html","hash":"e5b04ff9afca2e978b22f1b9a27f1e55a39f696b","modified":1636186858125},{"_id":"public/archives/2019/index.html","hash":"bcf940f9405db6190aa3d9ba9e2df0862bad7eaa","modified":1636186858125},{"_id":"public/archives/2019/12/index.html","hash":"5c2748063ba61dfaf44af62bb933f061eb4a30f4","modified":1636186858125},{"_id":"public/archives/2020/index.html","hash":"bb936edc48785d9c415f278ddd9b5a91d5a5a7bd","modified":1636186858125},{"_id":"public/archives/2020/12/index.html","hash":"f4b0e2f820de806a7475879804cb17b22a72cdab","modified":1636186858125},{"_id":"public/index.html","hash":"01b6e4bb366cd1d03825e09a7d34b028edb36ae6","modified":1636186858125},{"_id":"public/page/2/index.html","hash":"97bdd45fd410e0b6f6f2d721f95308bd6f72991b","modified":1636186858125},{"_id":"public/page/3/index.html","hash":"df9032095ff92afdf25ab1e276d51b21b4d9b3a5","modified":1636186858125},{"_id":"public/2020/12/30/2020/原型和继承初识/index.html","hash":"e67cdba88d7e50be54d11097d09b72f4a0282d4f","modified":1636186858125},{"_id":"public/2020/12/30/2020/实现promise_v1/index.html","hash":"d1bad9c99201adc1aabdc8df4cf878aacd23dafa","modified":1636186858125},{"_id":"public/2020/12/30/2020/探究继承/index.html","hash":"36c0ed1abe586c9328ceedd3b2b07ef672b6eb84","modified":1636186858125},{"_id":"public/2020/12/30/2020/实现promise_v2/index.html","hash":"ae736c4812b99d95f1cfc4d43760e09312eaedb9","modified":1636186858125},{"_id":"public/2020/12/30/2020/探究原型/index.html","hash":"6ae4c0cb58d88b88f5f4f1e75ab9b83ff40e3010","modified":1636186858125},{"_id":"public/2020/12/30/2020/搞懂redux/index.html","hash":"a26753ffe26743f2c47dfd80fe21bc60cb69c275","modified":1636186858125},{"_id":"public/2019/12/30/2019/babel7/index.html","hash":"0d295c242c8e42efb836f9f539448b72521141a7","modified":1636186858125},{"_id":"public/2019/12/30/2019/es-cjs-module/index.html","hash":"737b49ea9b530ec07129f324a9ebbce21177b588","modified":1636186858125},{"_id":"public/2019/12/30/2019/es-module/index.html","hash":"0d56680988103dd2cacb7f63dd38bab692a96324","modified":1636186858125},{"_id":"public/2019/12/30/2019/node-process/index.html","hash":"5c6fdfb02059636565e6a2d4f60318b1da920a50","modified":1636186858125},{"_id":"public/2019/12/30/2019/react-purecompent-diff/index.html","hash":"1588b0cdfaf85fda629514c59091de0f286bc6f5","modified":1636186858125},{"_id":"public/2019/12/30/2019/ts-react/index.html","hash":"a96dfe29544e2bf8c0d40fbaa3c5a09c99190d16","modified":1636186858125},{"_id":"public/2019/12/30/2019/webpack-inject-plugins/index.html","hash":"d4722fc6e2ac3c9f36bf8a98d25e0fb6f9f9dc00","modified":1636186858125},{"_id":"public/2018/12/30/2018/about-select-element/index.html","hash":"819d2da623883827abe254c6f34b18218232749b","modified":1636186858125},{"_id":"public/2018/12/30/2018/async-sync/index.html","hash":"c040ad9f23c03944aebc6858224563a38e722218","modified":1636186858125},{"_id":"public/2018/12/30/2018/event-loop/index.html","hash":"7074cd7efd734ce8d1c0de9c56a40023ee382f38","modified":1636186858125},{"_id":"public/2018/12/30/2018/life-circle-in-vue/index.html","hash":"bca7cba6b9339142dbc99de51578957968960cd4","modified":1636186858125},{"_id":"public/2018/12/30/2018/promise/index.html","hash":"ce1f36b5ca63c578266bf290a6f5b6f016c75924","modified":1636186858125},{"_id":"public/2018/12/30/2018/less-module-in-webpack/index.html","hash":"af89b9c166036454331ecd81ad825ea35405f02c","modified":1636186858125},{"_id":"public/2018/12/30/2018/render-in-vue/index.html","hash":"a72f125a52764df0e3accfbaaa31c2097bb2e58f","modified":1636186858125},{"_id":"public/2018/12/30/2018/thread-process/index.html","hash":"0ee1fa32f9e055ed28bd0838fdd1a40fde7fab75","modified":1636186858125},{"_id":"public/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1636186858125},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1636186858125},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1636186858125},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1636186858125},{"_id":"public/images/avatar.jpg","hash":"5ca5fc15f52d394a64628689562183a4b40521dc","modified":1636186858125},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1636186858125},{"_id":"public/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1636186858125},{"_id":"public/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1636186858125},{"_id":"public/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1636186858125},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1636186858125},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1636186858125},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1636186858125},{"_id":"public/images/Jietu20200525-170153.jpg","hash":"bdc8ea8ed1a7a5c3720c2c1b5bc3882caf824593","modified":1636186858125},{"_id":"public/images/Jietu20200525-160258.jpg","hash":"0cd9beb726aa3459bc12db8048caa387a9328c91","modified":1636186858125},{"_id":"public/images/Jietu20200529-212414.jpg","hash":"2e115d90d78aae62cc715f74a304dd5ef124a135","modified":1636186858125},{"_id":"public/images/Jietu20200525-170710.jpg","hash":"dbe657b4f947eac6e581d8eb7d51bfaa3dd74377","modified":1636186858125},{"_id":"public/images/Jietu20200529-212609.jpg","hash":"c3789b845d4cff85955cf615942d0bb366ce104a","modified":1636186858125},{"_id":"public/images/Jietu20200807-100039.jpg","hash":"314abea0d48224cf6b1725ffc904b03fe9020173","modified":1636186858125},{"_id":"public/images/VNode_object.jpg","hash":"cd4667bc3c1be5badc68b93a7704ed98d86e8013","modified":1636186858125},{"_id":"public/images/VNodes_createElement_return.jpg","hash":"11219750eef053179695bcc154f5e5f1e85d92d2","modified":1636186858125},{"_id":"public/images/eventloop.jpg","hash":"548988804cf04be5770e65ced240c74428023ca0","modified":1636186858125},{"_id":"public/images/micro_and_macro.jpg","hash":"811fdac93af77d0b1e18fc436609a9aecdd2fae7","modified":1636186858125},{"_id":"public/fonts/README.html","hash":"3b9daaf126709e3bbce5926e15d599f1fe877921","modified":1636186858125},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1636186858125},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1636186858125},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1636186858125},{"_id":"public/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1636186858125},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1636186858125},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1636186858125},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1636186858125},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1636186858125},{"_id":"public/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1636186858125},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1636186858125},{"_id":"public/images/browser_render.png","hash":"a690ac85045146ec132d424b7ec6fb95acf80a54","modified":1636186858125},{"_id":"public/images/browser_navigator.png","hash":"d337c7e412bfc7f3c2dec22def7efed437e4472b","modified":1636186858125}],"Category":[],"Data":[],"Page":[{"title":"关于","description":"个人简介","layout":"about","comments":0,"sidebar":"custom","_content":"\n阿里巴巴打工中...","source":"about/index.md","raw":"---\ntitle: 关于\ndescription: 个人简介\nlayout: about\ncomments: false\nsidebar: custom\n---\n\n阿里巴巴打工中...","date":"2021-11-06T07:27:06.381Z","updated":"2021-11-06T07:27:06.381Z","path":"about/index.html","_id":"ckvnjeryj00006hufcfryf83t","content":"<p>阿里巴巴打工中…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>阿里巴巴打工中…</p>\n"},{"title":"标签","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nlayout: tags\ncomments: false\n---\n","date":"2021-11-04T14:52:59.668Z","updated":"2021-11-04T14:52:59.667Z","path":"tags/index.html","_id":"ckvnjeryo00026huf0q7s404b","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Babel7 常见配置和概念。","date":"2019-12-29T16:00:00.000Z","_content":"\n## 安装\n\n我这里就用`yarn`了，`npm`一样\n\n```js\n  yarn add @babel/core @babel/cli @babel/preset-env -D\n  yarn add @babel/polyfill\n```\n\n大致先说下装了些啥，`core`核心，`cli`工具，可以让我们使用命令行来运行`babel`命令。\n\n`preset-env`主角之一，env 是已经在浏览器标准中的意思，Babel 官方的一个新 API 插件集合，可以将一些 ES6+的新 API 转换成 ES5。搭配`polyfill`主角之一，模拟一个 ES6+的环境，让我们可以使用新的特性。如`promise`等。\n\n## 怎么配置 Babel\n\n官方推荐用`babel.config.js`，我们可以在里面写 JS，比如对环境`ENV`不同，做一些不同的配置。也支持`.babelrc`文件，这是个独立的文件，通常跟放在项目的根目录。当然你也可以写在`package.json`中，以`babel`为`key`来写配置。\n\n大抵最终导出的其实就两样东西，`plugins`和`presets`:\n\n```js\n  {\n    presets: [],\n    plugins: []\n  }\n```\n\n## Plugins 配置\n\n数组格式，可以省略`babel-plugin-`\n\n```js\n  {\n    \"plugins\": [\n      \"myPlugin\", // 同等\n      \"babel-plugin-myPlugin\"\n    ]\n  }\n```\n\n对域的写法同样适合\n\n```js\n  {\n    \"plugins\": [\n      \"@babel/babel-plugin-name\", // 同等\n      \"@babel/name\"\n    ]\n  }\n```\n\n如果单独某个插件需要配置项，则在数组第二个位置写个配置对象。每个插件即一个数组：\n\n```js\n{\n  \"plugins\": [\n    [\"transform-async-to-module-method\", {\n      \"module\": \"bluebired\"\n    }]\n  ]\n}\n```\n\n同理，`presets`也是这样对单独项写配置。\n\n**注意加载顺序**\n\n1. `plugins`是从第一个到最后一个。\n2. `presets`是从最后一个到第一个。原因官方说是大部分用户会喜欢`es2015`写在前面，\n3. 插件在`presets`之前开始。\n\n## Presets\n\n顾名思义，预设。官方提供的`@babel/preset-env`等其实本质就是一个插件数组而已，无非是用了哪些插件。支持包含带选项的`plugin`或其他`presets`\n\n```js\nmodule.exports = function() {\n  return {\n    plugins: [\n      'pluginA',\n      'pluginB',\n      [\n        'pluginC',\n        {\n          opt: 1\n        }\n      ]\n    ],\n    presets: [require('@babel/preset-env')]\n  };\n};\n```\n\n关于路径这块，可以绝对，相对路径，也可以全名（从`node_modules`上找）。\n\n至于配置的写法，在`Plugins`中已经说过。这里再提醒下，`presets`是倒序的。\n\n## 关于配置文件\n\n这里注意下有个`Monorepo`的目录模式。大致意思就是多个 repo，在同一个 package 中管理。\n\n## Polyfill\n\n之前提到过，模拟 ES5+的环境。也会少量的在原型链如 String 上添加一些方法，如`includes`。官方推荐使用`@babel/preset-env`，并且设置该`presets`选项的配置`useBuildIns`使用。这样可以达到的效果，我们只需要引入我们用到的`polyfill`代码。\n\n如果你需要所有的ES5+的静态方法，实例方法已经新的API，那你就需要手动在入口文件顶部导入`@babel-polyfill`，缺点是，这样子是会污染全局环境的。\n\n## 使用位置\n\n不管是`CommonJS`还是`ES6 Modules`，我们都需要在应用的入口文件的顶部，加载`@babel/polyfill`。\n\n和`webpack`构建工具一起使用的话，我们有 3 种方式引入`polyfill`。在`.babelrc`中对`presets`里的`env`进行配置项设置，设置`useBuildIns`。\n\n1. 默认是`false`，相当于着在`webpack.config.js`的`entry`数组头部直接加入。\n\n```js\nmodule.exports = {\n  entry: ['@babel/polyfill', './app.js']\n};\n```\n\n2. 设为`usage`，不会在任何地方导入`@babel/polyfill`，而是用到哪些导哪些，但依旧需安装`@babel/polyfill`\n3. 设为`entry`，在入口文件的头部加载。\n\n**注意**\n在`Babel6.x`中，`useBuildIns`只有`true`和`false`。\n\n## plugin-transform-runtime\n\n这个插件，可以重用`Babel`注入的辅助代码，目的是为了减少代码体积。\n\n```js\n// 开发依赖\n`yarn add @babel/plugin-transform-runtime -D`\n\n// 生产依赖\n`yarn add @babel/runtime`\n```\n前者主要是将`helper`代码自动从`babel-runtime/core-js`中引入，不需要我们手动去写。后者相当于一个独立出来的模拟ES5+的环境包，是在打包的时候需要用到的，但为了不污染全局，一些实例属性不能使用。所以这两者是搭配使用的。\n\n## 常用实践\n\n希望达到，复用代码，缩小代码体积，功能还能很全的目标。\n\n**复用代码**，我们需要使用`transform-runtime-plugin`，在开发阶段，自动重写我们的导入代码，全部从`babel/runtime`中导入。\n\n**缩小代码体积**，我们需要按需加载，`transform-runtime-plugin`和`babel/runtime`结合使用就可以达到按需加载，插件会分析我们用到了哪些新的API，如`promise`，则从`import promise2 from '@babel/runtime/core-js/promise`，注意到这里使用的是promise2，所以避免了全局污染。\n\n**功能全**，光有`@babel/runtime`，还不够，它只能帮我们模拟出大部分ES5+环境，但是如`'hello'.includes('h')`等实例方法，是没有的，原因就是不污染全局环境。所以我们还需要`babel-polyfill`，但是`babel-polyfill`包含了完整的ES5+环境，包很大，且数据全局环境引入，会导致污染。所以我们需要一个`babel-preset-env`，这个预置其实就是包含了很多`plugins`，需要哪个，我们用哪个，可以根据开发环境来选择，已达到最小使用`babel-polyfill`，需要设置`useBuildIns`为`usage`，意为不直接引入`babel-polyfill`，而只单独加载用到的。\n","source":"_posts/2019/babel7.md","raw":"---\ntitle: Babel7 常见配置和概念。\ndate: 2019/12/30\n---\n\n## 安装\n\n我这里就用`yarn`了，`npm`一样\n\n```js\n  yarn add @babel/core @babel/cli @babel/preset-env -D\n  yarn add @babel/polyfill\n```\n\n大致先说下装了些啥，`core`核心，`cli`工具，可以让我们使用命令行来运行`babel`命令。\n\n`preset-env`主角之一，env 是已经在浏览器标准中的意思，Babel 官方的一个新 API 插件集合，可以将一些 ES6+的新 API 转换成 ES5。搭配`polyfill`主角之一，模拟一个 ES6+的环境，让我们可以使用新的特性。如`promise`等。\n\n## 怎么配置 Babel\n\n官方推荐用`babel.config.js`，我们可以在里面写 JS，比如对环境`ENV`不同，做一些不同的配置。也支持`.babelrc`文件，这是个独立的文件，通常跟放在项目的根目录。当然你也可以写在`package.json`中，以`babel`为`key`来写配置。\n\n大抵最终导出的其实就两样东西，`plugins`和`presets`:\n\n```js\n  {\n    presets: [],\n    plugins: []\n  }\n```\n\n## Plugins 配置\n\n数组格式，可以省略`babel-plugin-`\n\n```js\n  {\n    \"plugins\": [\n      \"myPlugin\", // 同等\n      \"babel-plugin-myPlugin\"\n    ]\n  }\n```\n\n对域的写法同样适合\n\n```js\n  {\n    \"plugins\": [\n      \"@babel/babel-plugin-name\", // 同等\n      \"@babel/name\"\n    ]\n  }\n```\n\n如果单独某个插件需要配置项，则在数组第二个位置写个配置对象。每个插件即一个数组：\n\n```js\n{\n  \"plugins\": [\n    [\"transform-async-to-module-method\", {\n      \"module\": \"bluebired\"\n    }]\n  ]\n}\n```\n\n同理，`presets`也是这样对单独项写配置。\n\n**注意加载顺序**\n\n1. `plugins`是从第一个到最后一个。\n2. `presets`是从最后一个到第一个。原因官方说是大部分用户会喜欢`es2015`写在前面，\n3. 插件在`presets`之前开始。\n\n## Presets\n\n顾名思义，预设。官方提供的`@babel/preset-env`等其实本质就是一个插件数组而已，无非是用了哪些插件。支持包含带选项的`plugin`或其他`presets`\n\n```js\nmodule.exports = function() {\n  return {\n    plugins: [\n      'pluginA',\n      'pluginB',\n      [\n        'pluginC',\n        {\n          opt: 1\n        }\n      ]\n    ],\n    presets: [require('@babel/preset-env')]\n  };\n};\n```\n\n关于路径这块，可以绝对，相对路径，也可以全名（从`node_modules`上找）。\n\n至于配置的写法，在`Plugins`中已经说过。这里再提醒下，`presets`是倒序的。\n\n## 关于配置文件\n\n这里注意下有个`Monorepo`的目录模式。大致意思就是多个 repo，在同一个 package 中管理。\n\n## Polyfill\n\n之前提到过，模拟 ES5+的环境。也会少量的在原型链如 String 上添加一些方法，如`includes`。官方推荐使用`@babel/preset-env`，并且设置该`presets`选项的配置`useBuildIns`使用。这样可以达到的效果，我们只需要引入我们用到的`polyfill`代码。\n\n如果你需要所有的ES5+的静态方法，实例方法已经新的API，那你就需要手动在入口文件顶部导入`@babel-polyfill`，缺点是，这样子是会污染全局环境的。\n\n## 使用位置\n\n不管是`CommonJS`还是`ES6 Modules`，我们都需要在应用的入口文件的顶部，加载`@babel/polyfill`。\n\n和`webpack`构建工具一起使用的话，我们有 3 种方式引入`polyfill`。在`.babelrc`中对`presets`里的`env`进行配置项设置，设置`useBuildIns`。\n\n1. 默认是`false`，相当于着在`webpack.config.js`的`entry`数组头部直接加入。\n\n```js\nmodule.exports = {\n  entry: ['@babel/polyfill', './app.js']\n};\n```\n\n2. 设为`usage`，不会在任何地方导入`@babel/polyfill`，而是用到哪些导哪些，但依旧需安装`@babel/polyfill`\n3. 设为`entry`，在入口文件的头部加载。\n\n**注意**\n在`Babel6.x`中，`useBuildIns`只有`true`和`false`。\n\n## plugin-transform-runtime\n\n这个插件，可以重用`Babel`注入的辅助代码，目的是为了减少代码体积。\n\n```js\n// 开发依赖\n`yarn add @babel/plugin-transform-runtime -D`\n\n// 生产依赖\n`yarn add @babel/runtime`\n```\n前者主要是将`helper`代码自动从`babel-runtime/core-js`中引入，不需要我们手动去写。后者相当于一个独立出来的模拟ES5+的环境包，是在打包的时候需要用到的，但为了不污染全局，一些实例属性不能使用。所以这两者是搭配使用的。\n\n## 常用实践\n\n希望达到，复用代码，缩小代码体积，功能还能很全的目标。\n\n**复用代码**，我们需要使用`transform-runtime-plugin`，在开发阶段，自动重写我们的导入代码，全部从`babel/runtime`中导入。\n\n**缩小代码体积**，我们需要按需加载，`transform-runtime-plugin`和`babel/runtime`结合使用就可以达到按需加载，插件会分析我们用到了哪些新的API，如`promise`，则从`import promise2 from '@babel/runtime/core-js/promise`，注意到这里使用的是promise2，所以避免了全局污染。\n\n**功能全**，光有`@babel/runtime`，还不够，它只能帮我们模拟出大部分ES5+环境，但是如`'hello'.includes('h')`等实例方法，是没有的，原因就是不污染全局环境。所以我们还需要`babel-polyfill`，但是`babel-polyfill`包含了完整的ES5+环境，包很大，且数据全局环境引入，会导致污染。所以我们需要一个`babel-preset-env`，这个预置其实就是包含了很多`plugins`，需要哪个，我们用哪个，可以根据开发环境来选择，已达到最小使用`babel-polyfill`，需要设置`useBuildIns`为`usage`，意为不直接引入`babel-polyfill`，而只单独加载用到的。\n","slug":"2019/babel7","published":1,"updated":"2021-11-06T07:30:45.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryl00016hufbt1e81qq","content":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我这里就用<code>yarn</code>了，<code>npm</code>一样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add @babel/core @babel/cli @babel/preset-env -D</span><br><span class=\"line\">yarn add @babel/polyfill</span><br></pre></td></tr></table></figure>\n\n<p>大致先说下装了些啥，<code>core</code>核心，<code>cli</code>工具，可以让我们使用命令行来运行<code>babel</code>命令。</p>\n<p><code>preset-env</code>主角之一，env 是已经在浏览器标准中的意思，Babel 官方的一个新 API 插件集合，可以将一些 ES6+的新 API 转换成 ES5。搭配<code>polyfill</code>主角之一，模拟一个 ES6+的环境，让我们可以使用新的特性。如<code>promise</code>等。</p>\n<h2 id=\"怎么配置-Babel\"><a href=\"#怎么配置-Babel\" class=\"headerlink\" title=\"怎么配置 Babel\"></a>怎么配置 Babel</h2><p>官方推荐用<code>babel.config.js</code>，我们可以在里面写 JS，比如对环境<code>ENV</code>不同，做一些不同的配置。也支持<code>.babelrc</code>文件，这是个独立的文件，通常跟放在项目的根目录。当然你也可以写在<code>package.json</code>中，以<code>babel</code>为<code>key</code>来写配置。</p>\n<p>大抵最终导出的其实就两样东西，<code>plugins</code>和<code>presets</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">presets</span>: [],</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Plugins-配置\"><a href=\"#Plugins-配置\" class=\"headerlink\" title=\"Plugins 配置\"></a>Plugins 配置</h2><p>数组格式，可以省略<code>babel-plugin-</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;myPlugin&quot;</span>, <span class=\"comment\">// 同等</span></span><br><span class=\"line\">    <span class=\"string\">&quot;babel-plugin-myPlugin&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对域的写法同样适合</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/babel-plugin-name&quot;</span>, <span class=\"comment\">// 同等</span></span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/name&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果单独某个插件需要配置项，则在数组第二个位置写个配置对象。每个插件即一个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    [<span class=\"string\">&quot;transform-async-to-module-method&quot;</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;module&quot;</span>: <span class=\"string\">&quot;bluebired&quot;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理，<code>presets</code>也是这样对单独项写配置。</p>\n<p><strong>注意加载顺序</strong></p>\n<ol>\n<li><code>plugins</code>是从第一个到最后一个。</li>\n<li><code>presets</code>是从最后一个到第一个。原因官方说是大部分用户会喜欢<code>es2015</code>写在前面，</li>\n<li>插件在<code>presets</code>之前开始。</li>\n</ol>\n<h2 id=\"Presets\"><a href=\"#Presets\" class=\"headerlink\" title=\"Presets\"></a>Presets</h2><p>顾名思义，预设。官方提供的<code>@babel/preset-env</code>等其实本质就是一个插件数组而已，无非是用了哪些插件。支持包含带选项的<code>plugin</code>或其他<code>presets</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">      <span class=\"string\">&#x27;pluginA&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;pluginB&#x27;</span>,</span><br><span class=\"line\">      [</span><br><span class=\"line\">        <span class=\"string\">&#x27;pluginC&#x27;</span>,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">opt</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">presets</span>: [<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/preset-env&#x27;</span>)]</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>关于路径这块，可以绝对，相对路径，也可以全名（从<code>node_modules</code>上找）。</p>\n<p>至于配置的写法，在<code>Plugins</code>中已经说过。这里再提醒下，<code>presets</code>是倒序的。</p>\n<h2 id=\"关于配置文件\"><a href=\"#关于配置文件\" class=\"headerlink\" title=\"关于配置文件\"></a>关于配置文件</h2><p>这里注意下有个<code>Monorepo</code>的目录模式。大致意思就是多个 repo，在同一个 package 中管理。</p>\n<h2 id=\"Polyfill\"><a href=\"#Polyfill\" class=\"headerlink\" title=\"Polyfill\"></a>Polyfill</h2><p>之前提到过，模拟 ES5+的环境。也会少量的在原型链如 String 上添加一些方法，如<code>includes</code>。官方推荐使用<code>@babel/preset-env</code>，并且设置该<code>presets</code>选项的配置<code>useBuildIns</code>使用。这样可以达到的效果，我们只需要引入我们用到的<code>polyfill</code>代码。</p>\n<p>如果你需要所有的ES5+的静态方法，实例方法已经新的API，那你就需要手动在入口文件顶部导入<code>@babel-polyfill</code>，缺点是，这样子是会污染全局环境的。</p>\n<h2 id=\"使用位置\"><a href=\"#使用位置\" class=\"headerlink\" title=\"使用位置\"></a>使用位置</h2><p>不管是<code>CommonJS</code>还是<code>ES6 Modules</code>，我们都需要在应用的入口文件的顶部，加载<code>@babel/polyfill</code>。</p>\n<p>和<code>webpack</code>构建工具一起使用的话，我们有 3 种方式引入<code>polyfill</code>。在<code>.babelrc</code>中对<code>presets</code>里的<code>env</code>进行配置项设置，设置<code>useBuildIns</code>。</p>\n<ol>\n<li>默认是<code>false</code>，相当于着在<code>webpack.config.js</code>的<code>entry</code>数组头部直接加入。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: [<span class=\"string\">&#x27;@babel/polyfill&#x27;</span>, <span class=\"string\">&#x27;./app.js&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>设为<code>usage</code>，不会在任何地方导入<code>@babel/polyfill</code>，而是用到哪些导哪些，但依旧需安装<code>@babel/polyfill</code></li>\n<li>设为<code>entry</code>，在入口文件的头部加载。</li>\n</ol>\n<p><strong>注意</strong><br>在<code>Babel6.x</code>中，<code>useBuildIns</code>只有<code>true</code>和<code>false</code>。</p>\n<h2 id=\"plugin-transform-runtime\"><a href=\"#plugin-transform-runtime\" class=\"headerlink\" title=\"plugin-transform-runtime\"></a>plugin-transform-runtime</h2><p>这个插件，可以重用<code>Babel</code>注入的辅助代码，目的是为了减少代码体积。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开发依赖</span></span><br><span class=\"line\"><span class=\"string\">`yarn add @babel/plugin-transform-runtime -D`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生产依赖</span></span><br><span class=\"line\"><span class=\"string\">`yarn add @babel/runtime`</span></span><br></pre></td></tr></table></figure>\n<p>前者主要是将<code>helper</code>代码自动从<code>babel-runtime/core-js</code>中引入，不需要我们手动去写。后者相当于一个独立出来的模拟ES5+的环境包，是在打包的时候需要用到的，但为了不污染全局，一些实例属性不能使用。所以这两者是搭配使用的。</p>\n<h2 id=\"常用实践\"><a href=\"#常用实践\" class=\"headerlink\" title=\"常用实践\"></a>常用实践</h2><p>希望达到，复用代码，缩小代码体积，功能还能很全的目标。</p>\n<p><strong>复用代码</strong>，我们需要使用<code>transform-runtime-plugin</code>，在开发阶段，自动重写我们的导入代码，全部从<code>babel/runtime</code>中导入。</p>\n<p><strong>缩小代码体积</strong>，我们需要按需加载，<code>transform-runtime-plugin</code>和<code>babel/runtime</code>结合使用就可以达到按需加载，插件会分析我们用到了哪些新的API，如<code>promise</code>，则从<code>import promise2 from &#39;@babel/runtime/core-js/promise</code>，注意到这里使用的是promise2，所以避免了全局污染。</p>\n<p><strong>功能全</strong>，光有<code>@babel/runtime</code>，还不够，它只能帮我们模拟出大部分ES5+环境，但是如<code>&#39;hello&#39;.includes(&#39;h&#39;)</code>等实例方法，是没有的，原因就是不污染全局环境。所以我们还需要<code>babel-polyfill</code>，但是<code>babel-polyfill</code>包含了完整的ES5+环境，包很大，且数据全局环境引入，会导致污染。所以我们需要一个<code>babel-preset-env</code>，这个预置其实就是包含了很多<code>plugins</code>，需要哪个，我们用哪个，可以根据开发环境来选择，已达到最小使用<code>babel-polyfill</code>，需要设置<code>useBuildIns</code>为<code>usage</code>，意为不直接引入<code>babel-polyfill</code>，而只单独加载用到的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我这里就用<code>yarn</code>了，<code>npm</code>一样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add @babel/core @babel/cli @babel/preset-env -D</span><br><span class=\"line\">yarn add @babel/polyfill</span><br></pre></td></tr></table></figure>\n\n<p>大致先说下装了些啥，<code>core</code>核心，<code>cli</code>工具，可以让我们使用命令行来运行<code>babel</code>命令。</p>\n<p><code>preset-env</code>主角之一，env 是已经在浏览器标准中的意思，Babel 官方的一个新 API 插件集合，可以将一些 ES6+的新 API 转换成 ES5。搭配<code>polyfill</code>主角之一，模拟一个 ES6+的环境，让我们可以使用新的特性。如<code>promise</code>等。</p>\n<h2 id=\"怎么配置-Babel\"><a href=\"#怎么配置-Babel\" class=\"headerlink\" title=\"怎么配置 Babel\"></a>怎么配置 Babel</h2><p>官方推荐用<code>babel.config.js</code>，我们可以在里面写 JS，比如对环境<code>ENV</code>不同，做一些不同的配置。也支持<code>.babelrc</code>文件，这是个独立的文件，通常跟放在项目的根目录。当然你也可以写在<code>package.json</code>中，以<code>babel</code>为<code>key</code>来写配置。</p>\n<p>大抵最终导出的其实就两样东西，<code>plugins</code>和<code>presets</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">presets</span>: [],</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Plugins-配置\"><a href=\"#Plugins-配置\" class=\"headerlink\" title=\"Plugins 配置\"></a>Plugins 配置</h2><p>数组格式，可以省略<code>babel-plugin-</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;myPlugin&quot;</span>, <span class=\"comment\">// 同等</span></span><br><span class=\"line\">    <span class=\"string\">&quot;babel-plugin-myPlugin&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对域的写法同样适合</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/babel-plugin-name&quot;</span>, <span class=\"comment\">// 同等</span></span><br><span class=\"line\">    <span class=\"string\">&quot;@babel/name&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果单独某个插件需要配置项，则在数组第二个位置写个配置对象。每个插件即一个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    [<span class=\"string\">&quot;transform-async-to-module-method&quot;</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;module&quot;</span>: <span class=\"string\">&quot;bluebired&quot;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理，<code>presets</code>也是这样对单独项写配置。</p>\n<p><strong>注意加载顺序</strong></p>\n<ol>\n<li><code>plugins</code>是从第一个到最后一个。</li>\n<li><code>presets</code>是从最后一个到第一个。原因官方说是大部分用户会喜欢<code>es2015</code>写在前面，</li>\n<li>插件在<code>presets</code>之前开始。</li>\n</ol>\n<h2 id=\"Presets\"><a href=\"#Presets\" class=\"headerlink\" title=\"Presets\"></a>Presets</h2><p>顾名思义，预设。官方提供的<code>@babel/preset-env</code>等其实本质就是一个插件数组而已，无非是用了哪些插件。支持包含带选项的<code>plugin</code>或其他<code>presets</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">      <span class=\"string\">&#x27;pluginA&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;pluginB&#x27;</span>,</span><br><span class=\"line\">      [</span><br><span class=\"line\">        <span class=\"string\">&#x27;pluginC&#x27;</span>,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">opt</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">presets</span>: [<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@babel/preset-env&#x27;</span>)]</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>关于路径这块，可以绝对，相对路径，也可以全名（从<code>node_modules</code>上找）。</p>\n<p>至于配置的写法，在<code>Plugins</code>中已经说过。这里再提醒下，<code>presets</code>是倒序的。</p>\n<h2 id=\"关于配置文件\"><a href=\"#关于配置文件\" class=\"headerlink\" title=\"关于配置文件\"></a>关于配置文件</h2><p>这里注意下有个<code>Monorepo</code>的目录模式。大致意思就是多个 repo，在同一个 package 中管理。</p>\n<h2 id=\"Polyfill\"><a href=\"#Polyfill\" class=\"headerlink\" title=\"Polyfill\"></a>Polyfill</h2><p>之前提到过，模拟 ES5+的环境。也会少量的在原型链如 String 上添加一些方法，如<code>includes</code>。官方推荐使用<code>@babel/preset-env</code>，并且设置该<code>presets</code>选项的配置<code>useBuildIns</code>使用。这样可以达到的效果，我们只需要引入我们用到的<code>polyfill</code>代码。</p>\n<p>如果你需要所有的ES5+的静态方法，实例方法已经新的API，那你就需要手动在入口文件顶部导入<code>@babel-polyfill</code>，缺点是，这样子是会污染全局环境的。</p>\n<h2 id=\"使用位置\"><a href=\"#使用位置\" class=\"headerlink\" title=\"使用位置\"></a>使用位置</h2><p>不管是<code>CommonJS</code>还是<code>ES6 Modules</code>，我们都需要在应用的入口文件的顶部，加载<code>@babel/polyfill</code>。</p>\n<p>和<code>webpack</code>构建工具一起使用的话，我们有 3 种方式引入<code>polyfill</code>。在<code>.babelrc</code>中对<code>presets</code>里的<code>env</code>进行配置项设置，设置<code>useBuildIns</code>。</p>\n<ol>\n<li>默认是<code>false</code>，相当于着在<code>webpack.config.js</code>的<code>entry</code>数组头部直接加入。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: [<span class=\"string\">&#x27;@babel/polyfill&#x27;</span>, <span class=\"string\">&#x27;./app.js&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>设为<code>usage</code>，不会在任何地方导入<code>@babel/polyfill</code>，而是用到哪些导哪些，但依旧需安装<code>@babel/polyfill</code></li>\n<li>设为<code>entry</code>，在入口文件的头部加载。</li>\n</ol>\n<p><strong>注意</strong><br>在<code>Babel6.x</code>中，<code>useBuildIns</code>只有<code>true</code>和<code>false</code>。</p>\n<h2 id=\"plugin-transform-runtime\"><a href=\"#plugin-transform-runtime\" class=\"headerlink\" title=\"plugin-transform-runtime\"></a>plugin-transform-runtime</h2><p>这个插件，可以重用<code>Babel</code>注入的辅助代码，目的是为了减少代码体积。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开发依赖</span></span><br><span class=\"line\"><span class=\"string\">`yarn add @babel/plugin-transform-runtime -D`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生产依赖</span></span><br><span class=\"line\"><span class=\"string\">`yarn add @babel/runtime`</span></span><br></pre></td></tr></table></figure>\n<p>前者主要是将<code>helper</code>代码自动从<code>babel-runtime/core-js</code>中引入，不需要我们手动去写。后者相当于一个独立出来的模拟ES5+的环境包，是在打包的时候需要用到的，但为了不污染全局，一些实例属性不能使用。所以这两者是搭配使用的。</p>\n<h2 id=\"常用实践\"><a href=\"#常用实践\" class=\"headerlink\" title=\"常用实践\"></a>常用实践</h2><p>希望达到，复用代码，缩小代码体积，功能还能很全的目标。</p>\n<p><strong>复用代码</strong>，我们需要使用<code>transform-runtime-plugin</code>，在开发阶段，自动重写我们的导入代码，全部从<code>babel/runtime</code>中导入。</p>\n<p><strong>缩小代码体积</strong>，我们需要按需加载，<code>transform-runtime-plugin</code>和<code>babel/runtime</code>结合使用就可以达到按需加载，插件会分析我们用到了哪些新的API，如<code>promise</code>，则从<code>import promise2 from &#39;@babel/runtime/core-js/promise</code>，注意到这里使用的是promise2，所以避免了全局污染。</p>\n<p><strong>功能全</strong>，光有<code>@babel/runtime</code>，还不够，它只能帮我们模拟出大部分ES5+环境，但是如<code>&#39;hello&#39;.includes(&#39;h&#39;)</code>等实例方法，是没有的，原因就是不污染全局环境。所以我们还需要<code>babel-polyfill</code>，但是<code>babel-polyfill</code>包含了完整的ES5+环境，包很大，且数据全局环境引入，会导致污染。所以我们需要一个<code>babel-preset-env</code>，这个预置其实就是包含了很多<code>plugins</code>，需要哪个，我们用哪个，可以根据开发环境来选择，已达到最小使用<code>babel-polyfill</code>，需要设置<code>useBuildIns</code>为<code>usage</code>，意为不直接引入<code>babel-polyfill</code>，而只单独加载用到的。</p>\n"},{"title":"webpack 模块化原理（ES+CJS）","date":"2019-12-29T16:00:00.000Z","_content":"\n接着上一篇**webpack 模块化原理(es)**。这篇我们看下 es+cjs，2 种模块混合书写，webpack 是如何处理的。demo 和之前差不多。\n\n```javascript\n// src/index.js\nimport print from './print';\nconsole.log(print); // 应该是{res: 1}\n\n// src/print.js cjs写法\nconst res = 1;\nexports.res = res;\n```\n\n通过 webpack 编译后，代码如下（同样，做了一些处理，去除分隔符，将模块的内部函数格式化下）<br />大部分跟上一篇中解释的一样，我们看下如下几个东西，在这个编译后的 `bundle`  中有使用到。\n\n```javascript\n(function (modules) {\n  // webpackBootstrap\n  // The module cache\n  var installedModules = {};\n\n  // The require function\n  function __webpack_require__(moduleId) {\n    // Check if module is in cache\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = (installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {},\n    });\n\n    // Execute the module function\n    modules[moduleId].call(\n      module.exports,\n      module,\n      module.exports,\n      __webpack_require__\n    );\n\n    // Flag the module as loaded\n    module.l = true;\n\n    // Return the exports of the module\n    return module.exports;\n  }\n\n  // expose the modules object (__webpack_modules__)\n  __webpack_require__.m = modules;\n\n  // expose the module cache\n  __webpack_require__.c = installedModules;\n\n  // define getter function for harmony exports\n  // 处理cjs模块的辅助函数。通过给具体实现exports对象新增一个getter属性。\n  __webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n      Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n  };\n\n  // define __esModule on exports\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n    }\n    Object.defineProperty(exports, '__esModule', { value: true });\n  };\n\n  // create a fake namespace object\n  // mode & 1: value is a module id, require it\n  // mode & 2: merge all properties of value into the ns\n  // mode & 4: return value when already ns object\n  // mode & 8|1: behave like require\n  __webpack_require__.t = function (value, mode) {\n    if (mode & 1) value = __webpack_require__(value);\n    if (mode & 8) return value;\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule)\n      return value;\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n    if (mode & 2 && typeof value != 'string')\n      for (var key in value)\n        __webpack_require__.d(\n          ns,\n          key,\n          function (key) {\n            return value[key];\n          }.bind(null, key)\n        );\n    return ns;\n  };\n\n  // getDefaultExport function for compatibility with non-harmony modules\n  // 针对es和cjs的默认导出，做一些处理。让大家都统一。\n  // 比如如果模块源码是es的，那么模块的exports.__esModule就会为true，在上一篇有解释过。\n  // 该函数通过判断module.exports上有没有__esModule，来区分暴露默认导出应该怎么暴露。\n  // 如果是cjs，它是没有默认导出这个概念的实际上暴露的都是往module.exports = exports，也就是exports身上挂属性。这也就是模块本身，也就是我们这里函数接收的参数module，直接暴露就好了。\n  // 如果是es，它有默认导出，还有部分导出，默认导出挂在了module.exports.default属性上，其他的挂载modulex.exports[xx]上。所以暴露的时候要暴露defaults这个属性值（这个函数接的参数变量，实际上就是{moduleId: xx, l: false, exports: {}}中的exports，因为模块加载函数已经在底部返回了啊, return module.exports）。\n  // 这里稍后（先去看1，2两步骤，在下面）让我们我们结合print.js来讲解\n  // 3. module参数就是{res: 1}。因为print模块源码是cjs写的，所以它没有被打上__esModule=true的标记。\n  // 因此，getter就是第二个函数getModuleExports，这个函数实际上就直接返回了{res: 1}\n  // 接着，调用了d方法，给getModuleExports这个函数，赋了一个a的getter属性，当你访问这个a时，就是调用getModuleExports这个函数，然后又拿到了{res: 1}。可以看出来就是这样a: {res: 1}\n  // d方法返回的就是getModuleExports这个函数。\n  __webpack_require__.n = function (module) {\n    var getter =\n      module && module.__esModule\n        ? function getDefault() {\n            return module['default'];\n          }\n        : function getModuleExports() {\n            return module;\n          };\n    __webpack_require__.d(getter, 'a', getter);\n    return getter;\n  };\n\n  // Object.prototype.hasOwnProperty.call\n  // 借用了hasOwnProperty方法而已。\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  // __webpack_public_path__\n  __webpack_require__.p = '';\n\n  // Load entry module and return exports\n  // 开始加载入口函数\n  return __webpack_require__((__webpack_require__.s = './src/index.js'));\n})({\n  './src/index.js':\n    /*! no exports provided */\n    function (module, __webpack_exports__, __webpack_require__) {\n      'use strict';\n      eval(\n        '__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ \"./src/print.js\");\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_print__WEBPACK_IMPORTED_MODULE_0__);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n//# sourceURL=webpack:///./src/index.js?'\n      );\n      //   __webpack_require__.r(__webpack_exports__)\n      //   1、这里先用webpack自己的模块加载函数来加载print.js，这里函数还是会返回module.exports，只不过我们看print.js模块函数实现可以看到exports.res = res。所以我们这里拿到的就是{res: 1}这个对象而已。\n      //   var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n      //     './src/print.js'\n      //   )\n      //   2. 所以这里__webpack_require__.n({res: 1})，让我们看看上面这个n函数干了些啥？\n      //   var _print__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(\n      //     _print__WEBPACK_IMPORTED_MODULE_0__\n      //   )\n      //   4. 上面的n函数调用完了，返回的是getModuleExports这个函数，且这个函数还有个a属性的getter\n      //   5. 赋值给_print__WEBPACK_IMPORTED_MODULE_0___default后，我们去调用这个函数的a属性，不言而喻，就是{res: 1}。至此大功告成！。\n      //   console.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a)\n    },\n\n  './src/print.js':\n    /*! no static exports found */\n    function (module, exports) {\n      eval(\n        'var res = 1;\\nexports.res = res;\\n\\n//# sourceURL=webpack:///./src/print.js?'\n      );\n      // var res = 1\n      // 因为源码是cjs模块，非es模块，所以没有给exports配__esModule=true的属性（这个配置是通过__webpack_exports__.r函数实现的）\n      // exports.res = res\n    },\n});\n```\n","source":"_posts/2019/es-cjs-module.md","raw":"---\ntitle: webpack 模块化原理（ES+CJS）\ndate: 2019/12/30\n---\n\n接着上一篇**webpack 模块化原理(es)**。这篇我们看下 es+cjs，2 种模块混合书写，webpack 是如何处理的。demo 和之前差不多。\n\n```javascript\n// src/index.js\nimport print from './print';\nconsole.log(print); // 应该是{res: 1}\n\n// src/print.js cjs写法\nconst res = 1;\nexports.res = res;\n```\n\n通过 webpack 编译后，代码如下（同样，做了一些处理，去除分隔符，将模块的内部函数格式化下）<br />大部分跟上一篇中解释的一样，我们看下如下几个东西，在这个编译后的 `bundle`  中有使用到。\n\n```javascript\n(function (modules) {\n  // webpackBootstrap\n  // The module cache\n  var installedModules = {};\n\n  // The require function\n  function __webpack_require__(moduleId) {\n    // Check if module is in cache\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = (installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {},\n    });\n\n    // Execute the module function\n    modules[moduleId].call(\n      module.exports,\n      module,\n      module.exports,\n      __webpack_require__\n    );\n\n    // Flag the module as loaded\n    module.l = true;\n\n    // Return the exports of the module\n    return module.exports;\n  }\n\n  // expose the modules object (__webpack_modules__)\n  __webpack_require__.m = modules;\n\n  // expose the module cache\n  __webpack_require__.c = installedModules;\n\n  // define getter function for harmony exports\n  // 处理cjs模块的辅助函数。通过给具体实现exports对象新增一个getter属性。\n  __webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n      Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n  };\n\n  // define __esModule on exports\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n    }\n    Object.defineProperty(exports, '__esModule', { value: true });\n  };\n\n  // create a fake namespace object\n  // mode & 1: value is a module id, require it\n  // mode & 2: merge all properties of value into the ns\n  // mode & 4: return value when already ns object\n  // mode & 8|1: behave like require\n  __webpack_require__.t = function (value, mode) {\n    if (mode & 1) value = __webpack_require__(value);\n    if (mode & 8) return value;\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule)\n      return value;\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n    if (mode & 2 && typeof value != 'string')\n      for (var key in value)\n        __webpack_require__.d(\n          ns,\n          key,\n          function (key) {\n            return value[key];\n          }.bind(null, key)\n        );\n    return ns;\n  };\n\n  // getDefaultExport function for compatibility with non-harmony modules\n  // 针对es和cjs的默认导出，做一些处理。让大家都统一。\n  // 比如如果模块源码是es的，那么模块的exports.__esModule就会为true，在上一篇有解释过。\n  // 该函数通过判断module.exports上有没有__esModule，来区分暴露默认导出应该怎么暴露。\n  // 如果是cjs，它是没有默认导出这个概念的实际上暴露的都是往module.exports = exports，也就是exports身上挂属性。这也就是模块本身，也就是我们这里函数接收的参数module，直接暴露就好了。\n  // 如果是es，它有默认导出，还有部分导出，默认导出挂在了module.exports.default属性上，其他的挂载modulex.exports[xx]上。所以暴露的时候要暴露defaults这个属性值（这个函数接的参数变量，实际上就是{moduleId: xx, l: false, exports: {}}中的exports，因为模块加载函数已经在底部返回了啊, return module.exports）。\n  // 这里稍后（先去看1，2两步骤，在下面）让我们我们结合print.js来讲解\n  // 3. module参数就是{res: 1}。因为print模块源码是cjs写的，所以它没有被打上__esModule=true的标记。\n  // 因此，getter就是第二个函数getModuleExports，这个函数实际上就直接返回了{res: 1}\n  // 接着，调用了d方法，给getModuleExports这个函数，赋了一个a的getter属性，当你访问这个a时，就是调用getModuleExports这个函数，然后又拿到了{res: 1}。可以看出来就是这样a: {res: 1}\n  // d方法返回的就是getModuleExports这个函数。\n  __webpack_require__.n = function (module) {\n    var getter =\n      module && module.__esModule\n        ? function getDefault() {\n            return module['default'];\n          }\n        : function getModuleExports() {\n            return module;\n          };\n    __webpack_require__.d(getter, 'a', getter);\n    return getter;\n  };\n\n  // Object.prototype.hasOwnProperty.call\n  // 借用了hasOwnProperty方法而已。\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  // __webpack_public_path__\n  __webpack_require__.p = '';\n\n  // Load entry module and return exports\n  // 开始加载入口函数\n  return __webpack_require__((__webpack_require__.s = './src/index.js'));\n})({\n  './src/index.js':\n    /*! no exports provided */\n    function (module, __webpack_exports__, __webpack_require__) {\n      'use strict';\n      eval(\n        '__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ \"./src/print.js\");\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_print__WEBPACK_IMPORTED_MODULE_0__);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n//# sourceURL=webpack:///./src/index.js?'\n      );\n      //   __webpack_require__.r(__webpack_exports__)\n      //   1、这里先用webpack自己的模块加载函数来加载print.js，这里函数还是会返回module.exports，只不过我们看print.js模块函数实现可以看到exports.res = res。所以我们这里拿到的就是{res: 1}这个对象而已。\n      //   var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n      //     './src/print.js'\n      //   )\n      //   2. 所以这里__webpack_require__.n({res: 1})，让我们看看上面这个n函数干了些啥？\n      //   var _print__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(\n      //     _print__WEBPACK_IMPORTED_MODULE_0__\n      //   )\n      //   4. 上面的n函数调用完了，返回的是getModuleExports这个函数，且这个函数还有个a属性的getter\n      //   5. 赋值给_print__WEBPACK_IMPORTED_MODULE_0___default后，我们去调用这个函数的a属性，不言而喻，就是{res: 1}。至此大功告成！。\n      //   console.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a)\n    },\n\n  './src/print.js':\n    /*! no static exports found */\n    function (module, exports) {\n      eval(\n        'var res = 1;\\nexports.res = res;\\n\\n//# sourceURL=webpack:///./src/print.js?'\n      );\n      // var res = 1\n      // 因为源码是cjs模块，非es模块，所以没有给exports配__esModule=true的属性（这个配置是通过__webpack_exports__.r函数实现的）\n      // exports.res = res\n    },\n});\n```\n","slug":"2019/es-cjs-module","published":1,"updated":"2021-11-06T07:30:54.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryp00036huf22fw9zg9","content":"<p>接着上一篇**webpack 模块化原理(es)**。这篇我们看下 es+cjs，2 种模块混合书写，webpack 是如何处理的。demo 和之前差不多。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> print <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./print&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(print); <span class=\"comment\">// 应该是&#123;res: 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/print.js cjs写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.res = res;</span><br></pre></td></tr></table></figure>\n\n<p>通过 webpack 编译后，代码如下（同样，做了一些处理，去除分隔符，将模块的内部函数格式化下）<br />大部分跟上一篇中解释的一样，我们看下如下几个东西，在这个编译后的 <code>bundle</code>  中有使用到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\">  <span class=\"comment\">// The module cache</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The require function</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check if module is in cache</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = (installedModules[moduleId] = &#123;</span><br><span class=\"line\">      <span class=\"attr\">i</span>: moduleId,</span><br><span class=\"line\">      <span class=\"attr\">l</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">exports</span>: &#123;&#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Execute the module function</span></span><br><span class=\"line\">    modules[moduleId].call(</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      __webpack_require__</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Flag the module as loaded</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return the exports of the module</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the modules object (__webpack_modules__)</span></span><br><span class=\"line\">  __webpack_require__.m = modules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the module cache</span></span><br><span class=\"line\">  __webpack_require__.c = installedModules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define getter function for harmony exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 处理cjs模块的辅助函数。通过给具体实现exports对象新增一个getter属性。</span></span><br><span class=\"line\">  __webpack_require__.d = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span>, name, getter</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__webpack_require__.o(<span class=\"built_in\">exports</span>, name)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, name, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">get</span>: getter &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define __esModule on exports</span></span><br><span class=\"line\">  __webpack_require__.r = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"built_in\">Symbol</span>.toStringTag) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"built_in\">Symbol</span>.toStringTag, &#123; <span class=\"attr\">value</span>: <span class=\"string\">&#x27;Module&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"string\">&#x27;__esModule&#x27;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// create a fake namespace object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 1: value is a module id, require it</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 2: merge all properties of value into the ns</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 4: return value when already ns object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 8|1: behave like require</span></span><br><span class=\"line\">  __webpack_require__.t = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, mode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">1</span>) value = __webpack_require__(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">8</span>) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">4</span> &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value &amp;&amp; value.__esModule)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ns = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    __webpack_require__.r(ns);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(ns, <span class=\"string\">&#x27;default&#x27;</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: value &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">2</span> &amp;&amp; <span class=\"keyword\">typeof</span> value != <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> value)</span><br><span class=\"line\">        __webpack_require__.d(</span><br><span class=\"line\">          ns,</span><br><span class=\"line\">          key,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value[key];</span><br><span class=\"line\">          &#125;.bind(<span class=\"literal\">null</span>, key)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ns;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class=\"line\">  <span class=\"comment\">// 针对es和cjs的默认导出，做一些处理。让大家都统一。</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如如果模块源码是es的，那么模块的exports.__esModule就会为true，在上一篇有解释过。</span></span><br><span class=\"line\">  <span class=\"comment\">// 该函数通过判断module.exports上有没有__esModule，来区分暴露默认导出应该怎么暴露。</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果是cjs，它是没有默认导出这个概念的实际上暴露的都是往module.exports = exports，也就是exports身上挂属性。这也就是模块本身，也就是我们这里函数接收的参数module，直接暴露就好了。</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果是es，它有默认导出，还有部分导出，默认导出挂在了module.exports.default属性上，其他的挂载modulex.exports[xx]上。所以暴露的时候要暴露defaults这个属性值（这个函数接的参数变量，实际上就是&#123;moduleId: xx, l: false, exports: &#123;&#125;&#125;中的exports，因为模块加载函数已经在底部返回了啊, return module.exports）。</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里稍后（先去看1，2两步骤，在下面）让我们我们结合print.js来讲解</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. module参数就是&#123;res: 1&#125;。因为print模块源码是cjs写的，所以它没有被打上__esModule=true的标记。</span></span><br><span class=\"line\">  <span class=\"comment\">// 因此，getter就是第二个函数getModuleExports，这个函数实际上就直接返回了&#123;res: 1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 接着，调用了d方法，给getModuleExports这个函数，赋了一个a的getter属性，当你访问这个a时，就是调用getModuleExports这个函数，然后又拿到了&#123;res: 1&#125;。可以看出来就是这样a: &#123;res: 1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// d方法返回的就是getModuleExports这个函数。</span></span><br><span class=\"line\">  __webpack_require__.n = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> getter =</span><br><span class=\"line\">      <span class=\"built_in\">module</span> &amp;&amp; <span class=\"built_in\">module</span>.__esModule</span><br><span class=\"line\">        ? <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDefault</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>[<span class=\"string\">&#x27;default&#x27;</span>];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        : <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModuleExports</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">    __webpack_require__.d(getter, <span class=\"string\">&#x27;a&#x27;</span>, getter);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getter;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Object.prototype.hasOwnProperty.call</span></span><br><span class=\"line\">  <span class=\"comment\">// 借用了hasOwnProperty方法而已。</span></span><br><span class=\"line\">  __webpack_require__.o = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">object, property</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// __webpack_public_path__</span></span><br><span class=\"line\">  __webpack_require__.p = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Load entry module and return exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 开始加载入口函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> __webpack_require__((__webpack_require__.s = <span class=\"string\">&#x27;./src/index.js&#x27;</span>));</span><br><span class=\"line\">&#125;)(&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/index.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! no exports provided */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      &#x27;use strict&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ &quot;./src/print.js&quot;);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_print__WEBPACK_IMPORTED_MODULE_0__);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n//# sourceURL=webpack:///./src/index.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">//   __webpack_require__.r(__webpack_exports__)</span></span><br><span class=\"line\">      <span class=\"comment\">//   1、这里先用webpack自己的模块加载函数来加载print.js，这里函数还是会返回module.exports，只不过我们看print.js模块函数实现可以看到exports.res = res。所以我们这里拿到的就是&#123;res: 1&#125;这个对象而已。</span></span><br><span class=\"line\">      <span class=\"comment\">//   var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(</span></span><br><span class=\"line\">      <span class=\"comment\">//     &#x27;./src/print.js&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">//   )</span></span><br><span class=\"line\">      <span class=\"comment\">//   2. 所以这里__webpack_require__.n(&#123;res: 1&#125;)，让我们看看上面这个n函数干了些啥？</span></span><br><span class=\"line\">      <span class=\"comment\">//   var _print__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(</span></span><br><span class=\"line\">      <span class=\"comment\">//     _print__WEBPACK_IMPORTED_MODULE_0__</span></span><br><span class=\"line\">      <span class=\"comment\">//   )</span></span><br><span class=\"line\">      <span class=\"comment\">//   4. 上面的n函数调用完了，返回的是getModuleExports这个函数，且这个函数还有个a属性的getter</span></span><br><span class=\"line\">      <span class=\"comment\">//   5. 赋值给_print__WEBPACK_IMPORTED_MODULE_0___default后，我们去调用这个函数的a属性，不言而喻，就是&#123;res: 1&#125;。至此大功告成！。</span></span><br><span class=\"line\">      <span class=\"comment\">//   console.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a)</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/print.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! no static exports found */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, <span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;var res = 1;\\nexports.res = res;\\n\\n//# sourceURL=webpack:///./src/print.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// var res = 1</span></span><br><span class=\"line\">      <span class=\"comment\">// 因为源码是cjs模块，非es模块，所以没有给exports配__esModule=true的属性（这个配置是通过__webpack_exports__.r函数实现的）</span></span><br><span class=\"line\">      <span class=\"comment\">// exports.res = res</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>接着上一篇**webpack 模块化原理(es)**。这篇我们看下 es+cjs，2 种模块混合书写，webpack 是如何处理的。demo 和之前差不多。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> print <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./print&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(print); <span class=\"comment\">// 应该是&#123;res: 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/print.js cjs写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.res = res;</span><br></pre></td></tr></table></figure>\n\n<p>通过 webpack 编译后，代码如下（同样，做了一些处理，去除分隔符，将模块的内部函数格式化下）<br />大部分跟上一篇中解释的一样，我们看下如下几个东西，在这个编译后的 <code>bundle</code>  中有使用到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\">  <span class=\"comment\">// The module cache</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The require function</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check if module is in cache</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = (installedModules[moduleId] = &#123;</span><br><span class=\"line\">      <span class=\"attr\">i</span>: moduleId,</span><br><span class=\"line\">      <span class=\"attr\">l</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">exports</span>: &#123;&#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Execute the module function</span></span><br><span class=\"line\">    modules[moduleId].call(</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      __webpack_require__</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Flag the module as loaded</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return the exports of the module</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the modules object (__webpack_modules__)</span></span><br><span class=\"line\">  __webpack_require__.m = modules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the module cache</span></span><br><span class=\"line\">  __webpack_require__.c = installedModules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define getter function for harmony exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 处理cjs模块的辅助函数。通过给具体实现exports对象新增一个getter属性。</span></span><br><span class=\"line\">  __webpack_require__.d = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span>, name, getter</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__webpack_require__.o(<span class=\"built_in\">exports</span>, name)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, name, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">get</span>: getter &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define __esModule on exports</span></span><br><span class=\"line\">  __webpack_require__.r = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"built_in\">Symbol</span>.toStringTag) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"built_in\">Symbol</span>.toStringTag, &#123; <span class=\"attr\">value</span>: <span class=\"string\">&#x27;Module&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"string\">&#x27;__esModule&#x27;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// create a fake namespace object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 1: value is a module id, require it</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 2: merge all properties of value into the ns</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 4: return value when already ns object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 8|1: behave like require</span></span><br><span class=\"line\">  __webpack_require__.t = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, mode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">1</span>) value = __webpack_require__(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">8</span>) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">4</span> &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value &amp;&amp; value.__esModule)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ns = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    __webpack_require__.r(ns);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(ns, <span class=\"string\">&#x27;default&#x27;</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: value &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">2</span> &amp;&amp; <span class=\"keyword\">typeof</span> value != <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> value)</span><br><span class=\"line\">        __webpack_require__.d(</span><br><span class=\"line\">          ns,</span><br><span class=\"line\">          key,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value[key];</span><br><span class=\"line\">          &#125;.bind(<span class=\"literal\">null</span>, key)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ns;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class=\"line\">  <span class=\"comment\">// 针对es和cjs的默认导出，做一些处理。让大家都统一。</span></span><br><span class=\"line\">  <span class=\"comment\">// 比如如果模块源码是es的，那么模块的exports.__esModule就会为true，在上一篇有解释过。</span></span><br><span class=\"line\">  <span class=\"comment\">// 该函数通过判断module.exports上有没有__esModule，来区分暴露默认导出应该怎么暴露。</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果是cjs，它是没有默认导出这个概念的实际上暴露的都是往module.exports = exports，也就是exports身上挂属性。这也就是模块本身，也就是我们这里函数接收的参数module，直接暴露就好了。</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果是es，它有默认导出，还有部分导出，默认导出挂在了module.exports.default属性上，其他的挂载modulex.exports[xx]上。所以暴露的时候要暴露defaults这个属性值（这个函数接的参数变量，实际上就是&#123;moduleId: xx, l: false, exports: &#123;&#125;&#125;中的exports，因为模块加载函数已经在底部返回了啊, return module.exports）。</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里稍后（先去看1，2两步骤，在下面）让我们我们结合print.js来讲解</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. module参数就是&#123;res: 1&#125;。因为print模块源码是cjs写的，所以它没有被打上__esModule=true的标记。</span></span><br><span class=\"line\">  <span class=\"comment\">// 因此，getter就是第二个函数getModuleExports，这个函数实际上就直接返回了&#123;res: 1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 接着，调用了d方法，给getModuleExports这个函数，赋了一个a的getter属性，当你访问这个a时，就是调用getModuleExports这个函数，然后又拿到了&#123;res: 1&#125;。可以看出来就是这样a: &#123;res: 1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// d方法返回的就是getModuleExports这个函数。</span></span><br><span class=\"line\">  __webpack_require__.n = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> getter =</span><br><span class=\"line\">      <span class=\"built_in\">module</span> &amp;&amp; <span class=\"built_in\">module</span>.__esModule</span><br><span class=\"line\">        ? <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDefault</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>[<span class=\"string\">&#x27;default&#x27;</span>];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        : <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModuleExports</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">    __webpack_require__.d(getter, <span class=\"string\">&#x27;a&#x27;</span>, getter);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getter;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Object.prototype.hasOwnProperty.call</span></span><br><span class=\"line\">  <span class=\"comment\">// 借用了hasOwnProperty方法而已。</span></span><br><span class=\"line\">  __webpack_require__.o = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">object, property</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// __webpack_public_path__</span></span><br><span class=\"line\">  __webpack_require__.p = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Load entry module and return exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 开始加载入口函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> __webpack_require__((__webpack_require__.s = <span class=\"string\">&#x27;./src/index.js&#x27;</span>));</span><br><span class=\"line\">&#125;)(&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/index.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! no exports provided */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      &#x27;use strict&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ &quot;./src/print.js&quot;);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_print__WEBPACK_IMPORTED_MODULE_0__);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n//# sourceURL=webpack:///./src/index.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">//   __webpack_require__.r(__webpack_exports__)</span></span><br><span class=\"line\">      <span class=\"comment\">//   1、这里先用webpack自己的模块加载函数来加载print.js，这里函数还是会返回module.exports，只不过我们看print.js模块函数实现可以看到exports.res = res。所以我们这里拿到的就是&#123;res: 1&#125;这个对象而已。</span></span><br><span class=\"line\">      <span class=\"comment\">//   var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(</span></span><br><span class=\"line\">      <span class=\"comment\">//     &#x27;./src/print.js&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">//   )</span></span><br><span class=\"line\">      <span class=\"comment\">//   2. 所以这里__webpack_require__.n(&#123;res: 1&#125;)，让我们看看上面这个n函数干了些啥？</span></span><br><span class=\"line\">      <span class=\"comment\">//   var _print__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(</span></span><br><span class=\"line\">      <span class=\"comment\">//     _print__WEBPACK_IMPORTED_MODULE_0__</span></span><br><span class=\"line\">      <span class=\"comment\">//   )</span></span><br><span class=\"line\">      <span class=\"comment\">//   4. 上面的n函数调用完了，返回的是getModuleExports这个函数，且这个函数还有个a属性的getter</span></span><br><span class=\"line\">      <span class=\"comment\">//   5. 赋值给_print__WEBPACK_IMPORTED_MODULE_0___default后，我们去调用这个函数的a属性，不言而喻，就是&#123;res: 1&#125;。至此大功告成！。</span></span><br><span class=\"line\">      <span class=\"comment\">//   console.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a)</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/print.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! no static exports found */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, <span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;var res = 1;\\nexports.res = res;\\n\\n//# sourceURL=webpack:///./src/print.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// var res = 1</span></span><br><span class=\"line\">      <span class=\"comment\">// 因为源码是cjs模块，非es模块，所以没有给exports配__esModule=true的属性（这个配置是通过__webpack_exports__.r函数实现的）</span></span><br><span class=\"line\">      <span class=\"comment\">// exports.res = res</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"webpack 模块化原理（ES 的）","date":"2019-12-29T16:00:00.000Z","_content":"\n写了一个最简单的 demo，webpack 配置也是最简的，主要是弄清楚 webpack 如何实现模块的加载。\n\n```javascript\n// src/index.js\nimport print from './print';\nconsole.log(print);\n\n// src/print.js\nconst res = 1;\nexport default res;\n```\n\n接下来通过 webpack 打包，贴上打包的代码（对打包的代码稍微处理了下，去掉了一些分隔符，并且将 2 个模块中的代码格式化了下，打包的是通过 eval 来执行的）\n\n```javascript\n// 可以看到，一个IIFE函数，接收一个参数modules\n\n// 这里的modules就是最下面自执行传入的一个对象，对象中包含了index.js 和 print.js通过webpack加工后的的具体实现代码。\n(function (modules) {\n  // webpackBootstrap\n  // The module cache\n  // 官方注释：模块的缓存对象，主要是希望加载过的模块不在执行第二遍。\n  var installedModules = {};\n\n  // The require function\n  // 模块的加载函数，核心部分，实现了模块的加载。\n  // 接收一个参数模块id，这里其实就是'./src/index.js'和'./print/index.js'。\n  function __webpack_require__(moduleId) {\n    // Check if module is in cache\n    // 第一步，检查模块缓存对象是否已经有过了，如果有了，就是返回出去。\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    // 如果没有，就把模块创建出来，并且也挂到缓存模块对象installedModules上。\n    // 这里利用了=的返回值的技巧。既将模块对象{i: xx, l: xx, exports: xx}赋值给了缓存模块上对应的模块key上，也赋值给了module变量\n    var module = (installedModules[moduleId] = {\n      // 就是标记模块的ID，这里也就是'./src/index.js'，'./src/main.js'\n      i: moduleId,\n      // 模块是否加载过，一个标志符。\n      l: false,\n      // 模块的具体实现，会有defaults和其他未挂载到defaults上的方法，比如exports function hello() {}\n      // 那么exports对象就会被填充为exports: {defaults: xxx, hello: xxx}\n      // 至于这里exports对象的填充，是在最下面的自执行函数传参的参数中写的。\n      exports: {},\n    });\n\n    // Execute the module function\n    // 执行模块函数，可以注意到我们打包后的代码（每个模块）都被处理为了函数\n    // 正事开始了，执行我们写的代码。使用call方法，将this指向模块的exports，因为exports里才是真正的代码实现。\n    // 然后传递3个参数，模块整体，模块的exports，还有模块加载函数。\n    modules[moduleId].call(\n      module.exports,\n      module,\n      module.exports,\n      __webpack_require__\n    );\n\n    // Flag the module as loaded\n    // 函数执行完后，将上面最开始创建新模块所声明的l，也就是模块加载标志符设为true，因为是对象，引用关系，缓存模块对象中对应的那个模块的加载标志也已经是true了\n    module.l = true;\n\n    // Return the exports of the module\n    // 这步也很关键。\n    // 浏览器目前不认识es6和cjs的模块加载，所以想要实现模块的加载，肯定是通过函数来实现。\n    // 每个模块需要暴露出自己的值或API等，而上面一直在说模块代码的具体实现，是写在exports里的，所以，暴露它，让其他模块能使用被暴露模块的值。\n    // 在下面的'./src/index.js'中可以看到，使用webpack模块加载函数引入了'./src/print/js'，并且使用了print.js中的值，这个值就是这里return暴露出去的。\n    return module.exports;\n  }\n\n  // expose the modules object (__webpack_modules__)\n  // 模块都挂到模块加载函数的属性m上。具体作用没看出来。\n  __webpack_require__.m = modules;\n\n  // expose the module cache\n  // 缓存模块对象也挂到模块加载函数的c属性上。\n  __webpack_require__.c = installedModules;\n\n  // define getter function for harmony exports\n  // 实现了一个方法。看着像是定义对象的某个属性，并将该属性配置为可枚举，且给他了一个getter实现。\n  __webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n      Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n  };\n\n  // define __esModule on exports\n  // 比较重要的一个函数，实现了对模块的一个类型定义，是不是es模块。\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n    }\n    Object.defineProperty(exports, '__esModule', { value: true });\n  };\n\n  // create a fake namespace object\n  // mode & 1: value is a module id, require it\n  // mode & 2: merge all properties of value into the ns\n  // mode & 4: return value when already ns object\n  // mode & 8|1: behave like require\n  // 这个函数没看出来有什么作用。\n  __webpack_require__.t = function (value, mode) {\n    if (mode & 1) value = __webpack_require__(value);\n    if (mode & 8) return value;\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule)\n      return value;\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n    if (mode & 2 && typeof value != 'string')\n      for (var key in value)\n        __webpack_require__.d(\n          ns,\n          key,\n          function (key) {\n            return value[key];\n          }.bind(null, key)\n        );\n    return ns;\n  };\n\n  // getDefaultExport function for compatibility with non-harmony modules\n  // 获取默认导出的函数，好像是针对于哪些不协调的模块。\n  __webpack_require__.n = function (module) {\n    var getter =\n      module && module.__esModule\n        ? function getDefault() {\n            return module['default'];\n          }\n        : function getModuleExports() {\n            return module;\n          };\n    __webpack_require__.d(getter, 'a', getter);\n    return getter;\n  };\n\n  // Object.prototype.hasOwnProperty.call\n  // 对象原型上一个函数的复用而已。\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  // __webpack_public_path__\n  __webpack_require__.p = '';\n\n  // Load entry module and return exports\n  // 加载入口函数，比较重要，前面的一些辅助函数等都已经声明完了。\n  // 这里开始从入口函数加载，开始执行我们的代码了。\n  // 模块加载函数，这里也用了=的返回的技巧。\n  // 我们将'./src/index.js'代入到上面的模块加载函数中去，逻辑解释如下：\n  // 1. 检查缓存模块对象是否已经有了'./src/index.js'这个键名对应的模块，有则返回它的具体实现，也就是exports对象。\n  // 2. 入口函数首次并没有被加载过，所以开始执行生成新模块的动作。var module = {moduleId: './src/index.js', l: false, exports: {}}\n  // 3. 开始执行这个模块也就是'./src/index.js'对应的函数。用call的方式来调用，传递了3个参数。在下面的index.js具体实现中可以看到。我们来解读。\n  return __webpack_require__((__webpack_require__.s = './src/index.js'));\n})({\n  './src/index.js':\n    /*! no exports provided */\n    function (module, __webpack_exports__, __webpack_require__) {\n      'use strict';\n      eval(\n        '__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ \"./src/print.js\");\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\\n\\n//# sourceURL=webpack:///./src/index.js?'\n      );\n      // 4. 首先调用定义模块是否是es的函数，将我们的'./src/index.js'这个模块对象{moduleId: xx, l: false, exports: {}}在添加一个__esModule: true的属性。的确我们在写代码时也就是用的es模块。\n      // __webpack_require__.r(__webpack_exports__);\n      // 5. 我们在index.js中引入了print.js，这里使用了模块加载器函数来加载print。加载的逻辑解析，【如上面的1，2，3步骤】。我们认为是6,7,8（开始执行print.js中的具体实现）吧，方便逻辑的继续。\n      // var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/print.js\");\n      // 13. 啦啦啦，上面这一行，__webpack_require__加载的print.js，接上了第12步扔出来的对象{default: 1, __esModule: true}\n      // 14. 打印了对象的default，也就是1。大工告成。\n      // console.log(_print__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n      // 这里因为我们在源码没有在index模块暴露任何东西，可以看到这里转换后的实现，webpack也并没有对index模块的exports做过多的改造。\n      // 好了index也执行完了，终于也把index模块的{l: false} 设为 true了。可以看到，print先设为true的，index是最后，因为print的调用和执行都在index中做的，属于index函数的一部分哦！\n    },\n\n  './src/print.js':\n    /*! exports provided: default */\n    function (module, __webpack_exports__, __webpack_require__) {\n      'use strict';\n      eval(\n        '__webpack_require__.r(__webpack_exports__);\\nvar res = 1;\\n/* harmony default export */ __webpack_exports__[\"default\"] = (res);\\n\\n//# sourceURL=webpack:///./src/print.js?'\n      );\n      // 9. 将print.js这个模块对象{moduleId: './src/print.js', l: false, exports: {}}也加一个__esModule: true的属性标记。\n      // __webpack_require__.r(__webpack_exports__);\n      // 10. 我们print.js源码里写的，可以看最上面的2个文件源码。\n      // var res = 1;\n      // 11. 源码里我们是export default形式暴露的res。所以这里帮我们将这种暴露挂到了exports.default上。\n      // __webpack_exports__[\"default\"] = (res);\n      // 12. 这步实际上就是__webpack_require__函数最后的return，将exports对象扔了出去。{default: 1, __esModule: true}\n      // 这里要注意，模块函数执行完了，此时print模块的 {l: false} 已经变为true了。（模块加载函数中写的module.l = true，别忘了。）\n    },\n});\n```\n","source":"_posts/2019/es-module.md","raw":"---\ntitle: webpack 模块化原理（ES 的）\ndate: 2019/12/30\n---\n\n写了一个最简单的 demo，webpack 配置也是最简的，主要是弄清楚 webpack 如何实现模块的加载。\n\n```javascript\n// src/index.js\nimport print from './print';\nconsole.log(print);\n\n// src/print.js\nconst res = 1;\nexport default res;\n```\n\n接下来通过 webpack 打包，贴上打包的代码（对打包的代码稍微处理了下，去掉了一些分隔符，并且将 2 个模块中的代码格式化了下，打包的是通过 eval 来执行的）\n\n```javascript\n// 可以看到，一个IIFE函数，接收一个参数modules\n\n// 这里的modules就是最下面自执行传入的一个对象，对象中包含了index.js 和 print.js通过webpack加工后的的具体实现代码。\n(function (modules) {\n  // webpackBootstrap\n  // The module cache\n  // 官方注释：模块的缓存对象，主要是希望加载过的模块不在执行第二遍。\n  var installedModules = {};\n\n  // The require function\n  // 模块的加载函数，核心部分，实现了模块的加载。\n  // 接收一个参数模块id，这里其实就是'./src/index.js'和'./print/index.js'。\n  function __webpack_require__(moduleId) {\n    // Check if module is in cache\n    // 第一步，检查模块缓存对象是否已经有过了，如果有了，就是返回出去。\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    // 如果没有，就把模块创建出来，并且也挂到缓存模块对象installedModules上。\n    // 这里利用了=的返回值的技巧。既将模块对象{i: xx, l: xx, exports: xx}赋值给了缓存模块上对应的模块key上，也赋值给了module变量\n    var module = (installedModules[moduleId] = {\n      // 就是标记模块的ID，这里也就是'./src/index.js'，'./src/main.js'\n      i: moduleId,\n      // 模块是否加载过，一个标志符。\n      l: false,\n      // 模块的具体实现，会有defaults和其他未挂载到defaults上的方法，比如exports function hello() {}\n      // 那么exports对象就会被填充为exports: {defaults: xxx, hello: xxx}\n      // 至于这里exports对象的填充，是在最下面的自执行函数传参的参数中写的。\n      exports: {},\n    });\n\n    // Execute the module function\n    // 执行模块函数，可以注意到我们打包后的代码（每个模块）都被处理为了函数\n    // 正事开始了，执行我们写的代码。使用call方法，将this指向模块的exports，因为exports里才是真正的代码实现。\n    // 然后传递3个参数，模块整体，模块的exports，还有模块加载函数。\n    modules[moduleId].call(\n      module.exports,\n      module,\n      module.exports,\n      __webpack_require__\n    );\n\n    // Flag the module as loaded\n    // 函数执行完后，将上面最开始创建新模块所声明的l，也就是模块加载标志符设为true，因为是对象，引用关系，缓存模块对象中对应的那个模块的加载标志也已经是true了\n    module.l = true;\n\n    // Return the exports of the module\n    // 这步也很关键。\n    // 浏览器目前不认识es6和cjs的模块加载，所以想要实现模块的加载，肯定是通过函数来实现。\n    // 每个模块需要暴露出自己的值或API等，而上面一直在说模块代码的具体实现，是写在exports里的，所以，暴露它，让其他模块能使用被暴露模块的值。\n    // 在下面的'./src/index.js'中可以看到，使用webpack模块加载函数引入了'./src/print/js'，并且使用了print.js中的值，这个值就是这里return暴露出去的。\n    return module.exports;\n  }\n\n  // expose the modules object (__webpack_modules__)\n  // 模块都挂到模块加载函数的属性m上。具体作用没看出来。\n  __webpack_require__.m = modules;\n\n  // expose the module cache\n  // 缓存模块对象也挂到模块加载函数的c属性上。\n  __webpack_require__.c = installedModules;\n\n  // define getter function for harmony exports\n  // 实现了一个方法。看着像是定义对象的某个属性，并将该属性配置为可枚举，且给他了一个getter实现。\n  __webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n      Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n  };\n\n  // define __esModule on exports\n  // 比较重要的一个函数，实现了对模块的一个类型定义，是不是es模块。\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n    }\n    Object.defineProperty(exports, '__esModule', { value: true });\n  };\n\n  // create a fake namespace object\n  // mode & 1: value is a module id, require it\n  // mode & 2: merge all properties of value into the ns\n  // mode & 4: return value when already ns object\n  // mode & 8|1: behave like require\n  // 这个函数没看出来有什么作用。\n  __webpack_require__.t = function (value, mode) {\n    if (mode & 1) value = __webpack_require__(value);\n    if (mode & 8) return value;\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule)\n      return value;\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n    if (mode & 2 && typeof value != 'string')\n      for (var key in value)\n        __webpack_require__.d(\n          ns,\n          key,\n          function (key) {\n            return value[key];\n          }.bind(null, key)\n        );\n    return ns;\n  };\n\n  // getDefaultExport function for compatibility with non-harmony modules\n  // 获取默认导出的函数，好像是针对于哪些不协调的模块。\n  __webpack_require__.n = function (module) {\n    var getter =\n      module && module.__esModule\n        ? function getDefault() {\n            return module['default'];\n          }\n        : function getModuleExports() {\n            return module;\n          };\n    __webpack_require__.d(getter, 'a', getter);\n    return getter;\n  };\n\n  // Object.prototype.hasOwnProperty.call\n  // 对象原型上一个函数的复用而已。\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  // __webpack_public_path__\n  __webpack_require__.p = '';\n\n  // Load entry module and return exports\n  // 加载入口函数，比较重要，前面的一些辅助函数等都已经声明完了。\n  // 这里开始从入口函数加载，开始执行我们的代码了。\n  // 模块加载函数，这里也用了=的返回的技巧。\n  // 我们将'./src/index.js'代入到上面的模块加载函数中去，逻辑解释如下：\n  // 1. 检查缓存模块对象是否已经有了'./src/index.js'这个键名对应的模块，有则返回它的具体实现，也就是exports对象。\n  // 2. 入口函数首次并没有被加载过，所以开始执行生成新模块的动作。var module = {moduleId: './src/index.js', l: false, exports: {}}\n  // 3. 开始执行这个模块也就是'./src/index.js'对应的函数。用call的方式来调用，传递了3个参数。在下面的index.js具体实现中可以看到。我们来解读。\n  return __webpack_require__((__webpack_require__.s = './src/index.js'));\n})({\n  './src/index.js':\n    /*! no exports provided */\n    function (module, __webpack_exports__, __webpack_require__) {\n      'use strict';\n      eval(\n        '__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ \"./src/print.js\");\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\\n\\n//# sourceURL=webpack:///./src/index.js?'\n      );\n      // 4. 首先调用定义模块是否是es的函数，将我们的'./src/index.js'这个模块对象{moduleId: xx, l: false, exports: {}}在添加一个__esModule: true的属性。的确我们在写代码时也就是用的es模块。\n      // __webpack_require__.r(__webpack_exports__);\n      // 5. 我们在index.js中引入了print.js，这里使用了模块加载器函数来加载print。加载的逻辑解析，【如上面的1，2，3步骤】。我们认为是6,7,8（开始执行print.js中的具体实现）吧，方便逻辑的继续。\n      // var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/print.js\");\n      // 13. 啦啦啦，上面这一行，__webpack_require__加载的print.js，接上了第12步扔出来的对象{default: 1, __esModule: true}\n      // 14. 打印了对象的default，也就是1。大工告成。\n      // console.log(_print__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n      // 这里因为我们在源码没有在index模块暴露任何东西，可以看到这里转换后的实现，webpack也并没有对index模块的exports做过多的改造。\n      // 好了index也执行完了，终于也把index模块的{l: false} 设为 true了。可以看到，print先设为true的，index是最后，因为print的调用和执行都在index中做的，属于index函数的一部分哦！\n    },\n\n  './src/print.js':\n    /*! exports provided: default */\n    function (module, __webpack_exports__, __webpack_require__) {\n      'use strict';\n      eval(\n        '__webpack_require__.r(__webpack_exports__);\\nvar res = 1;\\n/* harmony default export */ __webpack_exports__[\"default\"] = (res);\\n\\n//# sourceURL=webpack:///./src/print.js?'\n      );\n      // 9. 将print.js这个模块对象{moduleId: './src/print.js', l: false, exports: {}}也加一个__esModule: true的属性标记。\n      // __webpack_require__.r(__webpack_exports__);\n      // 10. 我们print.js源码里写的，可以看最上面的2个文件源码。\n      // var res = 1;\n      // 11. 源码里我们是export default形式暴露的res。所以这里帮我们将这种暴露挂到了exports.default上。\n      // __webpack_exports__[\"default\"] = (res);\n      // 12. 这步实际上就是__webpack_require__函数最后的return，将exports对象扔了出去。{default: 1, __esModule: true}\n      // 这里要注意，模块函数执行完了，此时print模块的 {l: false} 已经变为true了。（模块加载函数中写的module.l = true，别忘了。）\n    },\n});\n```\n","slug":"2019/es-module","published":1,"updated":"2021-11-06T07:31:14.755Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryr00046huf966jdi5n","content":"<p>写了一个最简单的 demo，webpack 配置也是最简的，主要是弄清楚 webpack 如何实现模块的加载。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> print <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./print&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(print);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/print.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> res;</span><br></pre></td></tr></table></figure>\n\n<p>接下来通过 webpack 打包，贴上打包的代码（对打包的代码稍微处理了下，去掉了一些分隔符，并且将 2 个模块中的代码格式化了下，打包的是通过 eval 来执行的）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以看到，一个IIFE函数，接收一个参数modules</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的modules就是最下面自执行传入的一个对象，对象中包含了index.js 和 print.js通过webpack加工后的的具体实现代码。</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\">  <span class=\"comment\">// The module cache</span></span><br><span class=\"line\">  <span class=\"comment\">// 官方注释：模块的缓存对象，主要是希望加载过的模块不在执行第二遍。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The require function</span></span><br><span class=\"line\">  <span class=\"comment\">// 模块的加载函数，核心部分，实现了模块的加载。</span></span><br><span class=\"line\">  <span class=\"comment\">// 接收一个参数模块id，这里其实就是&#x27;./src/index.js&#x27;和&#x27;./print/index.js&#x27;。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check if module is in cache</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一步，检查模块缓存对象是否已经有过了，如果有了，就是返回出去。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有，就把模块创建出来，并且也挂到缓存模块对象installedModules上。</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里利用了=的返回值的技巧。既将模块对象&#123;i: xx, l: xx, exports: xx&#125;赋值给了缓存模块上对应的模块key上，也赋值给了module变量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = (installedModules[moduleId] = &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 就是标记模块的ID，这里也就是&#x27;./src/index.js&#x27;，&#x27;./src/main.js&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">i</span>: moduleId,</span><br><span class=\"line\">      <span class=\"comment\">// 模块是否加载过，一个标志符。</span></span><br><span class=\"line\">      <span class=\"attr\">l</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 模块的具体实现，会有defaults和其他未挂载到defaults上的方法，比如exports function hello() &#123;&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 那么exports对象就会被填充为exports: &#123;defaults: xxx, hello: xxx&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 至于这里exports对象的填充，是在最下面的自执行函数传参的参数中写的。</span></span><br><span class=\"line\">      <span class=\"attr\">exports</span>: &#123;&#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Execute the module function</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行模块函数，可以注意到我们打包后的代码（每个模块）都被处理为了函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 正事开始了，执行我们写的代码。使用call方法，将this指向模块的exports，因为exports里才是真正的代码实现。</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后传递3个参数，模块整体，模块的exports，还有模块加载函数。</span></span><br><span class=\"line\">    modules[moduleId].call(</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      __webpack_require__</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Flag the module as loaded</span></span><br><span class=\"line\">    <span class=\"comment\">// 函数执行完后，将上面最开始创建新模块所声明的l，也就是模块加载标志符设为true，因为是对象，引用关系，缓存模块对象中对应的那个模块的加载标志也已经是true了</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return the exports of the module</span></span><br><span class=\"line\">    <span class=\"comment\">// 这步也很关键。</span></span><br><span class=\"line\">    <span class=\"comment\">// 浏览器目前不认识es6和cjs的模块加载，所以想要实现模块的加载，肯定是通过函数来实现。</span></span><br><span class=\"line\">    <span class=\"comment\">// 每个模块需要暴露出自己的值或API等，而上面一直在说模块代码的具体实现，是写在exports里的，所以，暴露它，让其他模块能使用被暴露模块的值。</span></span><br><span class=\"line\">    <span class=\"comment\">// 在下面的&#x27;./src/index.js&#x27;中可以看到，使用webpack模块加载函数引入了&#x27;./src/print/js&#x27;，并且使用了print.js中的值，这个值就是这里return暴露出去的。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the modules object (__webpack_modules__)</span></span><br><span class=\"line\">  <span class=\"comment\">// 模块都挂到模块加载函数的属性m上。具体作用没看出来。</span></span><br><span class=\"line\">  __webpack_require__.m = modules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the module cache</span></span><br><span class=\"line\">  <span class=\"comment\">// 缓存模块对象也挂到模块加载函数的c属性上。</span></span><br><span class=\"line\">  __webpack_require__.c = installedModules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define getter function for harmony exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 实现了一个方法。看着像是定义对象的某个属性，并将该属性配置为可枚举，且给他了一个getter实现。</span></span><br><span class=\"line\">  __webpack_require__.d = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span>, name, getter</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__webpack_require__.o(<span class=\"built_in\">exports</span>, name)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, name, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">get</span>: getter &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define __esModule on exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 比较重要的一个函数，实现了对模块的一个类型定义，是不是es模块。</span></span><br><span class=\"line\">  __webpack_require__.r = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"built_in\">Symbol</span>.toStringTag) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"built_in\">Symbol</span>.toStringTag, &#123; <span class=\"attr\">value</span>: <span class=\"string\">&#x27;Module&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"string\">&#x27;__esModule&#x27;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// create a fake namespace object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 1: value is a module id, require it</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 2: merge all properties of value into the ns</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 4: return value when already ns object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 8|1: behave like require</span></span><br><span class=\"line\">  <span class=\"comment\">// 这个函数没看出来有什么作用。</span></span><br><span class=\"line\">  __webpack_require__.t = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, mode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">1</span>) value = __webpack_require__(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">8</span>) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">4</span> &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value &amp;&amp; value.__esModule)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ns = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    __webpack_require__.r(ns);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(ns, <span class=\"string\">&#x27;default&#x27;</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: value &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">2</span> &amp;&amp; <span class=\"keyword\">typeof</span> value != <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> value)</span><br><span class=\"line\">        __webpack_require__.d(</span><br><span class=\"line\">          ns,</span><br><span class=\"line\">          key,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value[key];</span><br><span class=\"line\">          &#125;.bind(<span class=\"literal\">null</span>, key)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ns;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取默认导出的函数，好像是针对于哪些不协调的模块。</span></span><br><span class=\"line\">  __webpack_require__.n = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> getter =</span><br><span class=\"line\">      <span class=\"built_in\">module</span> &amp;&amp; <span class=\"built_in\">module</span>.__esModule</span><br><span class=\"line\">        ? <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDefault</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>[<span class=\"string\">&#x27;default&#x27;</span>];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        : <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModuleExports</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">    __webpack_require__.d(getter, <span class=\"string\">&#x27;a&#x27;</span>, getter);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getter;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Object.prototype.hasOwnProperty.call</span></span><br><span class=\"line\">  <span class=\"comment\">// 对象原型上一个函数的复用而已。</span></span><br><span class=\"line\">  __webpack_require__.o = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">object, property</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// __webpack_public_path__</span></span><br><span class=\"line\">  __webpack_require__.p = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Load entry module and return exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 加载入口函数，比较重要，前面的一些辅助函数等都已经声明完了。</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里开始从入口函数加载，开始执行我们的代码了。</span></span><br><span class=\"line\">  <span class=\"comment\">// 模块加载函数，这里也用了=的返回的技巧。</span></span><br><span class=\"line\">  <span class=\"comment\">// 我们将&#x27;./src/index.js&#x27;代入到上面的模块加载函数中去，逻辑解释如下：</span></span><br><span class=\"line\">  <span class=\"comment\">// 1. 检查缓存模块对象是否已经有了&#x27;./src/index.js&#x27;这个键名对应的模块，有则返回它的具体实现，也就是exports对象。</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 入口函数首次并没有被加载过，所以开始执行生成新模块的动作。var module = &#123;moduleId: &#x27;./src/index.js&#x27;, l: false, exports: &#123;&#125;&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. 开始执行这个模块也就是&#x27;./src/index.js&#x27;对应的函数。用call的方式来调用，传递了3个参数。在下面的index.js具体实现中可以看到。我们来解读。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> __webpack_require__((__webpack_require__.s = <span class=\"string\">&#x27;./src/index.js&#x27;</span>));</span><br><span class=\"line\">&#125;)(&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/index.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! no exports provided */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      &#x27;use strict&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ &quot;./src/print.js&quot;);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;]);\\n\\n//# sourceURL=webpack:///./src/index.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// 4. 首先调用定义模块是否是es的函数，将我们的&#x27;./src/index.js&#x27;这个模块对象&#123;moduleId: xx, l: false, exports: &#123;&#125;&#125;在添加一个__esModule: true的属性。的确我们在写代码时也就是用的es模块。</span></span><br><span class=\"line\">      <span class=\"comment\">// __webpack_require__.r(__webpack_exports__);</span></span><br><span class=\"line\">      <span class=\"comment\">// 5. 我们在index.js中引入了print.js，这里使用了模块加载器函数来加载print。加载的逻辑解析，【如上面的1，2，3步骤】。我们认为是6,7,8（开始执行print.js中的具体实现）吧，方便逻辑的继续。</span></span><br><span class=\"line\">      <span class=\"comment\">// var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;./src/print.js&quot;);</span></span><br><span class=\"line\">      <span class=\"comment\">// 13. 啦啦啦，上面这一行，__webpack_require__加载的print.js，接上了第12步扔出来的对象&#123;default: 1, __esModule: true&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 14. 打印了对象的default，也就是1。大工告成。</span></span><br><span class=\"line\">      <span class=\"comment\">// console.log(_print__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;]);</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里因为我们在源码没有在index模块暴露任何东西，可以看到这里转换后的实现，webpack也并没有对index模块的exports做过多的改造。</span></span><br><span class=\"line\">      <span class=\"comment\">// 好了index也执行完了，终于也把index模块的&#123;l: false&#125; 设为 true了。可以看到，print先设为true的，index是最后，因为print的调用和执行都在index中做的，属于index函数的一部分哦！</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/print.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! exports provided: default */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      &#x27;use strict&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;__webpack_require__.r(__webpack_exports__);\\nvar res = 1;\\n/* harmony default export */ __webpack_exports__[&quot;default&quot;] = (res);\\n\\n//# sourceURL=webpack:///./src/print.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// 9. 将print.js这个模块对象&#123;moduleId: &#x27;./src/print.js&#x27;, l: false, exports: &#123;&#125;&#125;也加一个__esModule: true的属性标记。</span></span><br><span class=\"line\">      <span class=\"comment\">// __webpack_require__.r(__webpack_exports__);</span></span><br><span class=\"line\">      <span class=\"comment\">// 10. 我们print.js源码里写的，可以看最上面的2个文件源码。</span></span><br><span class=\"line\">      <span class=\"comment\">// var res = 1;</span></span><br><span class=\"line\">      <span class=\"comment\">// 11. 源码里我们是export default形式暴露的res。所以这里帮我们将这种暴露挂到了exports.default上。</span></span><br><span class=\"line\">      <span class=\"comment\">// __webpack_exports__[&quot;default&quot;] = (res);</span></span><br><span class=\"line\">      <span class=\"comment\">// 12. 这步实际上就是__webpack_require__函数最后的return，将exports对象扔了出去。&#123;default: 1, __esModule: true&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里要注意，模块函数执行完了，此时print模块的 &#123;l: false&#125; 已经变为true了。（模块加载函数中写的module.l = true，别忘了。）</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>写了一个最简单的 demo，webpack 配置也是最简的，主要是弄清楚 webpack 如何实现模块的加载。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> print <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./print&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(print);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/print.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> res;</span><br></pre></td></tr></table></figure>\n\n<p>接下来通过 webpack 打包，贴上打包的代码（对打包的代码稍微处理了下，去掉了一些分隔符，并且将 2 个模块中的代码格式化了下，打包的是通过 eval 来执行的）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以看到，一个IIFE函数，接收一个参数modules</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的modules就是最下面自执行传入的一个对象，对象中包含了index.js 和 print.js通过webpack加工后的的具体实现代码。</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\">  <span class=\"comment\">// The module cache</span></span><br><span class=\"line\">  <span class=\"comment\">// 官方注释：模块的缓存对象，主要是希望加载过的模块不在执行第二遍。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The require function</span></span><br><span class=\"line\">  <span class=\"comment\">// 模块的加载函数，核心部分，实现了模块的加载。</span></span><br><span class=\"line\">  <span class=\"comment\">// 接收一个参数模块id，这里其实就是&#x27;./src/index.js&#x27;和&#x27;./print/index.js&#x27;。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check if module is in cache</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一步，检查模块缓存对象是否已经有过了，如果有了，就是返回出去。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有，就把模块创建出来，并且也挂到缓存模块对象installedModules上。</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里利用了=的返回值的技巧。既将模块对象&#123;i: xx, l: xx, exports: xx&#125;赋值给了缓存模块上对应的模块key上，也赋值给了module变量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = (installedModules[moduleId] = &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 就是标记模块的ID，这里也就是&#x27;./src/index.js&#x27;，&#x27;./src/main.js&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">i</span>: moduleId,</span><br><span class=\"line\">      <span class=\"comment\">// 模块是否加载过，一个标志符。</span></span><br><span class=\"line\">      <span class=\"attr\">l</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 模块的具体实现，会有defaults和其他未挂载到defaults上的方法，比如exports function hello() &#123;&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 那么exports对象就会被填充为exports: &#123;defaults: xxx, hello: xxx&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 至于这里exports对象的填充，是在最下面的自执行函数传参的参数中写的。</span></span><br><span class=\"line\">      <span class=\"attr\">exports</span>: &#123;&#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Execute the module function</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行模块函数，可以注意到我们打包后的代码（每个模块）都被处理为了函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 正事开始了，执行我们写的代码。使用call方法，将this指向模块的exports，因为exports里才是真正的代码实现。</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后传递3个参数，模块整体，模块的exports，还有模块加载函数。</span></span><br><span class=\"line\">    modules[moduleId].call(</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>,</span><br><span class=\"line\">      <span class=\"built_in\">module</span>.exports,</span><br><span class=\"line\">      __webpack_require__</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Flag the module as loaded</span></span><br><span class=\"line\">    <span class=\"comment\">// 函数执行完后，将上面最开始创建新模块所声明的l，也就是模块加载标志符设为true，因为是对象，引用关系，缓存模块对象中对应的那个模块的加载标志也已经是true了</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return the exports of the module</span></span><br><span class=\"line\">    <span class=\"comment\">// 这步也很关键。</span></span><br><span class=\"line\">    <span class=\"comment\">// 浏览器目前不认识es6和cjs的模块加载，所以想要实现模块的加载，肯定是通过函数来实现。</span></span><br><span class=\"line\">    <span class=\"comment\">// 每个模块需要暴露出自己的值或API等，而上面一直在说模块代码的具体实现，是写在exports里的，所以，暴露它，让其他模块能使用被暴露模块的值。</span></span><br><span class=\"line\">    <span class=\"comment\">// 在下面的&#x27;./src/index.js&#x27;中可以看到，使用webpack模块加载函数引入了&#x27;./src/print/js&#x27;，并且使用了print.js中的值，这个值就是这里return暴露出去的。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the modules object (__webpack_modules__)</span></span><br><span class=\"line\">  <span class=\"comment\">// 模块都挂到模块加载函数的属性m上。具体作用没看出来。</span></span><br><span class=\"line\">  __webpack_require__.m = modules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// expose the module cache</span></span><br><span class=\"line\">  <span class=\"comment\">// 缓存模块对象也挂到模块加载函数的c属性上。</span></span><br><span class=\"line\">  __webpack_require__.c = installedModules;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define getter function for harmony exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 实现了一个方法。看着像是定义对象的某个属性，并将该属性配置为可枚举，且给他了一个getter实现。</span></span><br><span class=\"line\">  __webpack_require__.d = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span>, name, getter</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__webpack_require__.o(<span class=\"built_in\">exports</span>, name)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, name, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">get</span>: getter &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define __esModule on exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 比较重要的一个函数，实现了对模块的一个类型定义，是不是es模块。</span></span><br><span class=\"line\">  __webpack_require__.r = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"built_in\">Symbol</span>.toStringTag) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"built_in\">Symbol</span>.toStringTag, &#123; <span class=\"attr\">value</span>: <span class=\"string\">&#x27;Module&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">exports</span>, <span class=\"string\">&#x27;__esModule&#x27;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// create a fake namespace object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 1: value is a module id, require it</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 2: merge all properties of value into the ns</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 4: return value when already ns object</span></span><br><span class=\"line\">  <span class=\"comment\">// mode &amp; 8|1: behave like require</span></span><br><span class=\"line\">  <span class=\"comment\">// 这个函数没看出来有什么作用。</span></span><br><span class=\"line\">  __webpack_require__.t = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, mode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">1</span>) value = __webpack_require__(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">8</span>) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">4</span> &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value &amp;&amp; value.__esModule)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ns = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    __webpack_require__.r(ns);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(ns, <span class=\"string\">&#x27;default&#x27;</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: value &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">2</span> &amp;&amp; <span class=\"keyword\">typeof</span> value != <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> value)</span><br><span class=\"line\">        __webpack_require__.d(</span><br><span class=\"line\">          ns,</span><br><span class=\"line\">          key,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value[key];</span><br><span class=\"line\">          &#125;.bind(<span class=\"literal\">null</span>, key)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ns;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取默认导出的函数，好像是针对于哪些不协调的模块。</span></span><br><span class=\"line\">  __webpack_require__.n = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> getter =</span><br><span class=\"line\">      <span class=\"built_in\">module</span> &amp;&amp; <span class=\"built_in\">module</span>.__esModule</span><br><span class=\"line\">        ? <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDefault</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>[<span class=\"string\">&#x27;default&#x27;</span>];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        : <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModuleExports</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">    __webpack_require__.d(getter, <span class=\"string\">&#x27;a&#x27;</span>, getter);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getter;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Object.prototype.hasOwnProperty.call</span></span><br><span class=\"line\">  <span class=\"comment\">// 对象原型上一个函数的复用而已。</span></span><br><span class=\"line\">  __webpack_require__.o = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">object, property</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// __webpack_public_path__</span></span><br><span class=\"line\">  __webpack_require__.p = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Load entry module and return exports</span></span><br><span class=\"line\">  <span class=\"comment\">// 加载入口函数，比较重要，前面的一些辅助函数等都已经声明完了。</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里开始从入口函数加载，开始执行我们的代码了。</span></span><br><span class=\"line\">  <span class=\"comment\">// 模块加载函数，这里也用了=的返回的技巧。</span></span><br><span class=\"line\">  <span class=\"comment\">// 我们将&#x27;./src/index.js&#x27;代入到上面的模块加载函数中去，逻辑解释如下：</span></span><br><span class=\"line\">  <span class=\"comment\">// 1. 检查缓存模块对象是否已经有了&#x27;./src/index.js&#x27;这个键名对应的模块，有则返回它的具体实现，也就是exports对象。</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 入口函数首次并没有被加载过，所以开始执行生成新模块的动作。var module = &#123;moduleId: &#x27;./src/index.js&#x27;, l: false, exports: &#123;&#125;&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. 开始执行这个模块也就是&#x27;./src/index.js&#x27;对应的函数。用call的方式来调用，传递了3个参数。在下面的index.js具体实现中可以看到。我们来解读。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> __webpack_require__((__webpack_require__.s = <span class=\"string\">&#x27;./src/index.js&#x27;</span>));</span><br><span class=\"line\">&#125;)(&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/index.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! no exports provided */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      &#x27;use strict&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ &quot;./src/print.js&quot;);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;]);\\n\\n//# sourceURL=webpack:///./src/index.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// 4. 首先调用定义模块是否是es的函数，将我们的&#x27;./src/index.js&#x27;这个模块对象&#123;moduleId: xx, l: false, exports: &#123;&#125;&#125;在添加一个__esModule: true的属性。的确我们在写代码时也就是用的es模块。</span></span><br><span class=\"line\">      <span class=\"comment\">// __webpack_require__.r(__webpack_exports__);</span></span><br><span class=\"line\">      <span class=\"comment\">// 5. 我们在index.js中引入了print.js，这里使用了模块加载器函数来加载print。加载的逻辑解析，【如上面的1，2，3步骤】。我们认为是6,7,8（开始执行print.js中的具体实现）吧，方便逻辑的继续。</span></span><br><span class=\"line\">      <span class=\"comment\">// var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;./src/print.js&quot;);</span></span><br><span class=\"line\">      <span class=\"comment\">// 13. 啦啦啦，上面这一行，__webpack_require__加载的print.js，接上了第12步扔出来的对象&#123;default: 1, __esModule: true&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 14. 打印了对象的default，也就是1。大工告成。</span></span><br><span class=\"line\">      <span class=\"comment\">// console.log(_print__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;]);</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里因为我们在源码没有在index模块暴露任何东西，可以看到这里转换后的实现，webpack也并没有对index模块的exports做过多的改造。</span></span><br><span class=\"line\">      <span class=\"comment\">// 好了index也执行完了，终于也把index模块的&#123;l: false&#125; 设为 true了。可以看到，print先设为true的，index是最后，因为print的调用和执行都在index中做的，属于index函数的一部分哦！</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&#x27;./src/print.js&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*! exports provided: default */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">      &#x27;use strict&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">eval</span>(</span><br><span class=\"line\">        <span class=\"string\">&#x27;__webpack_require__.r(__webpack_exports__);\\nvar res = 1;\\n/* harmony default export */ __webpack_exports__[&quot;default&quot;] = (res);\\n\\n//# sourceURL=webpack:///./src/print.js?&#x27;</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// 9. 将print.js这个模块对象&#123;moduleId: &#x27;./src/print.js&#x27;, l: false, exports: &#123;&#125;&#125;也加一个__esModule: true的属性标记。</span></span><br><span class=\"line\">      <span class=\"comment\">// __webpack_require__.r(__webpack_exports__);</span></span><br><span class=\"line\">      <span class=\"comment\">// 10. 我们print.js源码里写的，可以看最上面的2个文件源码。</span></span><br><span class=\"line\">      <span class=\"comment\">// var res = 1;</span></span><br><span class=\"line\">      <span class=\"comment\">// 11. 源码里我们是export default形式暴露的res。所以这里帮我们将这种暴露挂到了exports.default上。</span></span><br><span class=\"line\">      <span class=\"comment\">// __webpack_exports__[&quot;default&quot;] = (res);</span></span><br><span class=\"line\">      <span class=\"comment\">// 12. 这步实际上就是__webpack_require__函数最后的return，将exports对象扔了出去。&#123;default: 1, __esModule: true&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里要注意，模块函数执行完了，此时print模块的 &#123;l: false&#125; 已经变为true了。（模块加载函数中写的module.l = true，别忘了。）</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"node 查询和关闭进程","date":"2019-12-29T16:00:00.000Z","_content":"\n手头的 electron 项目，需要查询并关闭另外的程序，程序本身虽然是通过子进程方式启动，但是启动的仅是个壳，壳本身又自己启动了另一个程序 Z，导致无法通过子进程启动后的句柄拿到真正启动的程序 Z。所以无法监控到程序 Z 目前是开启还是关闭的。\n\n解决方法就是 node 子进程模块的 `spawn`  去执行 windows 的 cmd 命令。该项目只在 windows 电脑运行，所以要用 windows 的命令行而非 liunx 命令。\n\n> 这里项目本身只在 windows 运行，所以执行的命令应该是 windows 下的，而不是 linux 命令。比如列出当前目录文件，windows 下用的是 `dir` ，而 linux 下用的是 `ls` 。两者是不同的，因为我的电脑安装了 `cmder` ，即可以调用 windows 命令也可以调用 linux 命令。win10 的话有 powershell，可能能支持 linux 命令\n\n直接在 cmd 里面运行查找进程的命令的话，是这样的：\n\n```javascript\ntasklist | findstr /i chrome.exe\n// tasklist 查找系统进程后，查找的内容通过管道符 | 传递给另一个命令 findstr ，这个命令接收参数，这里接受了忽略大小写，然后查找chrome.exe关键字，并返回结果。\n```\n\n这里的 `/i`  意味忽略大小写。\n\n> 另外要注意的是，查找进程名字如果很长的话，通过上面的命令，查找出来的进程名字会被截取，限制了 25 个字符好像。所以可以加另一个参数给 tasklist， `/fo csv`  以该模式输出，避免查找出的结果被截取。这样查找后的结果，是自带\"\"的，如： `\"YoudaoDict.exe\",\"5324\",\"Console\",\"1\",\"37,028 K\"`\n\n开始说正题，node 的子进程模块提供了 `exec`  和 `spawn` 2 种方式来调用，其中 `exec`  会起一个 shell 来执行传入的参数，而 `spawn`  不会起 shell。所以两种方法调用是有区别的。\n\n<a name=\"U2KVo\"></a>\n\n##### exec 方式\n\n```javascript\nexec(`tasklist /fo csv | findstr /i YouDaoDict.exe`, (err, stdout, stderr) => {\n  if (err) {\n    console.log(`tasklist error: ${err}`);\n    return;\n  }\n  console.log(`stdout ${stdout}`);\n  console.log(`stderr ${stderr}`);\n});\n```\n\n<a name=\"GAj2U\"></a>\n\n##### spawn 方式\n\n相比上面的写法，略麻烦，注意 tasklist 和 findstr 是 2 个命令，正如上面解释的那样，是 tasklist 运行获取的值给到 findstr 在做的筛选。因此通过 spawn 的方式，需要这么写：\n\n这里涉及到了 `stdin stdout`  的使用，看起来像个流，简单理解下 `stdin`  就是函数的入参， `stdout`  就是函数的返回值。\n\n```javascript\nconst { spawn } = require('child_process');\n\nconst tasklist = spawn('tasklist', ['/fo', 'csv']);\nconst findstr = spawn('findstr', ['/i', 'AsmanVR-Win64-Shipping']);\n\ntasklist.stdout.on('data', (data) => {\n  // 往findstr的输入中写入 tasklist的输出数据。\n  findstr.stdin.write(data);\n});\n\ntasklist.stderr.on('data', (data) => {\n  console.error(`tasklist stderr: ${data}`);\n});\n\ntasklist.on('close', (code) => {\n  if (code !== 0) {\n    console.log(`tasklist进程退出，退出码：${code}`);\n  }\n  findstr.stdin.end();\n});\n\nfindstr.stdout.on('data', (data) => {\n  // 监听findstr的输出（就是运行返回的结果）\n  console.log(data.toString()); // 这里就是真正获取到查询结果的地方。\n});\n\nfindstr.stderr.on('data', (data) => {\n  console.log(`findstr stderr: ${data}`);\n});\n\nfindstr.on('close', (code) => {\n  if (code !== 0) {\n    console.log(`findstr进程退出，退出码：${code}`);\n  }\n});\n```\n","source":"_posts/2019/node-process.md","raw":"---\ntitle: node 查询和关闭进程\ndate: 2019/12/30\n---\n\n手头的 electron 项目，需要查询并关闭另外的程序，程序本身虽然是通过子进程方式启动，但是启动的仅是个壳，壳本身又自己启动了另一个程序 Z，导致无法通过子进程启动后的句柄拿到真正启动的程序 Z。所以无法监控到程序 Z 目前是开启还是关闭的。\n\n解决方法就是 node 子进程模块的 `spawn`  去执行 windows 的 cmd 命令。该项目只在 windows 电脑运行，所以要用 windows 的命令行而非 liunx 命令。\n\n> 这里项目本身只在 windows 运行，所以执行的命令应该是 windows 下的，而不是 linux 命令。比如列出当前目录文件，windows 下用的是 `dir` ，而 linux 下用的是 `ls` 。两者是不同的，因为我的电脑安装了 `cmder` ，即可以调用 windows 命令也可以调用 linux 命令。win10 的话有 powershell，可能能支持 linux 命令\n\n直接在 cmd 里面运行查找进程的命令的话，是这样的：\n\n```javascript\ntasklist | findstr /i chrome.exe\n// tasklist 查找系统进程后，查找的内容通过管道符 | 传递给另一个命令 findstr ，这个命令接收参数，这里接受了忽略大小写，然后查找chrome.exe关键字，并返回结果。\n```\n\n这里的 `/i`  意味忽略大小写。\n\n> 另外要注意的是，查找进程名字如果很长的话，通过上面的命令，查找出来的进程名字会被截取，限制了 25 个字符好像。所以可以加另一个参数给 tasklist， `/fo csv`  以该模式输出，避免查找出的结果被截取。这样查找后的结果，是自带\"\"的，如： `\"YoudaoDict.exe\",\"5324\",\"Console\",\"1\",\"37,028 K\"`\n\n开始说正题，node 的子进程模块提供了 `exec`  和 `spawn` 2 种方式来调用，其中 `exec`  会起一个 shell 来执行传入的参数，而 `spawn`  不会起 shell。所以两种方法调用是有区别的。\n\n<a name=\"U2KVo\"></a>\n\n##### exec 方式\n\n```javascript\nexec(`tasklist /fo csv | findstr /i YouDaoDict.exe`, (err, stdout, stderr) => {\n  if (err) {\n    console.log(`tasklist error: ${err}`);\n    return;\n  }\n  console.log(`stdout ${stdout}`);\n  console.log(`stderr ${stderr}`);\n});\n```\n\n<a name=\"GAj2U\"></a>\n\n##### spawn 方式\n\n相比上面的写法，略麻烦，注意 tasklist 和 findstr 是 2 个命令，正如上面解释的那样，是 tasklist 运行获取的值给到 findstr 在做的筛选。因此通过 spawn 的方式，需要这么写：\n\n这里涉及到了 `stdin stdout`  的使用，看起来像个流，简单理解下 `stdin`  就是函数的入参， `stdout`  就是函数的返回值。\n\n```javascript\nconst { spawn } = require('child_process');\n\nconst tasklist = spawn('tasklist', ['/fo', 'csv']);\nconst findstr = spawn('findstr', ['/i', 'AsmanVR-Win64-Shipping']);\n\ntasklist.stdout.on('data', (data) => {\n  // 往findstr的输入中写入 tasklist的输出数据。\n  findstr.stdin.write(data);\n});\n\ntasklist.stderr.on('data', (data) => {\n  console.error(`tasklist stderr: ${data}`);\n});\n\ntasklist.on('close', (code) => {\n  if (code !== 0) {\n    console.log(`tasklist进程退出，退出码：${code}`);\n  }\n  findstr.stdin.end();\n});\n\nfindstr.stdout.on('data', (data) => {\n  // 监听findstr的输出（就是运行返回的结果）\n  console.log(data.toString()); // 这里就是真正获取到查询结果的地方。\n});\n\nfindstr.stderr.on('data', (data) => {\n  console.log(`findstr stderr: ${data}`);\n});\n\nfindstr.on('close', (code) => {\n  if (code !== 0) {\n    console.log(`findstr进程退出，退出码：${code}`);\n  }\n});\n```\n","slug":"2019/node-process","published":1,"updated":"2021-11-06T07:31:26.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerys00056huf389v4zxq","content":"<p>手头的 electron 项目，需要查询并关闭另外的程序，程序本身虽然是通过子进程方式启动，但是启动的仅是个壳，壳本身又自己启动了另一个程序 Z，导致无法通过子进程启动后的句柄拿到真正启动的程序 Z。所以无法监控到程序 Z 目前是开启还是关闭的。</p>\n<p>解决方法就是 node 子进程模块的 <code>spawn</code>  去执行 windows 的 cmd 命令。该项目只在 windows 电脑运行，所以要用 windows 的命令行而非 liunx 命令。</p>\n<blockquote>\n<p>这里项目本身只在 windows 运行，所以执行的命令应该是 windows 下的，而不是 linux 命令。比如列出当前目录文件，windows 下用的是 <code>dir</code> ，而 linux 下用的是 <code>ls</code> 。两者是不同的，因为我的电脑安装了 <code>cmder</code> ，即可以调用 windows 命令也可以调用 linux 命令。win10 的话有 powershell，可能能支持 linux 命令</p>\n</blockquote>\n<p>直接在 cmd 里面运行查找进程的命令的话，是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist | findstr /i chrome.exe</span><br><span class=\"line\"><span class=\"comment\">// tasklist 查找系统进程后，查找的内容通过管道符 | 传递给另一个命令 findstr ，这个命令接收参数，这里接受了忽略大小写，然后查找chrome.exe关键字，并返回结果。</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>/i</code>  意味忽略大小写。</p>\n<blockquote>\n<p>另外要注意的是，查找进程名字如果很长的话，通过上面的命令，查找出来的进程名字会被截取，限制了 25 个字符好像。所以可以加另一个参数给 tasklist， <code>/fo csv</code>  以该模式输出，避免查找出的结果被截取。这样查找后的结果，是自带””的，如： <code>&quot;YoudaoDict.exe&quot;,&quot;5324&quot;,&quot;Console&quot;,&quot;1&quot;,&quot;37,028 K&quot;</code></p>\n</blockquote>\n<p>开始说正题，node 的子进程模块提供了 <code>exec</code>  和 <code>spawn</code> 2 种方式来调用，其中 <code>exec</code>  会起一个 shell 来执行传入的参数，而 <code>spawn</code>  不会起 shell。所以两种方法调用是有区别的。</p>\n<p><a name=\"U2KVo\"></a></p>\n<h5 id=\"exec-方式\"><a href=\"#exec-方式\" class=\"headerlink\" title=\"exec 方式\"></a>exec 方式</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec(<span class=\"string\">`tasklist /fo csv | findstr /i YouDaoDict.exe`</span>, <span class=\"function\">(<span class=\"params\">err, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`tasklist error: <span class=\"subst\">$&#123;err&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`stdout <span class=\"subst\">$&#123;stdout&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`stderr <span class=\"subst\">$&#123;stderr&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><a name=\"GAj2U\"></a></p>\n<h5 id=\"spawn-方式\"><a href=\"#spawn-方式\" class=\"headerlink\" title=\"spawn 方式\"></a>spawn 方式</h5><p>相比上面的写法，略麻烦，注意 tasklist 和 findstr 是 2 个命令，正如上面解释的那样，是 tasklist 运行获取的值给到 findstr 在做的筛选。因此通过 spawn 的方式，需要这么写：</p>\n<p>这里涉及到了 <code>stdin stdout</code>  的使用，看起来像个流，简单理解下 <code>stdin</code>  就是函数的入参， <code>stdout</code>  就是函数的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; spawn &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> tasklist = spawn(<span class=\"string\">&#x27;tasklist&#x27;</span>, [<span class=\"string\">&#x27;/fo&#x27;</span>, <span class=\"string\">&#x27;csv&#x27;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> findstr = spawn(<span class=\"string\">&#x27;findstr&#x27;</span>, [<span class=\"string\">&#x27;/i&#x27;</span>, <span class=\"string\">&#x27;AsmanVR-Win64-Shipping&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist.stdout.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 往findstr的输入中写入 tasklist的输出数据。</span></span><br><span class=\"line\">  findstr.stdin.write(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist.stderr.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">`tasklist stderr: <span class=\"subst\">$&#123;data&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (code !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`tasklist进程退出，退出码：<span class=\"subst\">$&#123;code&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  findstr.stdin.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">findstr.stdout.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 监听findstr的输出（就是运行返回的结果）</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data.toString()); <span class=\"comment\">// 这里就是真正获取到查询结果的地方。</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">findstr.stderr.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`findstr stderr: <span class=\"subst\">$&#123;data&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">findstr.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (code !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`findstr进程退出，退出码：<span class=\"subst\">$&#123;code&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>手头的 electron 项目，需要查询并关闭另外的程序，程序本身虽然是通过子进程方式启动，但是启动的仅是个壳，壳本身又自己启动了另一个程序 Z，导致无法通过子进程启动后的句柄拿到真正启动的程序 Z。所以无法监控到程序 Z 目前是开启还是关闭的。</p>\n<p>解决方法就是 node 子进程模块的 <code>spawn</code>  去执行 windows 的 cmd 命令。该项目只在 windows 电脑运行，所以要用 windows 的命令行而非 liunx 命令。</p>\n<blockquote>\n<p>这里项目本身只在 windows 运行，所以执行的命令应该是 windows 下的，而不是 linux 命令。比如列出当前目录文件，windows 下用的是 <code>dir</code> ，而 linux 下用的是 <code>ls</code> 。两者是不同的，因为我的电脑安装了 <code>cmder</code> ，即可以调用 windows 命令也可以调用 linux 命令。win10 的话有 powershell，可能能支持 linux 命令</p>\n</blockquote>\n<p>直接在 cmd 里面运行查找进程的命令的话，是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist | findstr /i chrome.exe</span><br><span class=\"line\"><span class=\"comment\">// tasklist 查找系统进程后，查找的内容通过管道符 | 传递给另一个命令 findstr ，这个命令接收参数，这里接受了忽略大小写，然后查找chrome.exe关键字，并返回结果。</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>/i</code>  意味忽略大小写。</p>\n<blockquote>\n<p>另外要注意的是，查找进程名字如果很长的话，通过上面的命令，查找出来的进程名字会被截取，限制了 25 个字符好像。所以可以加另一个参数给 tasklist， <code>/fo csv</code>  以该模式输出，避免查找出的结果被截取。这样查找后的结果，是自带””的，如： <code>&quot;YoudaoDict.exe&quot;,&quot;5324&quot;,&quot;Console&quot;,&quot;1&quot;,&quot;37,028 K&quot;</code></p>\n</blockquote>\n<p>开始说正题，node 的子进程模块提供了 <code>exec</code>  和 <code>spawn</code> 2 种方式来调用，其中 <code>exec</code>  会起一个 shell 来执行传入的参数，而 <code>spawn</code>  不会起 shell。所以两种方法调用是有区别的。</p>\n<p><a name=\"U2KVo\"></a></p>\n<h5 id=\"exec-方式\"><a href=\"#exec-方式\" class=\"headerlink\" title=\"exec 方式\"></a>exec 方式</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec(<span class=\"string\">`tasklist /fo csv | findstr /i YouDaoDict.exe`</span>, <span class=\"function\">(<span class=\"params\">err, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`tasklist error: <span class=\"subst\">$&#123;err&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`stdout <span class=\"subst\">$&#123;stdout&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`stderr <span class=\"subst\">$&#123;stderr&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><a name=\"GAj2U\"></a></p>\n<h5 id=\"spawn-方式\"><a href=\"#spawn-方式\" class=\"headerlink\" title=\"spawn 方式\"></a>spawn 方式</h5><p>相比上面的写法，略麻烦，注意 tasklist 和 findstr 是 2 个命令，正如上面解释的那样，是 tasklist 运行获取的值给到 findstr 在做的筛选。因此通过 spawn 的方式，需要这么写：</p>\n<p>这里涉及到了 <code>stdin stdout</code>  的使用，看起来像个流，简单理解下 <code>stdin</code>  就是函数的入参， <code>stdout</code>  就是函数的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; spawn &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> tasklist = spawn(<span class=\"string\">&#x27;tasklist&#x27;</span>, [<span class=\"string\">&#x27;/fo&#x27;</span>, <span class=\"string\">&#x27;csv&#x27;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> findstr = spawn(<span class=\"string\">&#x27;findstr&#x27;</span>, [<span class=\"string\">&#x27;/i&#x27;</span>, <span class=\"string\">&#x27;AsmanVR-Win64-Shipping&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist.stdout.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 往findstr的输入中写入 tasklist的输出数据。</span></span><br><span class=\"line\">  findstr.stdin.write(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist.stderr.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">`tasklist stderr: <span class=\"subst\">$&#123;data&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">tasklist.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (code !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`tasklist进程退出，退出码：<span class=\"subst\">$&#123;code&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  findstr.stdin.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">findstr.stdout.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 监听findstr的输出（就是运行返回的结果）</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data.toString()); <span class=\"comment\">// 这里就是真正获取到查询结果的地方。</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">findstr.stderr.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`findstr stderr: <span class=\"subst\">$&#123;data&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">findstr.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (code !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`findstr进程退出，退出码：<span class=\"subst\">$&#123;code&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"React PureComponent 的浅比较","date":"2019-12-29T16:00:00.000Z","_content":"\n在使用 `antd`  的 `form`  组件时，使用到了 `getFiledDecorator`  去包装了表单组件，其中一个表单组件是颜色选择器，颜色选择器这个表单组件是按  `antd`  自定义表单组件的方式，同时该组件也是用 `PureComponent`  声明的。\n\n然后我在使用 `setFiledValue`  去修改另一个表单组件 A 的值时，发现，也会触发颜色选择器组件的 `render` 。原以为只会触发我修改的 A 的渲染才对。\n\n测试发现，如果不使用 `getFiledDecorator`  的话，是不会给组件添加额外的 `props`  的，此时你去修改 A 组件的值，颜色选择器配合 `PureComponent`  声明的方式，接收到的新旧  `props`  都是 `{}` 。如果使用了 `getFieldDecorator`  进行包装的话，即便是 `PureComponent`  也会渲染组件，得到的新旧 `props`  如下：\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/241313/1578574171429-c0c467d6-fc64-44a8-83dc-1f3d09f77c49.png#align=left&display=inline&height=252&name=image.png&originHeight=504&originWidth=1182&size=95136&status=done&style=none&width=591)\n\n然后找了下 `PureComponent`  组件默认的浅比较方式，发现的确会出现以上描述的情况。\n\n自带的浅比较函数如下，其中 `is`  函数是 `Object.is`  的实现，只不过处理了 2 个特殊的情况，即让 `+0 === -0` , 让 `NaN !== NaN` 。\n\n```javascript\nif (ctor.prototype && ctor.prototype.isPureReactComponent) {\n  // 先判断组件是否继承的PureComponent\n  return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n}\n\nfunction shallowEqual(objA: mixed, objB: mixed): boolean {\n  if (is(objA, objB)) {\n    // 先用React实现的Object.is去比较2个参数，基本是同类型，同值，同引用的比较，如果不同，在往下比较。\n    return true;\n  }\n\n  // 如果有一个参数的类型是对象，则肯定是不相等的（仔细理解第一个if的比较，同类型同值同引用，如果引用不同，肯定不等，那对象和JS的基本类型更不可能相等）\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  // 浅比较对象引用，获取2个参数的键名长度，不一致肯定不等。一致的话，在下面进行对象的第一层比较\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      // 比较A的键名是否存在于B对象中，用的是hasOwnProperty。\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      // 如果存在，看看A和B同键名的值是否引用相同（如果是对象），这里用is函数来搞定。\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  // 浅比较结束，这里返回trur, 认为两者相等。\n  return true;\n}\n```\n\n所以在解释开篇提到的场景，两个 `{}`  的比较，比较到了最后一步，for 循环时，没有长度，里面没法走，直接到最后 `return true`  了。\n\n然后包装后，Props 变多了，然后就进到了 for 循环里比较，发现深层的对象引用不一致。（这里有个疑惑，可能在第一步 is(A,B)就已经判断出来引用不同了，具体看 antd 的传参 Props 是怎么写的，是一个变量还是一个手写{}）\n","source":"_posts/2019/react-purecompent-diff.md","raw":"---\ntitle: React PureComponent 的浅比较\ndate: 2019/12/30\n---\n\n在使用 `antd`  的 `form`  组件时，使用到了 `getFiledDecorator`  去包装了表单组件，其中一个表单组件是颜色选择器，颜色选择器这个表单组件是按  `antd`  自定义表单组件的方式，同时该组件也是用 `PureComponent`  声明的。\n\n然后我在使用 `setFiledValue`  去修改另一个表单组件 A 的值时，发现，也会触发颜色选择器组件的 `render` 。原以为只会触发我修改的 A 的渲染才对。\n\n测试发现，如果不使用 `getFiledDecorator`  的话，是不会给组件添加额外的 `props`  的，此时你去修改 A 组件的值，颜色选择器配合 `PureComponent`  声明的方式，接收到的新旧  `props`  都是 `{}` 。如果使用了 `getFieldDecorator`  进行包装的话，即便是 `PureComponent`  也会渲染组件，得到的新旧 `props`  如下：\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/241313/1578574171429-c0c467d6-fc64-44a8-83dc-1f3d09f77c49.png#align=left&display=inline&height=252&name=image.png&originHeight=504&originWidth=1182&size=95136&status=done&style=none&width=591)\n\n然后找了下 `PureComponent`  组件默认的浅比较方式，发现的确会出现以上描述的情况。\n\n自带的浅比较函数如下，其中 `is`  函数是 `Object.is`  的实现，只不过处理了 2 个特殊的情况，即让 `+0 === -0` , 让 `NaN !== NaN` 。\n\n```javascript\nif (ctor.prototype && ctor.prototype.isPureReactComponent) {\n  // 先判断组件是否继承的PureComponent\n  return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n}\n\nfunction shallowEqual(objA: mixed, objB: mixed): boolean {\n  if (is(objA, objB)) {\n    // 先用React实现的Object.is去比较2个参数，基本是同类型，同值，同引用的比较，如果不同，在往下比较。\n    return true;\n  }\n\n  // 如果有一个参数的类型是对象，则肯定是不相等的（仔细理解第一个if的比较，同类型同值同引用，如果引用不同，肯定不等，那对象和JS的基本类型更不可能相等）\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  // 浅比较对象引用，获取2个参数的键名长度，不一致肯定不等。一致的话，在下面进行对象的第一层比较\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      // 比较A的键名是否存在于B对象中，用的是hasOwnProperty。\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      // 如果存在，看看A和B同键名的值是否引用相同（如果是对象），这里用is函数来搞定。\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  // 浅比较结束，这里返回trur, 认为两者相等。\n  return true;\n}\n```\n\n所以在解释开篇提到的场景，两个 `{}`  的比较，比较到了最后一步，for 循环时，没有长度，里面没法走，直接到最后 `return true`  了。\n\n然后包装后，Props 变多了，然后就进到了 for 循环里比较，发现深层的对象引用不一致。（这里有个疑惑，可能在第一步 is(A,B)就已经判断出来引用不同了，具体看 antd 的传参 Props 是怎么写的，是一个变量还是一个手写{}）\n","slug":"2019/react-purecompent-diff","published":1,"updated":"2021-11-06T07:31:45.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryt00066hufd9cohq96","content":"<p>在使用 <code>antd</code>  的 <code>form</code>  组件时，使用到了 <code>getFiledDecorator</code>  去包装了表单组件，其中一个表单组件是颜色选择器，颜色选择器这个表单组件是按  <code>antd</code>  自定义表单组件的方式，同时该组件也是用 <code>PureComponent</code>  声明的。</p>\n<p>然后我在使用 <code>setFiledValue</code>  去修改另一个表单组件 A 的值时，发现，也会触发颜色选择器组件的 <code>render</code> 。原以为只会触发我修改的 A 的渲染才对。</p>\n<p>测试发现，如果不使用 <code>getFiledDecorator</code>  的话，是不会给组件添加额外的 <code>props</code>  的，此时你去修改 A 组件的值，颜色选择器配合 <code>PureComponent</code>  声明的方式，接收到的新旧  <code>props</code>  都是 <code>&#123;&#125;</code> 。如果使用了 <code>getFieldDecorator</code>  进行包装的话，即便是 <code>PureComponent</code>  也会渲染组件，得到的新旧 <code>props</code>  如下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/241313/1578574171429-c0c467d6-fc64-44a8-83dc-1f3d09f77c49.png#align=left&display=inline&height=252&name=image.png&originHeight=504&originWidth=1182&size=95136&status=done&style=none&width=591\" alt=\"image.png\"></p>\n<p>然后找了下 <code>PureComponent</code>  组件默认的浅比较方式，发现的确会出现以上描述的情况。</p>\n<p>自带的浅比较函数如下，其中 <code>is</code>  函数是 <code>Object.is</code>  的实现，只不过处理了 2 个特殊的情况，即让 <code>+0 === -0</code> , 让 <code>NaN !== NaN</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先判断组件是否继承的PureComponent</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowEqual</span>(<span class=\"params\">objA: mixed, objB: mixed</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is(objA, objB)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先用React实现的Object.is去比较2个参数，基本是同类型，同值，同引用的比较，如果不同，在往下比较。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果有一个参数的类型是对象，则肯定是不相等的（仔细理解第一个if的比较，同类型同值同引用，如果引用不同，肯定不等，那对象和JS的基本类型更不可能相等）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> objA !== <span class=\"string\">&#x27;object&#x27;</span> ||</span><br><span class=\"line\">    objA === <span class=\"literal\">null</span> ||</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> objB !== <span class=\"string\">&#x27;object&#x27;</span> ||</span><br><span class=\"line\">    objB === <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 浅比较对象引用，获取2个参数的键名长度，不一致肯定不等。一致的话，在下面进行对象的第一层比较</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysA = <span class=\"built_in\">Object</span>.keys(objA);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysB = <span class=\"built_in\">Object</span>.keys(objB);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"comment\">// 比较A的键名是否存在于B对象中，用的是hasOwnProperty。</span></span><br><span class=\"line\">      !hasOwnProperty.call(objB, keysA[i]) ||</span><br><span class=\"line\">      <span class=\"comment\">// 如果存在，看看A和B同键名的值是否引用相同（如果是对象），这里用is函数来搞定。</span></span><br><span class=\"line\">      !is(objA[keysA[i]], objB[keysA[i]])</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 浅比较结束，这里返回trur, 认为两者相等。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以在解释开篇提到的场景，两个 <code>&#123;&#125;</code>  的比较，比较到了最后一步，for 循环时，没有长度，里面没法走，直接到最后 <code>return true</code>  了。</p>\n<p>然后包装后，Props 变多了，然后就进到了 for 循环里比较，发现深层的对象引用不一致。（这里有个疑惑，可能在第一步 is(A,B)就已经判断出来引用不同了，具体看 antd 的传参 Props 是怎么写的，是一个变量还是一个手写{}）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用 <code>antd</code>  的 <code>form</code>  组件时，使用到了 <code>getFiledDecorator</code>  去包装了表单组件，其中一个表单组件是颜色选择器，颜色选择器这个表单组件是按  <code>antd</code>  自定义表单组件的方式，同时该组件也是用 <code>PureComponent</code>  声明的。</p>\n<p>然后我在使用 <code>setFiledValue</code>  去修改另一个表单组件 A 的值时，发现，也会触发颜色选择器组件的 <code>render</code> 。原以为只会触发我修改的 A 的渲染才对。</p>\n<p>测试发现，如果不使用 <code>getFiledDecorator</code>  的话，是不会给组件添加额外的 <code>props</code>  的，此时你去修改 A 组件的值，颜色选择器配合 <code>PureComponent</code>  声明的方式，接收到的新旧  <code>props</code>  都是 <code>&#123;&#125;</code> 。如果使用了 <code>getFieldDecorator</code>  进行包装的话，即便是 <code>PureComponent</code>  也会渲染组件，得到的新旧 <code>props</code>  如下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/241313/1578574171429-c0c467d6-fc64-44a8-83dc-1f3d09f77c49.png#align=left&display=inline&height=252&name=image.png&originHeight=504&originWidth=1182&size=95136&status=done&style=none&width=591\" alt=\"image.png\"></p>\n<p>然后找了下 <code>PureComponent</code>  组件默认的浅比较方式，发现的确会出现以上描述的情况。</p>\n<p>自带的浅比较函数如下，其中 <code>is</code>  函数是 <code>Object.is</code>  的实现，只不过处理了 2 个特殊的情况，即让 <code>+0 === -0</code> , 让 <code>NaN !== NaN</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先判断组件是否继承的PureComponent</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowEqual</span>(<span class=\"params\">objA: mixed, objB: mixed</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is(objA, objB)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先用React实现的Object.is去比较2个参数，基本是同类型，同值，同引用的比较，如果不同，在往下比较。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果有一个参数的类型是对象，则肯定是不相等的（仔细理解第一个if的比较，同类型同值同引用，如果引用不同，肯定不等，那对象和JS的基本类型更不可能相等）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> objA !== <span class=\"string\">&#x27;object&#x27;</span> ||</span><br><span class=\"line\">    objA === <span class=\"literal\">null</span> ||</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> objB !== <span class=\"string\">&#x27;object&#x27;</span> ||</span><br><span class=\"line\">    objB === <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 浅比较对象引用，获取2个参数的键名长度，不一致肯定不等。一致的话，在下面进行对象的第一层比较</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysA = <span class=\"built_in\">Object</span>.keys(objA);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysB = <span class=\"built_in\">Object</span>.keys(objB);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"comment\">// 比较A的键名是否存在于B对象中，用的是hasOwnProperty。</span></span><br><span class=\"line\">      !hasOwnProperty.call(objB, keysA[i]) ||</span><br><span class=\"line\">      <span class=\"comment\">// 如果存在，看看A和B同键名的值是否引用相同（如果是对象），这里用is函数来搞定。</span></span><br><span class=\"line\">      !is(objA[keysA[i]], objB[keysA[i]])</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 浅比较结束，这里返回trur, 认为两者相等。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以在解释开篇提到的场景，两个 <code>&#123;&#125;</code>  的比较，比较到了最后一步，for 循环时，没有长度，里面没法走，直接到最后 <code>return true</code>  了。</p>\n<p>然后包装后，Props 变多了，然后就进到了 for 循环里比较，发现深层的对象引用不一致。（这里有个疑惑，可能在第一步 is(A,B)就已经判断出来引用不同了，具体看 antd 的传参 Props 是怎么写的，是一个变量还是一个手写{}）</p>\n"},{"title":"React 和 Redux 技术栈快速接入 TS 指南","date":"2019-12-29T16:00:00.000Z","_content":"\n> TS 的基本知识这里不做过多的介绍，请自己参照入门文档：[TS 入门文档](https://ts.xcatliu.com/introduction/get-typescript)。\n\n推荐直接使用*create-react-app*直接生成支持 ts 的项目，然后进行 TS 代码测试，`create-react-app myProject --typescript`。或者直接使用 TS 官方提供的[TS 在线测试](http://www.typescriptlang.org/play/?esModuleInterop=true&target=6&jsx=2#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyRyYwYANhAFzIDOYUoA5gNyHGYS0KMAOp6EDXqMQrfAF98+MAE9eKOMgC8yAApwopOOQA8GbAD4gA)。\n\n## 常用 React 内建常用类型\n\n> 建议先浏览一遍有印象\n\n- `React.FC<Props>`，定义函数组件用。\n\n- `React.Component<Props, State>`，定义类组件用。\n\n- `React.ReactNode`，用来定义各种 react 节点，比如`<div />`, `<MyComp />`, `this is a just a text`, `null`, `0`...\n\n- `React.CSSProperties`，用来定义内联`style`的。\n\n- `React.HTMLProps<HTMLXXXELEMENT>`，获取内建 html 元素的属性。\n-\n- `React.PropsWithChildren`，如果需要显示使用 children，使用该类型创建 props，如：`React.PropsWithChildren<{a: string}>`。\n\n- `React.ReactEventHandler<HTMLXXXELEMENT>`，用来描述元素的事件处理函数。可以自行推导出适合的事件函数描述。\n\n- `React.ChangeEventHandler<HTMLXXXELEMENT>`，最常见的如 input 的 change 事件函数描述，人为的判定类型。区别于上面的，这里的 event 可用 event.target.value，上面的是 event.currentTarget.value。类似还有`MouseEventHandler`, `MouseEventHandler`等。\n\n## 常用的 TS 内建工具泛型和关键字\n\n> 建议先浏览一遍有印象\n\n- `typeof`关键字，自动推断出类型。如`typeof {a: 1, b: 'hello'}` 得到 {a: number, b: string}。\n\n- `keyof`关键字，类似于`Object.keys`。`keyof {a: string, b: string}`得到`'a' | 'b'`。\n\n- `in`关键字，类似于`let k in obj`，遍历。`type Keys = 'a' | 'b', type Obj = {[p in Keys]: any}`，遍历了 Keys，p 相当于 k，得到的 Obj = {a: any, b: any}。\n\n- `Partial<T>`，将 T 类型全部变为可选。如`Partial<{a: stirng, b: number}>` 得到 `{a: string | undefined, b: number | undefined}`。\n\n- `Omit<P, K>`，从 P 中排除 K，返回排除后的结果。如`Omit<{a: string, b: number}, 'a'>` 得到 `{b: number}`。\n\n- `Pick<T, K>`，从 T 中挑选出 K。如`Pick<{a: 1, b: 2, c: 3}, 'a' | 'b'` 得到`{a: 1, b: 2}`。（这里类型值写的是 number 类型的数字，TS 会推断出 number 类型）。\n\n- `Exclude<T, U>`，从类型 T 中排除不在类型 U 中的。如`Exclude<'a' | 'b', 'b' | 'c'>` 得到 `'a'`，如`Exclude<{a: 1, b:2}, {a: 1, b:2, c: 3}>` 得到 `{a: 1, b: 2}`【这里可以这么理解：T 属于 U 的一种具体实现则返回 never，不是则返回 T】。自己实现`type Exc<T, U> = T extends U ? never: T`。\n\n- `Extract<T, U>`，从类型 T 中提取出可以分配给类型 U 的部分。如`Extract<'a' | 'b', 'b' | 'c'>` 得到 `'b'`，如`Extract<{a: 1, b:2}, {a: 1, b:2, c: 3}>` 得到 `never`。【这里可以这么理解：T 属于 U 的一种具体实现，则返回 T，不是则返回 never】。自己实现`type Ext<T, U> = T extends U ? T : never`。\n\n## 非 React 技术栈的常见的 TS 用法\n\n### 类型预测\n\n`is`关键字。常用场景，明确一个对象的类型后，会调用该对象的属性或方法。\n\n```js\nfunction do(str) {\n  return str.length; // 如果 str 是 number类型，就会报错。\n}\n```\n\n```js\n// 这样写只能在编译阶段，当你传递的参数不是字符串类型而报错提示。\n// 如果传入的参数是经过计算或者异步获取，无法保证时，运行时会很大概率报错。\nfunction do(str: string) {\n  return str.length;\n}\n```\n\n```js\nfunction do(str: string) {\n  if (typeof str === 'string') {\n    // 做好类型判断后编译和运行时都不会报错。但是每次都判断的话，代码变多有点麻烦。\n    return str.length;\n  }\n}\n```\n\n通常会封装一个判断函数\n\n```js\n// 一个判断函数\nfunction isString(val) {\n  return typeof val === 'string';\n}\nfunction do(str: string) {\n  // 调用判断函数\n  if (isString(str)) {\n    return str.length;\n  }\n}\n```\n\n```js\n// 如果do函数的入参无法确认类型。我们通常会用any。\nfunction do(str: any) {\n  // 这里TS已经忽略了入参类型。\n  if (isString(str)) {\n    return str.length; // 如果无length属性也不会在编译阶段报错，这跟我们使用TS的愿景不一致。\n  }\n}\n```\n\n```js\n// 使用类型预测 str is string。\nfunction isString(str: any): str is string {\n  return typeof val === 'string'\n}\nfunction do(val: any) {\n  if(isString(val)) { // 这里在运行时阶段也会判断是否是是string，再决定进入if内的执行代码。\n    return str.length // 这里在编译阶段（书写时）会获得string类型对象的所有属性和方法提示。\n  }\n}\n```\n\n> str is string 能否改为: boolean，即 isString 返回的是一个布尔值？不能。改成单一的布尔类型后，无法获得期望的 string 类型对象的属性和方法推断。\n\n## React 常见写法\n\n### 函数组件写法\n\n```js\nconst FcComp: React.FC<{ prop1: string }> = ({ prop1 }) => {\n  return <div>{prop1}</div>;\n};\n```\n\n### 类组件写法\n\n```js\ninterface IProps {\n  name: string;\n}\ninterface IState {\n  age: number;\n}\nclass ClsComp extends React.Component<IProps, IState> {\n  state = {\n    age: 18,\n  };\n}\n```\n\n### 默认参数写法\n\n```js\ninterface IProps extends IDefaultProps {\n  name: string;\n}\ntype IDefaultProps = typeof DefComp.defaultProps; // 获取到默认属性的type签名\nclass DefComp extends React.Component<IProps, State> {\n  static defaultProps = {\n    work: 'docter',\n  };\n\n  render() {\n    return (\n      <div>\n        {this.props.name} is {this.props.work}\n      </div>\n    );\n  }\n}\n```\n\n> 其他写法参照项目中*defaultProps*文件夹\n\n### 通用组件写法\n\n这里描述一个最常见的情景，一个列表组件。利用泛型（阅读入门 TS 泛型部分）实现。\n\n```js\n// 组件定义\ninterface IProps<T> {\n  lists: T[]\n  renderItem: (item: T) => React.ReactNode // 最好都用ReactNode，而不是JSX.Element。\n}\nclass List<T> extends React.Component<IProps<T>, {}> {\n  render() {\n    const {lists, renderItem} = this.props\n    return (\n      <>\n        <ul>{lists.map(renderItem)}</ul>\n      </>\n    )\n  }\n}\n\n// 调用组件。注意：这里List传入了一个类型number，限制了泛型T的类型。\n<List<number> lists={[1, 2, 3]} renderItem={item => <li key={item}>{item}</li>}/>\n```\n\n### 高阶组件（HOC）写法\n\n> React 的高阶组件即一个函数，接受一个组件，返回一个新的组件。\n\n这里写一个例子，一个 withState 函数，接收一个没有 count 状态的组件，包装后，返回一个带有 count 状态的组件。\n\n```js\n/* withState.tsx */\nexport interface InjectedProps {\n  count: number,\n  onIncrement: () => void\n}\n\nexport const withState = <P extends InjectedProps>(WrappedComp: React.ComponentType<P>) => {\n  // 使用Omit结合keyof，实现排除掉IProp和InjectedProps交集的部分(count, onIncrement)\n  type HocProps = Omit<IProp, keyof InjectedProps> & {\n    // 这里可以做HOC的Props的扩展。\n    initialCount?: number\n  }\n  type HocState = { readonly count: number }\n\n  return class Hoc extends React.Component<HocProps, HocState> {\n    // 组件的名字，方便调试\n    static displayName = `withState(${WrappedComp.name})`\n\n    state: HocState = {\n      count: Number(this.props.initialCount) || 0\n    }\n\n    handleInc = () => {\n      this.setState({\n        count: this.state.count + 1\n      })\n    }\n\n    render() {\n      const { ...restProps } = this.props\n      const { count } = this.state\n      return (\n        <WrappedComp\n          count={count}\n          onIncrement={this.handleInc}\n          // HOC组件，应该透传与HOC无关的Prop给被包裹的组件。这里的写法是因为TS本身的BUG，如果不断言，则类型报错。\n          {...(restProps as IProp)}\n        ></WrappedComp>\n      )\n    }\n  }\n}\n```\n\n```js\n/* FcCounter.tsx */\nexport const FcCounter: React.FC<Props> = (props) => {\n  const { label, count, onIncrement } = props;\n  const handleIncrement = () => {\n    onIncrement();\n  };\n  return (\n    <div>\n      <span>\n        {label}:{count}\n      </span>\n      <button type=\"button\" onClick={handleIncrement}>{`Increment`}</button>\n    </div>\n  );\n};\n```\n\n```js\n/* 调用组件 */\nimport { FcCounter } from './FcCounter'\nimport { withState } from './withState'\n\nconst HocCounterWithState = withState(FcCounter)\n\n<HocCounterWithState initialCount={10} label=\"HocCounterWithState\" />\n```\n\n### 默认 props 的写法\n\n```js\n// 类组件写法\ninterface IProps extends defaultProps {\n  age: number;\n}\n// 使用typeof获取到类组件的默认参数类型\ntype defaultProps = typeof DefaultPropsComp.defaultProps;\nclass DefaultPropsComp extends React.Component<IProps> {\n  static defaultProps = {\n    name: 'jack',\n  };\n\n  echoProps = () => {\n    // 这里也可以获得TS提示\n    const { age, name } = this.props;\n  };\n\n  render() {\n    return <p>this is how to set default props of class component</p>;\n  }\n}\n\n// 函数组件写法\nconst defaultProps = {\n  work: 'doctor',\n};\ninterface IProps extends defaultPropsType {\n  age: number;\n}\ntype defaultPropsType = typeof defaultProps;\n\nfunction DefaultPropsFC(props: IProps) {\n  // 这里可以获得提示\n  const { work, age } = props;\n\n  return <p>{`The ${work} is ${age}`}</p>;\n}\n\n// 注意：一定要挂载默认属性，否则调用组件的地方默认值也需要传入\nDefaultPropsFC.defaultProps = defaultProps;\n```\n\n### 断言\n\n简单理解为可以 100%确定是什么类型，让 TS 按照确定的类型来进行 TS 提示，推断等。\n\nJSX 中只支持用 `as` 断言写法。不支持**<>**写法，如`var a = <string>b`。跟 jsx 冲突，会当成标签。\n\n```js\ntype UserA = {\n  name: string,\n  age: number\n}\n\ntype UserB = {\n  name: string,\n  sex: string\n}\n\ntype IProps = {\n  user: UserA | UserB\n}\n\nclass AssertComp extends React.Component<IProps, {}> {\n  render() {\n    // 这里如果不做类型断言，会提示UserA上没有sex属性\n    // const user = this.props.user\n    const userB = this.props.user as UserB\n    const userA = this.props.user as UserA\n    return <div>\n      <p>this is a user: {userA.age}</p>\n      <p>this is a user: {userB.sex}</p>\n    </div>\n  }\n}\n\n```\n\n### Context 写法\n\n用 React 官方 DOC 里的更改按钮颜色主题做例子。\n\n```js\n/* ctx.tsx */\nexport type Theme = React.CSSProperties\n\ntype Themes = {\n  dark: Theme\n  light: Theme\n}\n\nexport const themes: Themes = {\n  dark: {\n    color: 'black',\n    backgroundColor: 'white'\n  },\n  light: {\n    color: 'white',\n    backgroundColor: 'black'\n  }\n}\n// 这里定义Context的签名\nexport type ThemeContextProps = { theme: Theme; toggleTheme?: () => void }\n\n// createContext<T>需要一个类型，把定义好的Context签名传递进去\nconst ThemeContext = React.createContext<ThemeContextProps>({\n  theme: themes.light\n})\n```\n\n```js\n/* themeButton.tsx */\nimport ThemeContext from './ctx'\n\n// contextType v16.6+支持\nexport default class ToggleThemeButton extends React.Component<{}> {\n  static contextType = ThemeContext\n\n  // 后面需要通过this.context访问到上下文，所以定义一个类属性\n  // 这里使用!明确告诉TS，该参数一定有。\n  // 这里不能使用？，因为context是必选项\n  context!: React.ContextType<typeof ThemeContext>\n\n  render() {\n    // 前面context必须这么写，这里才能获取TS提示\n    const { theme, toggleTheme } = this.context\n    return (\n      <button style={theme} onClick={toggleTheme} {...this.props}>\n        button\n      </button>\n    )\n  }\n}\n```\n\n```js\n/* provider组件 */\nimport ThemeContext, { Theme, themes } from './ctx';\nimport ThemeButton from './themeButton';\n\nexport default class ThemeProvider extends React.Component<{}, State> {\n  state: State = {\n    theme: themes.light,\n  };\n\n  toggleTheme = () => {\n    this.setState((state) => ({\n      theme: state.theme === themes.light ? themes.dark : themes.light,\n    }));\n  };\n\n  render() {\n    const { theme } = this.state;\n    const { toggleTheme } = this;\n    return (\n      <ThemeContext.Provider value={{ theme, toggleTheme }}>\n        <ThemeButton />\n      </ThemeContext.Provider>\n    );\n  }\n}\n```\n\n### 多类型参数（重载）\n\n假设组件接收 2 种类型的 props。可以传`{a: string, config?: number}`，或者`{b: string}`。传递 config 时，说明是用的第一种类型 Props，也一定需要传递 a.\n\n```js\n// 定义types\ntype CommonProps = {\n  children: React.ReactNode\n  as: 'p' | 'span' | 'h1'\n}\n\ntype NoTrucateProps = CommonProps & {\n  truncate?: false\n}\n\ntype TrucateProps = CommonProps & {\n  truncate: true\n  expanded?: boolean\n}\n\n// 定义一个类型判断，运行时可用，这里使用了is技巧。\nconst isTrucateProps = (\n  props: TrucateProps | NoTrucateProps\n): props is TrucateProps => {\n  return !!props.truncate\n}\n\n// 这里是关键，函数重载，约定入参和反参。（并不是具体代码实现）调用组件的地方即可获取正确提示。\nfunction Text(props: NoTrucateProps): JSX.Element\nfunction Text(props: TrucateProps): JSX.Element\n// 这里才是Text函数的真正实现。\nfunction Text(props: NoTrucateProps | TrucateProps) {\n  console.log(props)\n  if (isTrucateProps(props)) {\n    const { children, as: Tag, truncate, expanded, ...others } = props\n    const classNames = truncate ? '.truncate' : ''\n    return (\n      <Tag className={classNames} aria-expanded={!!expanded} {...others}>\n        {children}\n      </Tag>\n    )\n  }\n\n  const { children, as: Tag, ...others } = props\n  return <Tag {...others}>{children}</Tag>\n}\n\nText.defaultProps = {\n  as: 'p'\n}\n```\n\n```js\n// 调用地\n// 这里传递了expanded，但未传入truncate，会获得提示。^_^\n<OptionalProps expanded>truncate-able but expanded</OptionalProps>\n```\n\n### 零碎，但频率高的 React 用法\n\n包括：**style 样式定义**，**接收 React 节点定义**，**事件函数定义**，**固定可选参数配置**，**类属性定义**，**Ref 定义**。\n\n```js\n/* usefulReactProp.tsx */\ninterface IProps extends DefaultProps {\n  descText: string // 基本的类型\n  style?: React.CSSProperties // 可以在调用组件的地方，获得style的完美提示。\n  additionDom?: React.ReactNode // 接收任何类型的React节点\n  renderReactNode?: () => React.ReactNode // 接收一个以函数方式返回的React节点\n  onChange: React.FormEventHandler<HTMLInputElement> // 优先推荐这种写法，让TS自己推断。下面的方法定义同样可以。\n  // onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n  buttonSize: 'small' | 'middle' | 'big' // 可选参数\n}\n\ntype DefaultProps = typeof UsefulReactProp.defaultProps\ninterface IState {\n  value: string\n}\n\nexport default class UsefulReactProp extends React.Component<IProps, IState> {\n  static defaultProps = {\n    initVal: '输入内容'\n  }\n\n  // 定义一个dom引用。使用如下定义方式\n  static aDom = React.createRef<HTMLDivElement>()\n\n  // 定义一个类属性，可以在需要时在赋值使用\n  static classProp?: string\n\n  // 定义一个类属性，在定义时即复制\n  static classProp2 = 'hello'\n\n  state = {\n    value: this.props.initVal\n  }\n\n  defaultOnChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { onChange } = this.props\n    this.setState({\n      value: e.target.value\n    })\n    this.classProp = 'hello world'\n    onChange(e)\n  }\n\n  render() {\n    const { onChange, style, additionDom, renderReactNode } = this.props\n    const { value } = this.state\n    // 如下代码提示只有3种上述定义过的值。\n    const btnSize =\n      this.props.buttonSize === 'big'\n        ? '100px'\n        : this.props.buttonSize === 'small'\n        ? '60px'\n        : '80px;'\n    return (\n      <div>\n        <input type=\"text\" value={value} onChange={this.defaultOnChange} />\n        <p className=\"desc\" style={style}>\n          这是个带样式的提醒\n        </p>\n        <div className=\"additional\">{additionDom}</div>\n        <div className=\"by-func-rcnode\">\n          {renderReactNode ? renderReactNode() : null}\n        </div>\n        <button style={{ width: btnSize }}>按钮尺寸：联合类型提示</button>\n      </div>\n    )\n  }\n}\n```\n\n```js\n/* 调用 */\n// 如下都可以获取类型提示。\n<UsefulReactProp\n  descText=\"一个简单的描述\"\n  onChange={(e) => {\n    console.log(e.currentTarget.value);\n  }}\n  style={{ fontSize: 14, fontWeight: 'bold' }}\n  additionDom={<p>this is additional tag</p>}\n  renderReactNode={() => {\n    return <p>这是通过函数返回的ReactNode</p>;\n  }}\n  buttonSize=\"big\"\n/>\n```\n","source":"_posts/2019/ts-react.md","raw":"---\ntitle: React 和 Redux 技术栈快速接入 TS 指南\ndate: 2019/12/30\n---\n\n> TS 的基本知识这里不做过多的介绍，请自己参照入门文档：[TS 入门文档](https://ts.xcatliu.com/introduction/get-typescript)。\n\n推荐直接使用*create-react-app*直接生成支持 ts 的项目，然后进行 TS 代码测试，`create-react-app myProject --typescript`。或者直接使用 TS 官方提供的[TS 在线测试](http://www.typescriptlang.org/play/?esModuleInterop=true&target=6&jsx=2#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyRyYwYANhAFzIDOYUoA5gNyHGYS0KMAOp6EDXqMQrfAF98+MAE9eKOMgC8yAApwopOOQA8GbAD4gA)。\n\n## 常用 React 内建常用类型\n\n> 建议先浏览一遍有印象\n\n- `React.FC<Props>`，定义函数组件用。\n\n- `React.Component<Props, State>`，定义类组件用。\n\n- `React.ReactNode`，用来定义各种 react 节点，比如`<div />`, `<MyComp />`, `this is a just a text`, `null`, `0`...\n\n- `React.CSSProperties`，用来定义内联`style`的。\n\n- `React.HTMLProps<HTMLXXXELEMENT>`，获取内建 html 元素的属性。\n-\n- `React.PropsWithChildren`，如果需要显示使用 children，使用该类型创建 props，如：`React.PropsWithChildren<{a: string}>`。\n\n- `React.ReactEventHandler<HTMLXXXELEMENT>`，用来描述元素的事件处理函数。可以自行推导出适合的事件函数描述。\n\n- `React.ChangeEventHandler<HTMLXXXELEMENT>`，最常见的如 input 的 change 事件函数描述，人为的判定类型。区别于上面的，这里的 event 可用 event.target.value，上面的是 event.currentTarget.value。类似还有`MouseEventHandler`, `MouseEventHandler`等。\n\n## 常用的 TS 内建工具泛型和关键字\n\n> 建议先浏览一遍有印象\n\n- `typeof`关键字，自动推断出类型。如`typeof {a: 1, b: 'hello'}` 得到 {a: number, b: string}。\n\n- `keyof`关键字，类似于`Object.keys`。`keyof {a: string, b: string}`得到`'a' | 'b'`。\n\n- `in`关键字，类似于`let k in obj`，遍历。`type Keys = 'a' | 'b', type Obj = {[p in Keys]: any}`，遍历了 Keys，p 相当于 k，得到的 Obj = {a: any, b: any}。\n\n- `Partial<T>`，将 T 类型全部变为可选。如`Partial<{a: stirng, b: number}>` 得到 `{a: string | undefined, b: number | undefined}`。\n\n- `Omit<P, K>`，从 P 中排除 K，返回排除后的结果。如`Omit<{a: string, b: number}, 'a'>` 得到 `{b: number}`。\n\n- `Pick<T, K>`，从 T 中挑选出 K。如`Pick<{a: 1, b: 2, c: 3}, 'a' | 'b'` 得到`{a: 1, b: 2}`。（这里类型值写的是 number 类型的数字，TS 会推断出 number 类型）。\n\n- `Exclude<T, U>`，从类型 T 中排除不在类型 U 中的。如`Exclude<'a' | 'b', 'b' | 'c'>` 得到 `'a'`，如`Exclude<{a: 1, b:2}, {a: 1, b:2, c: 3}>` 得到 `{a: 1, b: 2}`【这里可以这么理解：T 属于 U 的一种具体实现则返回 never，不是则返回 T】。自己实现`type Exc<T, U> = T extends U ? never: T`。\n\n- `Extract<T, U>`，从类型 T 中提取出可以分配给类型 U 的部分。如`Extract<'a' | 'b', 'b' | 'c'>` 得到 `'b'`，如`Extract<{a: 1, b:2}, {a: 1, b:2, c: 3}>` 得到 `never`。【这里可以这么理解：T 属于 U 的一种具体实现，则返回 T，不是则返回 never】。自己实现`type Ext<T, U> = T extends U ? T : never`。\n\n## 非 React 技术栈的常见的 TS 用法\n\n### 类型预测\n\n`is`关键字。常用场景，明确一个对象的类型后，会调用该对象的属性或方法。\n\n```js\nfunction do(str) {\n  return str.length; // 如果 str 是 number类型，就会报错。\n}\n```\n\n```js\n// 这样写只能在编译阶段，当你传递的参数不是字符串类型而报错提示。\n// 如果传入的参数是经过计算或者异步获取，无法保证时，运行时会很大概率报错。\nfunction do(str: string) {\n  return str.length;\n}\n```\n\n```js\nfunction do(str: string) {\n  if (typeof str === 'string') {\n    // 做好类型判断后编译和运行时都不会报错。但是每次都判断的话，代码变多有点麻烦。\n    return str.length;\n  }\n}\n```\n\n通常会封装一个判断函数\n\n```js\n// 一个判断函数\nfunction isString(val) {\n  return typeof val === 'string';\n}\nfunction do(str: string) {\n  // 调用判断函数\n  if (isString(str)) {\n    return str.length;\n  }\n}\n```\n\n```js\n// 如果do函数的入参无法确认类型。我们通常会用any。\nfunction do(str: any) {\n  // 这里TS已经忽略了入参类型。\n  if (isString(str)) {\n    return str.length; // 如果无length属性也不会在编译阶段报错，这跟我们使用TS的愿景不一致。\n  }\n}\n```\n\n```js\n// 使用类型预测 str is string。\nfunction isString(str: any): str is string {\n  return typeof val === 'string'\n}\nfunction do(val: any) {\n  if(isString(val)) { // 这里在运行时阶段也会判断是否是是string，再决定进入if内的执行代码。\n    return str.length // 这里在编译阶段（书写时）会获得string类型对象的所有属性和方法提示。\n  }\n}\n```\n\n> str is string 能否改为: boolean，即 isString 返回的是一个布尔值？不能。改成单一的布尔类型后，无法获得期望的 string 类型对象的属性和方法推断。\n\n## React 常见写法\n\n### 函数组件写法\n\n```js\nconst FcComp: React.FC<{ prop1: string }> = ({ prop1 }) => {\n  return <div>{prop1}</div>;\n};\n```\n\n### 类组件写法\n\n```js\ninterface IProps {\n  name: string;\n}\ninterface IState {\n  age: number;\n}\nclass ClsComp extends React.Component<IProps, IState> {\n  state = {\n    age: 18,\n  };\n}\n```\n\n### 默认参数写法\n\n```js\ninterface IProps extends IDefaultProps {\n  name: string;\n}\ntype IDefaultProps = typeof DefComp.defaultProps; // 获取到默认属性的type签名\nclass DefComp extends React.Component<IProps, State> {\n  static defaultProps = {\n    work: 'docter',\n  };\n\n  render() {\n    return (\n      <div>\n        {this.props.name} is {this.props.work}\n      </div>\n    );\n  }\n}\n```\n\n> 其他写法参照项目中*defaultProps*文件夹\n\n### 通用组件写法\n\n这里描述一个最常见的情景，一个列表组件。利用泛型（阅读入门 TS 泛型部分）实现。\n\n```js\n// 组件定义\ninterface IProps<T> {\n  lists: T[]\n  renderItem: (item: T) => React.ReactNode // 最好都用ReactNode，而不是JSX.Element。\n}\nclass List<T> extends React.Component<IProps<T>, {}> {\n  render() {\n    const {lists, renderItem} = this.props\n    return (\n      <>\n        <ul>{lists.map(renderItem)}</ul>\n      </>\n    )\n  }\n}\n\n// 调用组件。注意：这里List传入了一个类型number，限制了泛型T的类型。\n<List<number> lists={[1, 2, 3]} renderItem={item => <li key={item}>{item}</li>}/>\n```\n\n### 高阶组件（HOC）写法\n\n> React 的高阶组件即一个函数，接受一个组件，返回一个新的组件。\n\n这里写一个例子，一个 withState 函数，接收一个没有 count 状态的组件，包装后，返回一个带有 count 状态的组件。\n\n```js\n/* withState.tsx */\nexport interface InjectedProps {\n  count: number,\n  onIncrement: () => void\n}\n\nexport const withState = <P extends InjectedProps>(WrappedComp: React.ComponentType<P>) => {\n  // 使用Omit结合keyof，实现排除掉IProp和InjectedProps交集的部分(count, onIncrement)\n  type HocProps = Omit<IProp, keyof InjectedProps> & {\n    // 这里可以做HOC的Props的扩展。\n    initialCount?: number\n  }\n  type HocState = { readonly count: number }\n\n  return class Hoc extends React.Component<HocProps, HocState> {\n    // 组件的名字，方便调试\n    static displayName = `withState(${WrappedComp.name})`\n\n    state: HocState = {\n      count: Number(this.props.initialCount) || 0\n    }\n\n    handleInc = () => {\n      this.setState({\n        count: this.state.count + 1\n      })\n    }\n\n    render() {\n      const { ...restProps } = this.props\n      const { count } = this.state\n      return (\n        <WrappedComp\n          count={count}\n          onIncrement={this.handleInc}\n          // HOC组件，应该透传与HOC无关的Prop给被包裹的组件。这里的写法是因为TS本身的BUG，如果不断言，则类型报错。\n          {...(restProps as IProp)}\n        ></WrappedComp>\n      )\n    }\n  }\n}\n```\n\n```js\n/* FcCounter.tsx */\nexport const FcCounter: React.FC<Props> = (props) => {\n  const { label, count, onIncrement } = props;\n  const handleIncrement = () => {\n    onIncrement();\n  };\n  return (\n    <div>\n      <span>\n        {label}:{count}\n      </span>\n      <button type=\"button\" onClick={handleIncrement}>{`Increment`}</button>\n    </div>\n  );\n};\n```\n\n```js\n/* 调用组件 */\nimport { FcCounter } from './FcCounter'\nimport { withState } from './withState'\n\nconst HocCounterWithState = withState(FcCounter)\n\n<HocCounterWithState initialCount={10} label=\"HocCounterWithState\" />\n```\n\n### 默认 props 的写法\n\n```js\n// 类组件写法\ninterface IProps extends defaultProps {\n  age: number;\n}\n// 使用typeof获取到类组件的默认参数类型\ntype defaultProps = typeof DefaultPropsComp.defaultProps;\nclass DefaultPropsComp extends React.Component<IProps> {\n  static defaultProps = {\n    name: 'jack',\n  };\n\n  echoProps = () => {\n    // 这里也可以获得TS提示\n    const { age, name } = this.props;\n  };\n\n  render() {\n    return <p>this is how to set default props of class component</p>;\n  }\n}\n\n// 函数组件写法\nconst defaultProps = {\n  work: 'doctor',\n};\ninterface IProps extends defaultPropsType {\n  age: number;\n}\ntype defaultPropsType = typeof defaultProps;\n\nfunction DefaultPropsFC(props: IProps) {\n  // 这里可以获得提示\n  const { work, age } = props;\n\n  return <p>{`The ${work} is ${age}`}</p>;\n}\n\n// 注意：一定要挂载默认属性，否则调用组件的地方默认值也需要传入\nDefaultPropsFC.defaultProps = defaultProps;\n```\n\n### 断言\n\n简单理解为可以 100%确定是什么类型，让 TS 按照确定的类型来进行 TS 提示，推断等。\n\nJSX 中只支持用 `as` 断言写法。不支持**<>**写法，如`var a = <string>b`。跟 jsx 冲突，会当成标签。\n\n```js\ntype UserA = {\n  name: string,\n  age: number\n}\n\ntype UserB = {\n  name: string,\n  sex: string\n}\n\ntype IProps = {\n  user: UserA | UserB\n}\n\nclass AssertComp extends React.Component<IProps, {}> {\n  render() {\n    // 这里如果不做类型断言，会提示UserA上没有sex属性\n    // const user = this.props.user\n    const userB = this.props.user as UserB\n    const userA = this.props.user as UserA\n    return <div>\n      <p>this is a user: {userA.age}</p>\n      <p>this is a user: {userB.sex}</p>\n    </div>\n  }\n}\n\n```\n\n### Context 写法\n\n用 React 官方 DOC 里的更改按钮颜色主题做例子。\n\n```js\n/* ctx.tsx */\nexport type Theme = React.CSSProperties\n\ntype Themes = {\n  dark: Theme\n  light: Theme\n}\n\nexport const themes: Themes = {\n  dark: {\n    color: 'black',\n    backgroundColor: 'white'\n  },\n  light: {\n    color: 'white',\n    backgroundColor: 'black'\n  }\n}\n// 这里定义Context的签名\nexport type ThemeContextProps = { theme: Theme; toggleTheme?: () => void }\n\n// createContext<T>需要一个类型，把定义好的Context签名传递进去\nconst ThemeContext = React.createContext<ThemeContextProps>({\n  theme: themes.light\n})\n```\n\n```js\n/* themeButton.tsx */\nimport ThemeContext from './ctx'\n\n// contextType v16.6+支持\nexport default class ToggleThemeButton extends React.Component<{}> {\n  static contextType = ThemeContext\n\n  // 后面需要通过this.context访问到上下文，所以定义一个类属性\n  // 这里使用!明确告诉TS，该参数一定有。\n  // 这里不能使用？，因为context是必选项\n  context!: React.ContextType<typeof ThemeContext>\n\n  render() {\n    // 前面context必须这么写，这里才能获取TS提示\n    const { theme, toggleTheme } = this.context\n    return (\n      <button style={theme} onClick={toggleTheme} {...this.props}>\n        button\n      </button>\n    )\n  }\n}\n```\n\n```js\n/* provider组件 */\nimport ThemeContext, { Theme, themes } from './ctx';\nimport ThemeButton from './themeButton';\n\nexport default class ThemeProvider extends React.Component<{}, State> {\n  state: State = {\n    theme: themes.light,\n  };\n\n  toggleTheme = () => {\n    this.setState((state) => ({\n      theme: state.theme === themes.light ? themes.dark : themes.light,\n    }));\n  };\n\n  render() {\n    const { theme } = this.state;\n    const { toggleTheme } = this;\n    return (\n      <ThemeContext.Provider value={{ theme, toggleTheme }}>\n        <ThemeButton />\n      </ThemeContext.Provider>\n    );\n  }\n}\n```\n\n### 多类型参数（重载）\n\n假设组件接收 2 种类型的 props。可以传`{a: string, config?: number}`，或者`{b: string}`。传递 config 时，说明是用的第一种类型 Props，也一定需要传递 a.\n\n```js\n// 定义types\ntype CommonProps = {\n  children: React.ReactNode\n  as: 'p' | 'span' | 'h1'\n}\n\ntype NoTrucateProps = CommonProps & {\n  truncate?: false\n}\n\ntype TrucateProps = CommonProps & {\n  truncate: true\n  expanded?: boolean\n}\n\n// 定义一个类型判断，运行时可用，这里使用了is技巧。\nconst isTrucateProps = (\n  props: TrucateProps | NoTrucateProps\n): props is TrucateProps => {\n  return !!props.truncate\n}\n\n// 这里是关键，函数重载，约定入参和反参。（并不是具体代码实现）调用组件的地方即可获取正确提示。\nfunction Text(props: NoTrucateProps): JSX.Element\nfunction Text(props: TrucateProps): JSX.Element\n// 这里才是Text函数的真正实现。\nfunction Text(props: NoTrucateProps | TrucateProps) {\n  console.log(props)\n  if (isTrucateProps(props)) {\n    const { children, as: Tag, truncate, expanded, ...others } = props\n    const classNames = truncate ? '.truncate' : ''\n    return (\n      <Tag className={classNames} aria-expanded={!!expanded} {...others}>\n        {children}\n      </Tag>\n    )\n  }\n\n  const { children, as: Tag, ...others } = props\n  return <Tag {...others}>{children}</Tag>\n}\n\nText.defaultProps = {\n  as: 'p'\n}\n```\n\n```js\n// 调用地\n// 这里传递了expanded，但未传入truncate，会获得提示。^_^\n<OptionalProps expanded>truncate-able but expanded</OptionalProps>\n```\n\n### 零碎，但频率高的 React 用法\n\n包括：**style 样式定义**，**接收 React 节点定义**，**事件函数定义**，**固定可选参数配置**，**类属性定义**，**Ref 定义**。\n\n```js\n/* usefulReactProp.tsx */\ninterface IProps extends DefaultProps {\n  descText: string // 基本的类型\n  style?: React.CSSProperties // 可以在调用组件的地方，获得style的完美提示。\n  additionDom?: React.ReactNode // 接收任何类型的React节点\n  renderReactNode?: () => React.ReactNode // 接收一个以函数方式返回的React节点\n  onChange: React.FormEventHandler<HTMLInputElement> // 优先推荐这种写法，让TS自己推断。下面的方法定义同样可以。\n  // onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n  buttonSize: 'small' | 'middle' | 'big' // 可选参数\n}\n\ntype DefaultProps = typeof UsefulReactProp.defaultProps\ninterface IState {\n  value: string\n}\n\nexport default class UsefulReactProp extends React.Component<IProps, IState> {\n  static defaultProps = {\n    initVal: '输入内容'\n  }\n\n  // 定义一个dom引用。使用如下定义方式\n  static aDom = React.createRef<HTMLDivElement>()\n\n  // 定义一个类属性，可以在需要时在赋值使用\n  static classProp?: string\n\n  // 定义一个类属性，在定义时即复制\n  static classProp2 = 'hello'\n\n  state = {\n    value: this.props.initVal\n  }\n\n  defaultOnChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { onChange } = this.props\n    this.setState({\n      value: e.target.value\n    })\n    this.classProp = 'hello world'\n    onChange(e)\n  }\n\n  render() {\n    const { onChange, style, additionDom, renderReactNode } = this.props\n    const { value } = this.state\n    // 如下代码提示只有3种上述定义过的值。\n    const btnSize =\n      this.props.buttonSize === 'big'\n        ? '100px'\n        : this.props.buttonSize === 'small'\n        ? '60px'\n        : '80px;'\n    return (\n      <div>\n        <input type=\"text\" value={value} onChange={this.defaultOnChange} />\n        <p className=\"desc\" style={style}>\n          这是个带样式的提醒\n        </p>\n        <div className=\"additional\">{additionDom}</div>\n        <div className=\"by-func-rcnode\">\n          {renderReactNode ? renderReactNode() : null}\n        </div>\n        <button style={{ width: btnSize }}>按钮尺寸：联合类型提示</button>\n      </div>\n    )\n  }\n}\n```\n\n```js\n/* 调用 */\n// 如下都可以获取类型提示。\n<UsefulReactProp\n  descText=\"一个简单的描述\"\n  onChange={(e) => {\n    console.log(e.currentTarget.value);\n  }}\n  style={{ fontSize: 14, fontWeight: 'bold' }}\n  additionDom={<p>this is additional tag</p>}\n  renderReactNode={() => {\n    return <p>这是通过函数返回的ReactNode</p>;\n  }}\n  buttonSize=\"big\"\n/>\n```\n","slug":"2019/ts-react","published":1,"updated":"2021-11-06T07:32:14.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryu00076huf0m8z0000","content":"<blockquote>\n<p>TS 的基本知识这里不做过多的介绍，请自己参照入门文档：<a href=\"https://ts.xcatliu.com/introduction/get-typescript\">TS 入门文档</a>。</p>\n</blockquote>\n<p>推荐直接使用<em>create-react-app</em>直接生成支持 ts 的项目，然后进行 TS 代码测试，<code>create-react-app myProject --typescript</code>。或者直接使用 TS 官方提供的<a href=\"http://www.typescriptlang.org/play/?esModuleInterop=true&target=6&jsx=2#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyRyYwYANhAFzIDOYUoA5gNyHGYS0KMAOp6EDXqMQrfAF98+MAE9eKOMgC8yAApwopOOQA8GbAD4gA\">TS 在线测试</a>。</p>\n<h2 id=\"常用-React-内建常用类型\"><a href=\"#常用-React-内建常用类型\" class=\"headerlink\" title=\"常用 React 内建常用类型\"></a>常用 React 内建常用类型</h2><blockquote>\n<p>建议先浏览一遍有印象</p>\n</blockquote>\n<ul>\n<li><p><code>React.FC&lt;Props&gt;</code>，定义函数组件用。</p>\n</li>\n<li><p><code>React.Component&lt;Props, State&gt;</code>，定义类组件用。</p>\n</li>\n<li><p><code>React.ReactNode</code>，用来定义各种 react 节点，比如<code>&lt;div /&gt;</code>, <code>&lt;MyComp /&gt;</code>, <code>this is a just a text</code>, <code>null</code>, <code>0</code>…</p>\n</li>\n<li><p><code>React.CSSProperties</code>，用来定义内联<code>style</code>的。</p>\n</li>\n<li><p><code>React.HTMLProps&lt;HTMLXXXELEMENT&gt;</code>，获取内建 html 元素的属性。</p>\n</li>\n<li></li>\n<li><p><code>React.PropsWithChildren</code>，如果需要显示使用 children，使用该类型创建 props，如：<code>React.PropsWithChildren&lt;&#123;a: string&#125;&gt;</code>。</p>\n</li>\n<li><p><code>React.ReactEventHandler&lt;HTMLXXXELEMENT&gt;</code>，用来描述元素的事件处理函数。可以自行推导出适合的事件函数描述。</p>\n</li>\n<li><p><code>React.ChangeEventHandler&lt;HTMLXXXELEMENT&gt;</code>，最常见的如 input 的 change 事件函数描述，人为的判定类型。区别于上面的，这里的 event 可用 event.target.value，上面的是 event.currentTarget.value。类似还有<code>MouseEventHandler</code>, <code>MouseEventHandler</code>等。</p>\n</li>\n</ul>\n<h2 id=\"常用的-TS-内建工具泛型和关键字\"><a href=\"#常用的-TS-内建工具泛型和关键字\" class=\"headerlink\" title=\"常用的 TS 内建工具泛型和关键字\"></a>常用的 TS 内建工具泛型和关键字</h2><blockquote>\n<p>建议先浏览一遍有印象</p>\n</blockquote>\n<ul>\n<li><p><code>typeof</code>关键字，自动推断出类型。如<code>typeof &#123;a: 1, b: &#39;hello&#39;&#125;</code> 得到 {a: number, b: string}。</p>\n</li>\n<li><p><code>keyof</code>关键字，类似于<code>Object.keys</code>。<code>keyof &#123;a: string, b: string&#125;</code>得到<code>&#39;a&#39; | &#39;b&#39;</code>。</p>\n</li>\n<li><p><code>in</code>关键字，类似于<code>let k in obj</code>，遍历。<code>type Keys = &#39;a&#39; | &#39;b&#39;, type Obj = &#123;[p in Keys]: any&#125;</code>，遍历了 Keys，p 相当于 k，得到的 Obj = {a: any, b: any}。</p>\n</li>\n<li><p><code>Partial&lt;T&gt;</code>，将 T 类型全部变为可选。如<code>Partial&lt;&#123;a: stirng, b: number&#125;&gt;</code> 得到 <code>&#123;a: string | undefined, b: number | undefined&#125;</code>。</p>\n</li>\n<li><p><code>Omit&lt;P, K&gt;</code>，从 P 中排除 K，返回排除后的结果。如<code>Omit&lt;&#123;a: string, b: number&#125;, &#39;a&#39;&gt;</code> 得到 <code>&#123;b: number&#125;</code>。</p>\n</li>\n<li><p><code>Pick&lt;T, K&gt;</code>，从 T 中挑选出 K。如<code>Pick&lt;&#123;a: 1, b: 2, c: 3&#125;, &#39;a&#39; | &#39;b&#39;</code> 得到<code>&#123;a: 1, b: 2&#125;</code>。（这里类型值写的是 number 类型的数字，TS 会推断出 number 类型）。</p>\n</li>\n<li><p><code>Exclude&lt;T, U&gt;</code>，从类型 T 中排除不在类型 U 中的。如<code>Exclude&lt;&#39;a&#39; | &#39;b&#39;, &#39;b&#39; | &#39;c&#39;&gt;</code> 得到 <code>&#39;a&#39;</code>，如<code>Exclude&lt;&#123;a: 1, b:2&#125;, &#123;a: 1, b:2, c: 3&#125;&gt;</code> 得到 <code>&#123;a: 1, b: 2&#125;</code>【这里可以这么理解：T 属于 U 的一种具体实现则返回 never，不是则返回 T】。自己实现<code>type Exc&lt;T, U&gt; = T extends U ? never: T</code>。</p>\n</li>\n<li><p><code>Extract&lt;T, U&gt;</code>，从类型 T 中提取出可以分配给类型 U 的部分。如<code>Extract&lt;&#39;a&#39; | &#39;b&#39;, &#39;b&#39; | &#39;c&#39;&gt;</code> 得到 <code>&#39;b&#39;</code>，如<code>Extract&lt;&#123;a: 1, b:2&#125;, &#123;a: 1, b:2, c: 3&#125;&gt;</code> 得到 <code>never</code>。【这里可以这么理解：T 属于 U 的一种具体实现，则返回 T，不是则返回 never】。自己实现<code>type Ext&lt;T, U&gt; = T extends U ? T : never</code>。</p>\n</li>\n</ul>\n<h2 id=\"非-React-技术栈的常见的-TS-用法\"><a href=\"#非-React-技术栈的常见的-TS-用法\" class=\"headerlink\" title=\"非 React 技术栈的常见的 TS 用法\"></a>非 React 技术栈的常见的 TS 用法</h2><h3 id=\"类型预测\"><a href=\"#类型预测\" class=\"headerlink\" title=\"类型预测\"></a>类型预测</h3><p><code>is</code>关键字。常用场景，明确一个对象的类型后，会调用该对象的属性或方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.length; <span class=\"comment\">// 如果 str 是 number类型，就会报错。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样写只能在编译阶段，当你传递的参数不是字符串类型而报错提示。</span></span><br><span class=\"line\"><span class=\"comment\">// 如果传入的参数是经过计算或者异步获取，无法保证时，运行时会很大概率报错。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> str === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做好类型判断后编译和运行时都不会报错。但是每次都判断的话，代码变多有点麻烦。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常会封装一个判断函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个判断函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用判断函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(str)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果do函数的入参无法确认类型。我们通常会用any。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: any</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里TS已经忽略了入参类型。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(str)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length; <span class=\"comment\">// 如果无length属性也不会在编译阶段报错，这跟我们使用TS的愿景不一致。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用类型预测 str is string。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">str: any</span>): <span class=\"title\">str</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">val: any</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(isString(val)) &#123; <span class=\"comment\">// 这里在运行时阶段也会判断是否是是string，再决定进入if内的执行代码。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length <span class=\"comment\">// 这里在编译阶段（书写时）会获得string类型对象的所有属性和方法提示。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>str is string 能否改为: boolean，即 isString 返回的是一个布尔值？不能。改成单一的布尔类型后，无法获得期望的 string 类型对象的属性和方法推断。</p>\n</blockquote>\n<h2 id=\"React-常见写法\"><a href=\"#React-常见写法\" class=\"headerlink\" title=\"React 常见写法\"></a>React 常见写法</h2><h3 id=\"函数组件写法\"><a href=\"#函数组件写法\" class=\"headerlink\" title=\"函数组件写法\"></a>函数组件写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FcComp: React.FC&lt;&#123; <span class=\"attr\">prop1</span>: string &#125;&gt; = <span class=\"function\">(<span class=\"params\">&#123; prop1 &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;prop1&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类组件写法\"><a href=\"#类组件写法\" class=\"headerlink\" title=\"类组件写法\"></a>类组件写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface IState &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClsComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, <span class=\"title\">IState</span>&gt; </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认参数写法\"><a href=\"#默认参数写法\" class=\"headerlink\" title=\"默认参数写法\"></a>默认参数写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> IDefaultProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type IDefaultProps = <span class=\"keyword\">typeof</span> DefComp.defaultProps; <span class=\"comment\">// 获取到默认属性的type签名</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, <span class=\"title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> defaultProps = &#123;</span><br><span class=\"line\">    <span class=\"attr\">work</span>: <span class=\"string\">&#x27;docter&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        &#123;this.props.name&#125; is &#123;this.props.work&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其他写法参照项目中<em>defaultProps</em>文件夹</p>\n</blockquote>\n<h3 id=\"通用组件写法\"><a href=\"#通用组件写法\" class=\"headerlink\" title=\"通用组件写法\"></a>通用组件写法</h3><p>这里描述一个最常见的情景，一个列表组件。利用泛型（阅读入门 TS 泛型部分）实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件定义</span></span><br><span class=\"line\">interface IProps&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">lists</span>: T[]</span><br><span class=\"line\">  <span class=\"attr\">renderItem</span>: <span class=\"function\">(<span class=\"params\">item: T</span>) =&gt;</span> React.ReactNode <span class=\"comment\">// 最好都用ReactNode，而不是JSX.Element。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>&lt;<span class=\"title\">T</span>&gt;, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;lists, renderItem&#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>&#123;lists.map(renderItem)&#125;<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用组件。注意：这里List传入了一个类型number，限制了泛型T的类型。</span></span><br><span class=\"line\">&lt;List&lt;number&gt; lists=&#123;[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]&#125; renderItem=&#123;<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>&#125;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高阶组件（HOC）写法\"><a href=\"#高阶组件（HOC）写法\" class=\"headerlink\" title=\"高阶组件（HOC）写法\"></a>高阶组件（HOC）写法</h3><blockquote>\n<p>React 的高阶组件即一个函数，接受一个组件，返回一个新的组件。</p>\n</blockquote>\n<p>这里写一个例子，一个 withState 函数，接收一个没有 count 状态的组件，包装后，返回一个带有 count 状态的组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* withState.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface InjectedProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: number,</span><br><span class=\"line\">  <span class=\"attr\">onIncrement</span>: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> withState = &lt;P extends InjectedProps&gt;(WrappedComp: React.ComponentType&lt;P&gt;) =&gt; &#123;</span><br><span class=\"line\">  // 使用Omit结合keyof，实现排除掉IProp和InjectedProps交集的部分(count, onIncrement)</span><br><span class=\"line\">  type HocProps = Omit&lt;IProp, keyof InjectedProps&gt; &amp; &#123;</span><br><span class=\"line\">    // 这里可以做HOC的Props的扩展。</span><br><span class=\"line\">    initialCount?: number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  type HocState = &#123; readonly count: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123;</span><br><span class=\"line\">    // 组件的名字，方便调试</span><br><span class=\"line\">    static displayName = `withState($&#123;WrappedComp.name&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">    state: HocState = &#123;</span><br><span class=\"line\">      count: Number(this.props.initialCount) || 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleInc = () =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        count: this.state.count + 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      const &#123; ...restProps &#125; = this.props</span><br><span class=\"line\">      const &#123; count &#125; = this.state</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        &lt;WrappedComp</span><br><span class=\"line\">          count=&#123;count&#125;</span><br><span class=\"line\">          onIncrement=&#123;this.handleInc&#125;</span><br><span class=\"line\">          // HOC组件，应该透传与HOC无关的Prop给被包裹的组件。这里的写法是因为TS本身的BUG，如果不断言，则类型报错。</span><br><span class=\"line\">          &#123;...(restProps as IProp)&#125;</span><br><span class=\"line\">        &gt;&lt;/WrappedComp&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* FcCounter.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FcCounter: React.FC&lt;Props&gt; = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; label, count, onIncrement &#125; = props;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleIncrement = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    onIncrement();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        &#123;label&#125;:&#123;count&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleIncrement&#125;</span>&gt;</span>&#123;`Increment`&#125;<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 调用组件 */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; FcCounter &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./FcCounter&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; withState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./withState&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HocCounterWithState = withState(FcCounter)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;HocCounterWithState initialCount=&#123;<span class=\"number\">10</span>&#125; label=<span class=\"string\">&quot;HocCounterWithState&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认-props-的写法\"><a href=\"#默认-props-的写法\" class=\"headerlink\" title=\"默认 props 的写法\"></a>默认 props 的写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类组件写法</span></span><br><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> defaultProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用typeof获取到类组件的默认参数类型</span></span><br><span class=\"line\">type defaultProps = <span class=\"keyword\">typeof</span> DefaultPropsComp.defaultProps;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultPropsComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> defaultProps = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  echoProps = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里也可以获得TS提示</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; age, name &#125; = <span class=\"built_in\">this</span>.props;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is how to set default props of class component<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数组件写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">work</span>: <span class=\"string\">&#x27;doctor&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> defaultPropsType &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type defaultPropsType = <span class=\"keyword\">typeof</span> defaultProps;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DefaultPropsFC</span>(<span class=\"params\">props: IProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里可以获得提示</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; work, age &#125; = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;`The $&#123;work&#125; is $&#123;age&#125;`&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：一定要挂载默认属性，否则调用组件的地方默认值也需要传入</span></span><br><span class=\"line\">DefaultPropsFC.defaultProps = defaultProps;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h3><p>简单理解为可以 100%确定是什么类型，让 TS 按照确定的类型来进行 TS 提示，推断等。</p>\n<p>JSX 中只支持用 <code>as</code> 断言写法。不支持**&lt;&gt;**写法，如<code>var a = &lt;string&gt;b</code>。跟 jsx 冲突，会当成标签。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type UserA = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type UserB = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string,</span><br><span class=\"line\">  <span class=\"attr\">sex</span>: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type IProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: UserA | UserB</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AssertComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里如果不做类型断言，会提示UserA上没有sex属性</span></span><br><span class=\"line\">    <span class=\"comment\">// const user = this.props.user</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> userB = <span class=\"built_in\">this</span>.props.user <span class=\"keyword\">as</span> UserB</span><br><span class=\"line\">    <span class=\"keyword\">const</span> userA = <span class=\"built_in\">this</span>.props.user <span class=\"keyword\">as</span> UserA</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is a user: &#123;userA.age&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is a user: &#123;userB.sex&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Context-写法\"><a href=\"#Context-写法\" class=\"headerlink\" title=\"Context 写法\"></a>Context 写法</h3><p>用 React 官方 DOC 里的更改按钮颜色主题做例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ctx.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> type Theme = React.CSSProperties</span><br><span class=\"line\"></span><br><span class=\"line\">type Themes = &#123;</span><br><span class=\"line\">  <span class=\"attr\">dark</span>: Theme</span><br><span class=\"line\">  <span class=\"attr\">light</span>: Theme</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> themes: Themes = &#123;</span><br><span class=\"line\">  <span class=\"attr\">dark</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">&#x27;black&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">backgroundColor</span>: <span class=\"string\">&#x27;white&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">light</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">backgroundColor</span>: <span class=\"string\">&#x27;black&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里定义Context的签名</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> type ThemeContextProps = &#123; <span class=\"attr\">theme</span>: Theme; toggleTheme?: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">void</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// createContext&lt;T&gt;需要一个类型，把定义好的Context签名传递进去</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ThemeContext = React.createContext&lt;ThemeContextProps&gt;(&#123;</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: themes.light</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* themeButton.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ThemeContext <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./ctx&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// contextType v16.6+支持</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToggleThemeButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;</span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> contextType = ThemeContext</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 后面需要通过this.context访问到上下文，所以定义一个类属性</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里使用!明确告诉TS，该参数一定有。</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里不能使用？，因为context是必选项</span></span><br><span class=\"line\">  context!: React.ContextType&lt;<span class=\"keyword\">typeof</span> ThemeContext&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 前面context必须这么写，这里才能获取TS提示</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; theme, toggleTheme &#125; = <span class=\"built_in\">this</span>.context</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;theme&#125;</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;toggleTheme&#125;</span> &#123;<span class=\"attr\">...this.props</span>&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        button</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* provider组件 */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ThemeContext, &#123; Theme, themes &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./ctx&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ThemeButton <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./themeButton&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThemeProvider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;</span>&#123;&#125;, State&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: State = &#123;</span><br><span class=\"line\">    <span class=\"attr\">theme</span>: themes.light,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggleTheme = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(<span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">      <span class=\"attr\">theme</span>: state.theme === themes.light ? themes.dark : themes.light,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; theme &#125; = <span class=\"built_in\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; toggleTheme &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ThemeContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">theme</span>, <span class=\"attr\">toggleTheme</span> &#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">ThemeButton</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">ThemeContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多类型参数（重载）\"><a href=\"#多类型参数（重载）\" class=\"headerlink\" title=\"多类型参数（重载）\"></a>多类型参数（重载）</h3><p>假设组件接收 2 种类型的 props。可以传<code>&#123;a: string, config?: number&#125;</code>，或者<code>&#123;b: string&#125;</code>。传递 config 时，说明是用的第一种类型 Props，也一定需要传递 a.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义types</span></span><br><span class=\"line\">type CommonProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: React.ReactNode</span><br><span class=\"line\">  <span class=\"attr\">as</span>: <span class=\"string\">&#x27;p&#x27;</span> | <span class=\"string\">&#x27;span&#x27;</span> | <span class=\"string\">&#x27;h1&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type NoTrucateProps = CommonProps &amp; &#123;</span><br><span class=\"line\">  truncate?: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type TrucateProps = CommonProps &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">truncate</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  expanded?: boolean</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个类型判断，运行时可用，这里使用了is技巧。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isTrucateProps = (</span><br><span class=\"line\">  props: TrucateProps | NoTrucateProps</span><br><span class=\"line\">): props is TrucateProps =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!props.truncate</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里是关键，函数重载，约定入参和反参。（并不是具体代码实现）调用组件的地方即可获取正确提示。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Text</span>(<span class=\"params\">props: NoTrucateProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Text</span>(<span class=\"params\">props: TrucateProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">// 这里才是<span class=\"title\">Text</span>函数的真正实现。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Text</span>(<span class=\"params\">props: NoTrucateProps | TrucateProps</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">console</span>.<span class=\"title\">log</span>(<span class=\"params\">props</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">isTrucateProps(props)</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">const</span> </span>&#123; children, <span class=\"attr\">as</span>: Tag, truncate, expanded, ...others &#125; = props</span><br><span class=\"line\">    <span class=\"keyword\">const</span> classNames = truncate ? <span class=\"string\">&#x27;.truncate&#x27;</span> : <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Tag</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;classNames&#125;</span> <span class=\"attr\">aria-expanded</span>=<span class=\"string\">&#123;!!expanded&#125;</span> &#123;<span class=\"attr\">...others</span>&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        &#123;children&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Tag</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; children, <span class=\"attr\">as</span>: Tag, ...others &#125; = props</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Tag</span> &#123;<span class=\"attr\">...others</span>&#125;&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">Tag</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Text.defaultProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">as</span>: <span class=\"string\">&#x27;p&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用地</span></span><br><span class=\"line\"><span class=\"comment\">// 这里传递了expanded，但未传入truncate，会获得提示。^_^</span></span><br><span class=\"line\">&lt;OptionalProps expanded&gt;truncate-able but expanded&lt;/OptionalProps&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"零碎，但频率高的-React-用法\"><a href=\"#零碎，但频率高的-React-用法\" class=\"headerlink\" title=\"零碎，但频率高的 React 用法\"></a>零碎，但频率高的 React 用法</h3><p>包括：<strong>style 样式定义</strong>，<strong>接收 React 节点定义</strong>，<strong>事件函数定义</strong>，<strong>固定可选参数配置</strong>，<strong>类属性定义</strong>，<strong>Ref 定义</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* usefulReactProp.tsx */</span></span><br><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> DefaultProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">descText</span>: string <span class=\"comment\">// 基本的类型</span></span><br><span class=\"line\">  style?: React.CSSProperties <span class=\"comment\">// 可以在调用组件的地方，获得style的完美提示。</span></span><br><span class=\"line\">  additionDom?: React.ReactNode <span class=\"comment\">// 接收任何类型的React节点</span></span><br><span class=\"line\">  renderReactNode?: <span class=\"function\">() =&gt;</span> React.ReactNode <span class=\"comment\">// 接收一个以函数方式返回的React节点</span></span><br><span class=\"line\">  <span class=\"attr\">onChange</span>: React.FormEventHandler&lt;HTMLInputElement&gt; <span class=\"comment\">// 优先推荐这种写法，让TS自己推断。下面的方法定义同样可以。</span></span><br><span class=\"line\">  <span class=\"comment\">// onChange: (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void</span></span><br><span class=\"line\">  buttonSize: <span class=\"string\">&#x27;small&#x27;</span> | <span class=\"string\">&#x27;middle&#x27;</span> | <span class=\"string\">&#x27;big&#x27;</span> <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type DefaultProps = <span class=\"keyword\">typeof</span> UsefulReactProp.defaultProps</span><br><span class=\"line\">interface IState &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UsefulReactProp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, <span class=\"title\">IState</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> defaultProps = &#123;</span><br><span class=\"line\">    <span class=\"attr\">initVal</span>: <span class=\"string\">&#x27;输入内容&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义一个dom引用。使用如下定义方式</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> aDom = React.createRef&lt;HTMLDivElement&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义一个类属性，可以在需要时在赋值使用</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> classProp?: string</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义一个类属性，在定义时即复制</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> classProp2 = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"built_in\">this</span>.props.initVal</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  defaultOnChange = <span class=\"function\">(<span class=\"params\">e: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onChange &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">      <span class=\"attr\">value</span>: e.target.value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.classProp = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onChange, style, additionDom, renderReactNode &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value &#125; = <span class=\"built_in\">this</span>.state</span><br><span class=\"line\">    <span class=\"comment\">// 如下代码提示只有3种上述定义过的值。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> btnSize =</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.props.buttonSize === <span class=\"string\">&#x27;big&#x27;</span></span><br><span class=\"line\">        ? <span class=\"string\">&#x27;100px&#x27;</span></span><br><span class=\"line\">        : <span class=\"built_in\">this</span>.props.buttonSize === <span class=\"string\">&#x27;small&#x27;</span></span><br><span class=\"line\">        ? <span class=\"string\">&#x27;60px&#x27;</span></span><br><span class=\"line\">        : <span class=\"string\">&#x27;80px;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.defaultOnChange&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;desc&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;style&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">          这是个带样式的提醒</span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;additional&quot;</span>&gt;</span>&#123;additionDom&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;by-func-rcnode&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">          &#123;renderReactNode ? renderReactNode() : null&#125;</span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">width:</span> <span class=\"attr\">btnSize</span> &#125;&#125;&gt;</span>按钮尺寸：联合类型提示<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 调用 */</span></span><br><span class=\"line\"><span class=\"comment\">// 如下都可以获取类型提示。</span></span><br><span class=\"line\">&lt;UsefulReactProp</span><br><span class=\"line\">  descText=<span class=\"string\">&quot;一个简单的描述&quot;</span></span><br><span class=\"line\">  onChange=&#123;<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.currentTarget.value);</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">  style=&#123;&#123; <span class=\"attr\">fontSize</span>: <span class=\"number\">14</span>, <span class=\"attr\">fontWeight</span>: <span class=\"string\">&#x27;bold&#x27;</span> &#125;&#125;</span><br><span class=\"line\">  additionDom=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is additional tag<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>&#125;</span><br><span class=\"line\">  renderReactNode=&#123;<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是通过函数返回的ReactNode<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">  buttonSize=<span class=\"string\">&quot;big&quot;</span></span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>TS 的基本知识这里不做过多的介绍，请自己参照入门文档：<a href=\"https://ts.xcatliu.com/introduction/get-typescript\">TS 入门文档</a>。</p>\n</blockquote>\n<p>推荐直接使用<em>create-react-app</em>直接生成支持 ts 的项目，然后进行 TS 代码测试，<code>create-react-app myProject --typescript</code>。或者直接使用 TS 官方提供的<a href=\"http://www.typescriptlang.org/play/?esModuleInterop=true&target=6&jsx=2#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyRyYwYANhAFzIDOYUoA5gNyHGYS0KMAOp6EDXqMQrfAF98+MAE9eKOMgC8yAApwopOOQA8GbAD4gA\">TS 在线测试</a>。</p>\n<h2 id=\"常用-React-内建常用类型\"><a href=\"#常用-React-内建常用类型\" class=\"headerlink\" title=\"常用 React 内建常用类型\"></a>常用 React 内建常用类型</h2><blockquote>\n<p>建议先浏览一遍有印象</p>\n</blockquote>\n<ul>\n<li><p><code>React.FC&lt;Props&gt;</code>，定义函数组件用。</p>\n</li>\n<li><p><code>React.Component&lt;Props, State&gt;</code>，定义类组件用。</p>\n</li>\n<li><p><code>React.ReactNode</code>，用来定义各种 react 节点，比如<code>&lt;div /&gt;</code>, <code>&lt;MyComp /&gt;</code>, <code>this is a just a text</code>, <code>null</code>, <code>0</code>…</p>\n</li>\n<li><p><code>React.CSSProperties</code>，用来定义内联<code>style</code>的。</p>\n</li>\n<li><p><code>React.HTMLProps&lt;HTMLXXXELEMENT&gt;</code>，获取内建 html 元素的属性。</p>\n</li>\n<li></li>\n<li><p><code>React.PropsWithChildren</code>，如果需要显示使用 children，使用该类型创建 props，如：<code>React.PropsWithChildren&lt;&#123;a: string&#125;&gt;</code>。</p>\n</li>\n<li><p><code>React.ReactEventHandler&lt;HTMLXXXELEMENT&gt;</code>，用来描述元素的事件处理函数。可以自行推导出适合的事件函数描述。</p>\n</li>\n<li><p><code>React.ChangeEventHandler&lt;HTMLXXXELEMENT&gt;</code>，最常见的如 input 的 change 事件函数描述，人为的判定类型。区别于上面的，这里的 event 可用 event.target.value，上面的是 event.currentTarget.value。类似还有<code>MouseEventHandler</code>, <code>MouseEventHandler</code>等。</p>\n</li>\n</ul>\n<h2 id=\"常用的-TS-内建工具泛型和关键字\"><a href=\"#常用的-TS-内建工具泛型和关键字\" class=\"headerlink\" title=\"常用的 TS 内建工具泛型和关键字\"></a>常用的 TS 内建工具泛型和关键字</h2><blockquote>\n<p>建议先浏览一遍有印象</p>\n</blockquote>\n<ul>\n<li><p><code>typeof</code>关键字，自动推断出类型。如<code>typeof &#123;a: 1, b: &#39;hello&#39;&#125;</code> 得到 {a: number, b: string}。</p>\n</li>\n<li><p><code>keyof</code>关键字，类似于<code>Object.keys</code>。<code>keyof &#123;a: string, b: string&#125;</code>得到<code>&#39;a&#39; | &#39;b&#39;</code>。</p>\n</li>\n<li><p><code>in</code>关键字，类似于<code>let k in obj</code>，遍历。<code>type Keys = &#39;a&#39; | &#39;b&#39;, type Obj = &#123;[p in Keys]: any&#125;</code>，遍历了 Keys，p 相当于 k，得到的 Obj = {a: any, b: any}。</p>\n</li>\n<li><p><code>Partial&lt;T&gt;</code>，将 T 类型全部变为可选。如<code>Partial&lt;&#123;a: stirng, b: number&#125;&gt;</code> 得到 <code>&#123;a: string | undefined, b: number | undefined&#125;</code>。</p>\n</li>\n<li><p><code>Omit&lt;P, K&gt;</code>，从 P 中排除 K，返回排除后的结果。如<code>Omit&lt;&#123;a: string, b: number&#125;, &#39;a&#39;&gt;</code> 得到 <code>&#123;b: number&#125;</code>。</p>\n</li>\n<li><p><code>Pick&lt;T, K&gt;</code>，从 T 中挑选出 K。如<code>Pick&lt;&#123;a: 1, b: 2, c: 3&#125;, &#39;a&#39; | &#39;b&#39;</code> 得到<code>&#123;a: 1, b: 2&#125;</code>。（这里类型值写的是 number 类型的数字，TS 会推断出 number 类型）。</p>\n</li>\n<li><p><code>Exclude&lt;T, U&gt;</code>，从类型 T 中排除不在类型 U 中的。如<code>Exclude&lt;&#39;a&#39; | &#39;b&#39;, &#39;b&#39; | &#39;c&#39;&gt;</code> 得到 <code>&#39;a&#39;</code>，如<code>Exclude&lt;&#123;a: 1, b:2&#125;, &#123;a: 1, b:2, c: 3&#125;&gt;</code> 得到 <code>&#123;a: 1, b: 2&#125;</code>【这里可以这么理解：T 属于 U 的一种具体实现则返回 never，不是则返回 T】。自己实现<code>type Exc&lt;T, U&gt; = T extends U ? never: T</code>。</p>\n</li>\n<li><p><code>Extract&lt;T, U&gt;</code>，从类型 T 中提取出可以分配给类型 U 的部分。如<code>Extract&lt;&#39;a&#39; | &#39;b&#39;, &#39;b&#39; | &#39;c&#39;&gt;</code> 得到 <code>&#39;b&#39;</code>，如<code>Extract&lt;&#123;a: 1, b:2&#125;, &#123;a: 1, b:2, c: 3&#125;&gt;</code> 得到 <code>never</code>。【这里可以这么理解：T 属于 U 的一种具体实现，则返回 T，不是则返回 never】。自己实现<code>type Ext&lt;T, U&gt; = T extends U ? T : never</code>。</p>\n</li>\n</ul>\n<h2 id=\"非-React-技术栈的常见的-TS-用法\"><a href=\"#非-React-技术栈的常见的-TS-用法\" class=\"headerlink\" title=\"非 React 技术栈的常见的 TS 用法\"></a>非 React 技术栈的常见的 TS 用法</h2><h3 id=\"类型预测\"><a href=\"#类型预测\" class=\"headerlink\" title=\"类型预测\"></a>类型预测</h3><p><code>is</code>关键字。常用场景，明确一个对象的类型后，会调用该对象的属性或方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.length; <span class=\"comment\">// 如果 str 是 number类型，就会报错。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样写只能在编译阶段，当你传递的参数不是字符串类型而报错提示。</span></span><br><span class=\"line\"><span class=\"comment\">// 如果传入的参数是经过计算或者异步获取，无法保证时，运行时会很大概率报错。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> str === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做好类型判断后编译和运行时都不会报错。但是每次都判断的话，代码变多有点麻烦。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常会封装一个判断函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个判断函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用判断函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(str)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果do函数的入参无法确认类型。我们通常会用any。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">str: any</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里TS已经忽略了入参类型。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(str)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length; <span class=\"comment\">// 如果无length属性也不会在编译阶段报错，这跟我们使用TS的愿景不一致。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用类型预测 str is string。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">str: any</span>): <span class=\"title\">str</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do</span>(<span class=\"params\">val: any</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(isString(val)) &#123; <span class=\"comment\">// 这里在运行时阶段也会判断是否是是string，再决定进入if内的执行代码。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.length <span class=\"comment\">// 这里在编译阶段（书写时）会获得string类型对象的所有属性和方法提示。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>str is string 能否改为: boolean，即 isString 返回的是一个布尔值？不能。改成单一的布尔类型后，无法获得期望的 string 类型对象的属性和方法推断。</p>\n</blockquote>\n<h2 id=\"React-常见写法\"><a href=\"#React-常见写法\" class=\"headerlink\" title=\"React 常见写法\"></a>React 常见写法</h2><h3 id=\"函数组件写法\"><a href=\"#函数组件写法\" class=\"headerlink\" title=\"函数组件写法\"></a>函数组件写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FcComp: React.FC&lt;&#123; <span class=\"attr\">prop1</span>: string &#125;&gt; = <span class=\"function\">(<span class=\"params\">&#123; prop1 &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;prop1&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类组件写法\"><a href=\"#类组件写法\" class=\"headerlink\" title=\"类组件写法\"></a>类组件写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface IState &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClsComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, <span class=\"title\">IState</span>&gt; </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认参数写法\"><a href=\"#默认参数写法\" class=\"headerlink\" title=\"默认参数写法\"></a>默认参数写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> IDefaultProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type IDefaultProps = <span class=\"keyword\">typeof</span> DefComp.defaultProps; <span class=\"comment\">// 获取到默认属性的type签名</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, <span class=\"title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> defaultProps = &#123;</span><br><span class=\"line\">    <span class=\"attr\">work</span>: <span class=\"string\">&#x27;docter&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        &#123;this.props.name&#125; is &#123;this.props.work&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其他写法参照项目中<em>defaultProps</em>文件夹</p>\n</blockquote>\n<h3 id=\"通用组件写法\"><a href=\"#通用组件写法\" class=\"headerlink\" title=\"通用组件写法\"></a>通用组件写法</h3><p>这里描述一个最常见的情景，一个列表组件。利用泛型（阅读入门 TS 泛型部分）实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件定义</span></span><br><span class=\"line\">interface IProps&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">lists</span>: T[]</span><br><span class=\"line\">  <span class=\"attr\">renderItem</span>: <span class=\"function\">(<span class=\"params\">item: T</span>) =&gt;</span> React.ReactNode <span class=\"comment\">// 最好都用ReactNode，而不是JSX.Element。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>&lt;<span class=\"title\">T</span>&gt;, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;lists, renderItem&#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>&#123;lists.map(renderItem)&#125;<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用组件。注意：这里List传入了一个类型number，限制了泛型T的类型。</span></span><br><span class=\"line\">&lt;List&lt;number&gt; lists=&#123;[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]&#125; renderItem=&#123;<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>&#125;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高阶组件（HOC）写法\"><a href=\"#高阶组件（HOC）写法\" class=\"headerlink\" title=\"高阶组件（HOC）写法\"></a>高阶组件（HOC）写法</h3><blockquote>\n<p>React 的高阶组件即一个函数，接受一个组件，返回一个新的组件。</p>\n</blockquote>\n<p>这里写一个例子，一个 withState 函数，接收一个没有 count 状态的组件，包装后，返回一个带有 count 状态的组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* withState.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface InjectedProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: number,</span><br><span class=\"line\">  <span class=\"attr\">onIncrement</span>: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> withState = &lt;P extends InjectedProps&gt;(WrappedComp: React.ComponentType&lt;P&gt;) =&gt; &#123;</span><br><span class=\"line\">  // 使用Omit结合keyof，实现排除掉IProp和InjectedProps交集的部分(count, onIncrement)</span><br><span class=\"line\">  type HocProps = Omit&lt;IProp, keyof InjectedProps&gt; &amp; &#123;</span><br><span class=\"line\">    // 这里可以做HOC的Props的扩展。</span><br><span class=\"line\">    initialCount?: number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  type HocState = &#123; readonly count: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123;</span><br><span class=\"line\">    // 组件的名字，方便调试</span><br><span class=\"line\">    static displayName = `withState($&#123;WrappedComp.name&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">    state: HocState = &#123;</span><br><span class=\"line\">      count: Number(this.props.initialCount) || 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleInc = () =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        count: this.state.count + 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      const &#123; ...restProps &#125; = this.props</span><br><span class=\"line\">      const &#123; count &#125; = this.state</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        &lt;WrappedComp</span><br><span class=\"line\">          count=&#123;count&#125;</span><br><span class=\"line\">          onIncrement=&#123;this.handleInc&#125;</span><br><span class=\"line\">          // HOC组件，应该透传与HOC无关的Prop给被包裹的组件。这里的写法是因为TS本身的BUG，如果不断言，则类型报错。</span><br><span class=\"line\">          &#123;...(restProps as IProp)&#125;</span><br><span class=\"line\">        &gt;&lt;/WrappedComp&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* FcCounter.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FcCounter: React.FC&lt;Props&gt; = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; label, count, onIncrement &#125; = props;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleIncrement = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    onIncrement();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        &#123;label&#125;:&#123;count&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleIncrement&#125;</span>&gt;</span>&#123;`Increment`&#125;<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 调用组件 */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; FcCounter &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./FcCounter&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; withState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./withState&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HocCounterWithState = withState(FcCounter)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;HocCounterWithState initialCount=&#123;<span class=\"number\">10</span>&#125; label=<span class=\"string\">&quot;HocCounterWithState&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认-props-的写法\"><a href=\"#默认-props-的写法\" class=\"headerlink\" title=\"默认 props 的写法\"></a>默认 props 的写法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类组件写法</span></span><br><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> defaultProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用typeof获取到类组件的默认参数类型</span></span><br><span class=\"line\">type defaultProps = <span class=\"keyword\">typeof</span> DefaultPropsComp.defaultProps;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultPropsComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> defaultProps = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  echoProps = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里也可以获得TS提示</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; age, name &#125; = <span class=\"built_in\">this</span>.props;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is how to set default props of class component<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数组件写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">work</span>: <span class=\"string\">&#x27;doctor&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> defaultPropsType &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type defaultPropsType = <span class=\"keyword\">typeof</span> defaultProps;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DefaultPropsFC</span>(<span class=\"params\">props: IProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里可以获得提示</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; work, age &#125; = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;`The $&#123;work&#125; is $&#123;age&#125;`&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：一定要挂载默认属性，否则调用组件的地方默认值也需要传入</span></span><br><span class=\"line\">DefaultPropsFC.defaultProps = defaultProps;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h3><p>简单理解为可以 100%确定是什么类型，让 TS 按照确定的类型来进行 TS 提示，推断等。</p>\n<p>JSX 中只支持用 <code>as</code> 断言写法。不支持**&lt;&gt;**写法，如<code>var a = &lt;string&gt;b</code>。跟 jsx 冲突，会当成标签。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type UserA = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type UserB = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string,</span><br><span class=\"line\">  <span class=\"attr\">sex</span>: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type IProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: UserA | UserB</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AssertComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里如果不做类型断言，会提示UserA上没有sex属性</span></span><br><span class=\"line\">    <span class=\"comment\">// const user = this.props.user</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> userB = <span class=\"built_in\">this</span>.props.user <span class=\"keyword\">as</span> UserB</span><br><span class=\"line\">    <span class=\"keyword\">const</span> userA = <span class=\"built_in\">this</span>.props.user <span class=\"keyword\">as</span> UserA</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is a user: &#123;userA.age&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is a user: &#123;userB.sex&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Context-写法\"><a href=\"#Context-写法\" class=\"headerlink\" title=\"Context 写法\"></a>Context 写法</h3><p>用 React 官方 DOC 里的更改按钮颜色主题做例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ctx.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> type Theme = React.CSSProperties</span><br><span class=\"line\"></span><br><span class=\"line\">type Themes = &#123;</span><br><span class=\"line\">  <span class=\"attr\">dark</span>: Theme</span><br><span class=\"line\">  <span class=\"attr\">light</span>: Theme</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> themes: Themes = &#123;</span><br><span class=\"line\">  <span class=\"attr\">dark</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">&#x27;black&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">backgroundColor</span>: <span class=\"string\">&#x27;white&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">light</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">color</span>: <span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">backgroundColor</span>: <span class=\"string\">&#x27;black&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里定义Context的签名</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> type ThemeContextProps = &#123; <span class=\"attr\">theme</span>: Theme; toggleTheme?: <span class=\"function\">() =&gt;</span> <span class=\"keyword\">void</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// createContext&lt;T&gt;需要一个类型，把定义好的Context签名传递进去</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ThemeContext = React.createContext&lt;ThemeContextProps&gt;(&#123;</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: themes.light</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* themeButton.tsx */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ThemeContext <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./ctx&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// contextType v16.6+支持</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToggleThemeButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;</span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> contextType = ThemeContext</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 后面需要通过this.context访问到上下文，所以定义一个类属性</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里使用!明确告诉TS，该参数一定有。</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里不能使用？，因为context是必选项</span></span><br><span class=\"line\">  context!: React.ContextType&lt;<span class=\"keyword\">typeof</span> ThemeContext&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 前面context必须这么写，这里才能获取TS提示</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; theme, toggleTheme &#125; = <span class=\"built_in\">this</span>.context</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;theme&#125;</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;toggleTheme&#125;</span> &#123;<span class=\"attr\">...this.props</span>&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        button</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* provider组件 */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ThemeContext, &#123; Theme, themes &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./ctx&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ThemeButton <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./themeButton&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThemeProvider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;</span>&#123;&#125;, State&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: State = &#123;</span><br><span class=\"line\">    <span class=\"attr\">theme</span>: themes.light,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggleTheme = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(<span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">      <span class=\"attr\">theme</span>: state.theme === themes.light ? themes.dark : themes.light,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; theme &#125; = <span class=\"built_in\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; toggleTheme &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ThemeContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">theme</span>, <span class=\"attr\">toggleTheme</span> &#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">ThemeButton</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">ThemeContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多类型参数（重载）\"><a href=\"#多类型参数（重载）\" class=\"headerlink\" title=\"多类型参数（重载）\"></a>多类型参数（重载）</h3><p>假设组件接收 2 种类型的 props。可以传<code>&#123;a: string, config?: number&#125;</code>，或者<code>&#123;b: string&#125;</code>。传递 config 时，说明是用的第一种类型 Props，也一定需要传递 a.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义types</span></span><br><span class=\"line\">type CommonProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: React.ReactNode</span><br><span class=\"line\">  <span class=\"attr\">as</span>: <span class=\"string\">&#x27;p&#x27;</span> | <span class=\"string\">&#x27;span&#x27;</span> | <span class=\"string\">&#x27;h1&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type NoTrucateProps = CommonProps &amp; &#123;</span><br><span class=\"line\">  truncate?: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type TrucateProps = CommonProps &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">truncate</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  expanded?: boolean</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个类型判断，运行时可用，这里使用了is技巧。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isTrucateProps = (</span><br><span class=\"line\">  props: TrucateProps | NoTrucateProps</span><br><span class=\"line\">): props is TrucateProps =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!props.truncate</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里是关键，函数重载，约定入参和反参。（并不是具体代码实现）调用组件的地方即可获取正确提示。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Text</span>(<span class=\"params\">props: NoTrucateProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Text</span>(<span class=\"params\">props: TrucateProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">// 这里才是<span class=\"title\">Text</span>函数的真正实现。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Text</span>(<span class=\"params\">props: NoTrucateProps | TrucateProps</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">console</span>.<span class=\"title\">log</span>(<span class=\"params\">props</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span> (<span class=\"params\">isTrucateProps(props)</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">const</span> </span>&#123; children, <span class=\"attr\">as</span>: Tag, truncate, expanded, ...others &#125; = props</span><br><span class=\"line\">    <span class=\"keyword\">const</span> classNames = truncate ? <span class=\"string\">&#x27;.truncate&#x27;</span> : <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Tag</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;classNames&#125;</span> <span class=\"attr\">aria-expanded</span>=<span class=\"string\">&#123;!!expanded&#125;</span> &#123;<span class=\"attr\">...others</span>&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        &#123;children&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Tag</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; children, <span class=\"attr\">as</span>: Tag, ...others &#125; = props</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Tag</span> &#123;<span class=\"attr\">...others</span>&#125;&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">Tag</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Text.defaultProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">as</span>: <span class=\"string\">&#x27;p&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用地</span></span><br><span class=\"line\"><span class=\"comment\">// 这里传递了expanded，但未传入truncate，会获得提示。^_^</span></span><br><span class=\"line\">&lt;OptionalProps expanded&gt;truncate-able but expanded&lt;/OptionalProps&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"零碎，但频率高的-React-用法\"><a href=\"#零碎，但频率高的-React-用法\" class=\"headerlink\" title=\"零碎，但频率高的 React 用法\"></a>零碎，但频率高的 React 用法</h3><p>包括：<strong>style 样式定义</strong>，<strong>接收 React 节点定义</strong>，<strong>事件函数定义</strong>，<strong>固定可选参数配置</strong>，<strong>类属性定义</strong>，<strong>Ref 定义</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* usefulReactProp.tsx */</span></span><br><span class=\"line\">interface IProps <span class=\"keyword\">extends</span> DefaultProps &#123;</span><br><span class=\"line\">  <span class=\"attr\">descText</span>: string <span class=\"comment\">// 基本的类型</span></span><br><span class=\"line\">  style?: React.CSSProperties <span class=\"comment\">// 可以在调用组件的地方，获得style的完美提示。</span></span><br><span class=\"line\">  additionDom?: React.ReactNode <span class=\"comment\">// 接收任何类型的React节点</span></span><br><span class=\"line\">  renderReactNode?: <span class=\"function\">() =&gt;</span> React.ReactNode <span class=\"comment\">// 接收一个以函数方式返回的React节点</span></span><br><span class=\"line\">  <span class=\"attr\">onChange</span>: React.FormEventHandler&lt;HTMLInputElement&gt; <span class=\"comment\">// 优先推荐这种写法，让TS自己推断。下面的方法定义同样可以。</span></span><br><span class=\"line\">  <span class=\"comment\">// onChange: (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void</span></span><br><span class=\"line\">  buttonSize: <span class=\"string\">&#x27;small&#x27;</span> | <span class=\"string\">&#x27;middle&#x27;</span> | <span class=\"string\">&#x27;big&#x27;</span> <span class=\"comment\">// 可选参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type DefaultProps = <span class=\"keyword\">typeof</span> UsefulReactProp.defaultProps</span><br><span class=\"line\">interface IState &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UsefulReactProp</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">IProps</span>, <span class=\"title\">IState</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> defaultProps = &#123;</span><br><span class=\"line\">    <span class=\"attr\">initVal</span>: <span class=\"string\">&#x27;输入内容&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义一个dom引用。使用如下定义方式</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> aDom = React.createRef&lt;HTMLDivElement&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义一个类属性，可以在需要时在赋值使用</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> classProp?: string</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义一个类属性，在定义时即复制</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> classProp2 = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"built_in\">this</span>.props.initVal</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  defaultOnChange = <span class=\"function\">(<span class=\"params\">e: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onChange &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">      <span class=\"attr\">value</span>: e.target.value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.classProp = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">    onChange(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onChange, style, additionDom, renderReactNode &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value &#125; = <span class=\"built_in\">this</span>.state</span><br><span class=\"line\">    <span class=\"comment\">// 如下代码提示只有3种上述定义过的值。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> btnSize =</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.props.buttonSize === <span class=\"string\">&#x27;big&#x27;</span></span><br><span class=\"line\">        ? <span class=\"string\">&#x27;100px&#x27;</span></span><br><span class=\"line\">        : <span class=\"built_in\">this</span>.props.buttonSize === <span class=\"string\">&#x27;small&#x27;</span></span><br><span class=\"line\">        ? <span class=\"string\">&#x27;60px&#x27;</span></span><br><span class=\"line\">        : <span class=\"string\">&#x27;80px;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.defaultOnChange&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;desc&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;style&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">          这是个带样式的提醒</span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;additional&quot;</span>&gt;</span>&#123;additionDom&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;by-func-rcnode&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">          &#123;renderReactNode ? renderReactNode() : null&#125;</span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">width:</span> <span class=\"attr\">btnSize</span> &#125;&#125;&gt;</span>按钮尺寸：联合类型提示<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 调用 */</span></span><br><span class=\"line\"><span class=\"comment\">// 如下都可以获取类型提示。</span></span><br><span class=\"line\">&lt;UsefulReactProp</span><br><span class=\"line\">  descText=<span class=\"string\">&quot;一个简单的描述&quot;</span></span><br><span class=\"line\">  onChange=&#123;<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.currentTarget.value);</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">  style=&#123;&#123; <span class=\"attr\">fontSize</span>: <span class=\"number\">14</span>, <span class=\"attr\">fontWeight</span>: <span class=\"string\">&#x27;bold&#x27;</span> &#125;&#125;</span><br><span class=\"line\">  additionDom=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>this is additional tag<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>&#125;</span><br><span class=\"line\">  renderReactNode=&#123;<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是通过函数返回的ReactNode<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">  buttonSize=<span class=\"string\">&quot;big&quot;</span></span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"Vue中原生操作Select","date":"2018-12-29T16:00:00.000Z","_content":"\nVue中鼓励数据驱动，从而避免跟以前一样使用jQuery来操作DOM的方式操作select。业务开发中经常碰到select操作，所以写一篇记录下原生操作select相关的。\n\n## 实际开发遇到的情况\n因为option选项展示给用户看是一个文案，而跟后端约定传值，是对应的code。如果根据selectData的值做一个判断，少的话还行，如果是城市选择，相信大家都有过经验，传递的是城市对应的code，这个时候，如果一个个判断，是不可能的。如下情况：\n\n```html\n<div id=\"app\">\n  <select v-model=\"selectData\">\n    <option v-for=\"item,index in options\" v-text=\"item.t\" :value=\"item.v\"></option>\n  </select>\n</div>\n```\n\n```js\n  let vm = new Vue({\n    data: {\n      selectData: '2',\n      options: [\n        {t: 'one', v: 1},\n        {t: 'two', v: 2},\n        {t: 'three', v: 3},\n      ]\n    }\n  })\n```\n## 获取对应value的思路\n依赖了原生操作dom的方式，先获取到select，然后获取其selectedIndex属性值，该值返回的就是select中选中的那个option的数组下标。\n\n>这里有几个平时经常会弄错的地方。\n\n### 关于v-model的绑定\n应该绑定的是select，而不是循环结构里的option。\n\n### 关于@change事件的绑定\n也是需要绑定在select上，而不是option。\n\n下面看下原生方式获取对应option的text\n```html\n  <select v-model=\"selectData\" @change=\"changeEvent\" ref=\"selectDom\">\n    <option v-for=\"item,index in options\" v-text=\"item.t\" :value=\"item.v\" ref=\"options\"></option>\n  </select>\n```\n```js\n  {\n    methods: {\n      changeEvent() {\n        let selectIndex = this.$refs.selectDom.selectedIndex; // 获取选中的index\n        let selectOptionTxt = this.$refs.options[selectedIndex].textContent;\n        console.log(selectOptionTxt); // 打印出对应的option的text\n      }\n    }\n  }\n  \n```\n还有一种方法可以获取，查看了下***$refs.options***，实际上就是option的dom元素集合。每一个元素（option）有很多属性，其中有一个***selected***属性，选中的opiton，其***selected***属性值为true。所以我们可以遍历下option，查看其***selected***属性，如果是true，则锁定该option。\n```js\n  // 示意代码\n  let selectOption = null;\n  [].forEach.call(document.querySelectorAll('option'), function(item, index){\n    if (item.selected) {\n      selectOption = item; // 确定了选择的option\n    }\n  })\n\n  console.log(selectOption.textContent);\n\n  // 顺提一下获取select最终选择的值。Vue中，通常是v-model绑定了data中的一个属性\n  console.log(document.querySelector('select').value); \n```\n\n# 总结\n因为本人经常碰到此类情况，每次又不能顺利的搞定该问题，不是绑错了v-model，就是其他问题，因此记录该文。\n如果哪位有更好的方案（比如用Vue的方式），不吝赐教啊~\n","source":"_posts/2018/about-select-element.md","raw":"---\ntitle: Vue中原生操作Select\ndate: 2018/12/30\n---\n\nVue中鼓励数据驱动，从而避免跟以前一样使用jQuery来操作DOM的方式操作select。业务开发中经常碰到select操作，所以写一篇记录下原生操作select相关的。\n\n## 实际开发遇到的情况\n因为option选项展示给用户看是一个文案，而跟后端约定传值，是对应的code。如果根据selectData的值做一个判断，少的话还行，如果是城市选择，相信大家都有过经验，传递的是城市对应的code，这个时候，如果一个个判断，是不可能的。如下情况：\n\n```html\n<div id=\"app\">\n  <select v-model=\"selectData\">\n    <option v-for=\"item,index in options\" v-text=\"item.t\" :value=\"item.v\"></option>\n  </select>\n</div>\n```\n\n```js\n  let vm = new Vue({\n    data: {\n      selectData: '2',\n      options: [\n        {t: 'one', v: 1},\n        {t: 'two', v: 2},\n        {t: 'three', v: 3},\n      ]\n    }\n  })\n```\n## 获取对应value的思路\n依赖了原生操作dom的方式，先获取到select，然后获取其selectedIndex属性值，该值返回的就是select中选中的那个option的数组下标。\n\n>这里有几个平时经常会弄错的地方。\n\n### 关于v-model的绑定\n应该绑定的是select，而不是循环结构里的option。\n\n### 关于@change事件的绑定\n也是需要绑定在select上，而不是option。\n\n下面看下原生方式获取对应option的text\n```html\n  <select v-model=\"selectData\" @change=\"changeEvent\" ref=\"selectDom\">\n    <option v-for=\"item,index in options\" v-text=\"item.t\" :value=\"item.v\" ref=\"options\"></option>\n  </select>\n```\n```js\n  {\n    methods: {\n      changeEvent() {\n        let selectIndex = this.$refs.selectDom.selectedIndex; // 获取选中的index\n        let selectOptionTxt = this.$refs.options[selectedIndex].textContent;\n        console.log(selectOptionTxt); // 打印出对应的option的text\n      }\n    }\n  }\n  \n```\n还有一种方法可以获取，查看了下***$refs.options***，实际上就是option的dom元素集合。每一个元素（option）有很多属性，其中有一个***selected***属性，选中的opiton，其***selected***属性值为true。所以我们可以遍历下option，查看其***selected***属性，如果是true，则锁定该option。\n```js\n  // 示意代码\n  let selectOption = null;\n  [].forEach.call(document.querySelectorAll('option'), function(item, index){\n    if (item.selected) {\n      selectOption = item; // 确定了选择的option\n    }\n  })\n\n  console.log(selectOption.textContent);\n\n  // 顺提一下获取select最终选择的值。Vue中，通常是v-model绑定了data中的一个属性\n  console.log(document.querySelector('select').value); \n```\n\n# 总结\n因为本人经常碰到此类情况，每次又不能顺利的搞定该问题，不是绑错了v-model，就是其他问题，因此记录该文。\n如果哪位有更好的方案（比如用Vue的方式），不吝赐教啊~\n","slug":"2018/about-select-element","published":1,"updated":"2021-11-06T07:21:37.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryv00086hufct172bcx","content":"<p>Vue中鼓励数据驱动，从而避免跟以前一样使用jQuery来操作DOM的方式操作select。业务开发中经常碰到select操作，所以写一篇记录下原生操作select相关的。</p>\n<h2 id=\"实际开发遇到的情况\"><a href=\"#实际开发遇到的情况\" class=\"headerlink\" title=\"实际开发遇到的情况\"></a>实际开发遇到的情况</h2><p>因为option选项展示给用户看是一个文案，而跟后端约定传值，是对应的code。如果根据selectData的值做一个判断，少的话还行，如果是城市选择，相信大家都有过经验，传递的是城市对应的code，这个时候，如果一个个判断，是不可能的。如下情况：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;selectData&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item,index in options&quot;</span> <span class=\"attr\">v-text</span>=<span class=\"string\">&quot;item.t&quot;</span> <span class=\"attr\">:value</span>=<span class=\"string\">&quot;item.v&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">selectData</span>: <span class=\"string\">&#x27;2&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">options</span>: [</span><br><span class=\"line\">      &#123;<span class=\"attr\">t</span>: <span class=\"string\">&#x27;one&#x27;</span>, <span class=\"attr\">v</span>: <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">      &#123;<span class=\"attr\">t</span>: <span class=\"string\">&#x27;two&#x27;</span>, <span class=\"attr\">v</span>: <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">      &#123;<span class=\"attr\">t</span>: <span class=\"string\">&#x27;three&#x27;</span>, <span class=\"attr\">v</span>: <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取对应value的思路\"><a href=\"#获取对应value的思路\" class=\"headerlink\" title=\"获取对应value的思路\"></a>获取对应value的思路</h2><p>依赖了原生操作dom的方式，先获取到select，然后获取其selectedIndex属性值，该值返回的就是select中选中的那个option的数组下标。</p>\n<blockquote>\n<p>这里有几个平时经常会弄错的地方。</p>\n</blockquote>\n<h3 id=\"关于v-model的绑定\"><a href=\"#关于v-model的绑定\" class=\"headerlink\" title=\"关于v-model的绑定\"></a>关于v-model的绑定</h3><p>应该绑定的是select，而不是循环结构里的option。</p>\n<h3 id=\"关于-change事件的绑定\"><a href=\"#关于-change事件的绑定\" class=\"headerlink\" title=\"关于@change事件的绑定\"></a>关于@change事件的绑定</h3><p>也是需要绑定在select上，而不是option。</p>\n<p>下面看下原生方式获取对应option的text</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;selectData&quot;</span> @<span class=\"attr\">change</span>=<span class=\"string\">&quot;changeEvent&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;selectDom&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item,index in options&quot;</span> <span class=\"attr\">v-text</span>=<span class=\"string\">&quot;item.t&quot;</span> <span class=\"attr\">:value</span>=<span class=\"string\">&quot;item.v&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;options&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">changeEvent</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> selectIndex = <span class=\"built_in\">this</span>.$refs.selectDom.selectedIndex; <span class=\"comment\">// 获取选中的index</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> selectOptionTxt = <span class=\"built_in\">this</span>.$refs.options[selectedIndex].textContent;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(selectOptionTxt); <span class=\"comment\">// 打印出对应的option的text</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>还有一种方法可以获取，查看了下***$refs.options<em><strong>，实际上就是option的dom元素集合。每一个元素（option）有很多属性，其中有一个</strong></em>selected<em><strong>属性，选中的opiton，其</strong></em>selected<em><strong>属性值为true。所以我们可以遍历下option，查看其</strong></em>selected***属性，如果是true，则锁定该option。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示意代码</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> selectOption = <span class=\"literal\">null</span>;</span><br><span class=\"line\">[].forEach.call(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">&#x27;option&#x27;</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item.selected) &#123;</span><br><span class=\"line\">    selectOption = item; <span class=\"comment\">// 确定了选择的option</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(selectOption.textContent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顺提一下获取select最终选择的值。Vue中，通常是v-model绑定了data中的一个属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;select&#x27;</span>).value); </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>因为本人经常碰到此类情况，每次又不能顺利的搞定该问题，不是绑错了v-model，就是其他问题，因此记录该文。<br>如果哪位有更好的方案（比如用Vue的方式），不吝赐教啊~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vue中鼓励数据驱动，从而避免跟以前一样使用jQuery来操作DOM的方式操作select。业务开发中经常碰到select操作，所以写一篇记录下原生操作select相关的。</p>\n<h2 id=\"实际开发遇到的情况\"><a href=\"#实际开发遇到的情况\" class=\"headerlink\" title=\"实际开发遇到的情况\"></a>实际开发遇到的情况</h2><p>因为option选项展示给用户看是一个文案，而跟后端约定传值，是对应的code。如果根据selectData的值做一个判断，少的话还行，如果是城市选择，相信大家都有过经验，传递的是城市对应的code，这个时候，如果一个个判断，是不可能的。如下情况：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;selectData&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item,index in options&quot;</span> <span class=\"attr\">v-text</span>=<span class=\"string\">&quot;item.t&quot;</span> <span class=\"attr\">:value</span>=<span class=\"string\">&quot;item.v&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">selectData</span>: <span class=\"string\">&#x27;2&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">options</span>: [</span><br><span class=\"line\">      &#123;<span class=\"attr\">t</span>: <span class=\"string\">&#x27;one&#x27;</span>, <span class=\"attr\">v</span>: <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">      &#123;<span class=\"attr\">t</span>: <span class=\"string\">&#x27;two&#x27;</span>, <span class=\"attr\">v</span>: <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">      &#123;<span class=\"attr\">t</span>: <span class=\"string\">&#x27;three&#x27;</span>, <span class=\"attr\">v</span>: <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取对应value的思路\"><a href=\"#获取对应value的思路\" class=\"headerlink\" title=\"获取对应value的思路\"></a>获取对应value的思路</h2><p>依赖了原生操作dom的方式，先获取到select，然后获取其selectedIndex属性值，该值返回的就是select中选中的那个option的数组下标。</p>\n<blockquote>\n<p>这里有几个平时经常会弄错的地方。</p>\n</blockquote>\n<h3 id=\"关于v-model的绑定\"><a href=\"#关于v-model的绑定\" class=\"headerlink\" title=\"关于v-model的绑定\"></a>关于v-model的绑定</h3><p>应该绑定的是select，而不是循环结构里的option。</p>\n<h3 id=\"关于-change事件的绑定\"><a href=\"#关于-change事件的绑定\" class=\"headerlink\" title=\"关于@change事件的绑定\"></a>关于@change事件的绑定</h3><p>也是需要绑定在select上，而不是option。</p>\n<p>下面看下原生方式获取对应option的text</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;selectData&quot;</span> @<span class=\"attr\">change</span>=<span class=\"string\">&quot;changeEvent&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;selectDom&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item,index in options&quot;</span> <span class=\"attr\">v-text</span>=<span class=\"string\">&quot;item.t&quot;</span> <span class=\"attr\">:value</span>=<span class=\"string\">&quot;item.v&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;options&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">changeEvent</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> selectIndex = <span class=\"built_in\">this</span>.$refs.selectDom.selectedIndex; <span class=\"comment\">// 获取选中的index</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> selectOptionTxt = <span class=\"built_in\">this</span>.$refs.options[selectedIndex].textContent;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(selectOptionTxt); <span class=\"comment\">// 打印出对应的option的text</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>还有一种方法可以获取，查看了下***$refs.options<em><strong>，实际上就是option的dom元素集合。每一个元素（option）有很多属性，其中有一个</strong></em>selected<em><strong>属性，选中的opiton，其</strong></em>selected<em><strong>属性值为true。所以我们可以遍历下option，查看其</strong></em>selected***属性，如果是true，则锁定该option。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示意代码</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> selectOption = <span class=\"literal\">null</span>;</span><br><span class=\"line\">[].forEach.call(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">&#x27;option&#x27;</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item.selected) &#123;</span><br><span class=\"line\">    selectOption = item; <span class=\"comment\">// 确定了选择的option</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(selectOption.textContent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顺提一下获取select最终选择的值。Vue中，通常是v-model绑定了data中的一个属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;select&#x27;</span>).value); </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>因为本人经常碰到此类情况，每次又不能顺利的搞定该问题，不是绑错了v-model，就是其他问题，因此记录该文。<br>如果哪位有更好的方案（比如用Vue的方式），不吝赐教啊~</p>\n"},{"title":"webpack 的各种注入插件","date":"2019-12-29T16:00:00.000Z","_content":"\n`webpack.DefinePlugin`  编译阶段，往 JS 注入定义的常量。实际上就是字符串的一个替换而已。所以我们在注入的时候，必须注入的是字符串，而非值本身。例如<br />\n\n```javascript\nplugins: [\n  new webpack.DefinePlugin({\n    BUILD_ENV: 'test',\n    BUILD_ENV: JSON.stringify('test'),\n    // 如果是布尔值\n    IS_TRUE: 'true', // 不是 true哦！\n    IS_TRUE: JSON.stringify(true),\n  }),\n];\n```\n\n<br />`HtmlWebpackPlugin`  插件，众所周知是方便创建一个配置好各种脚本注入的 HTML 文件的，可以自己提供一个 HTML 模板作为基础，然后在上面进行各种注入，插件支持 `EJS` ，所以，我们可以在 HTML 模板里使用 `<%= HELLO %>` 。插件本身支持了 `title`  字段，也就是 HTML 的 `title`  可以进行替换。我们也可以使用自定义的其他字段，在 HTML 模板里也可以使用。<br />\n\n```javascript\nplugins: [\n  new HtmlWebpackPlugin({\n    inject: true, // 注入JS\n    title: '文章标题',\n    // custom key\n    myName: 'Jack',\n    flag: true,\n  }),\n];\n```\n\n```html\n<title><%= title %></title>\n<% if(htmlWebpackPlugin.options.flag) {%>\n<script>\n  console.log('hello');\n</script>\n<% } %> ...\n\n<div><%= myName%></div>\n```\n\n<br />CRA 脚手架提供了自带的 `InterpolateHtmlPlugin` ，提供类似上面的方法注入变量，只不过注入后的变量，这么用， `%PRO_ENV%` <br />\n\n```html\n<% if ('%PRO_ENV%' !== 'pro' || '%NODE_ENV%' !== 'development') {%>\n<script src=\"%PUBLIC_URL%/libs/vconsole/vconsole.min.js\"></script>\n<script>\n  if (window.engine.isAttached) {\n    var vConsole = new VConsole();\n  }\n</script>\n<% } %>\n```\n","source":"_posts/2019/webpack-inject-plugins.md","raw":"---\ntitle: webpack 的各种注入插件\ndate: 2019/12/30\n---\n\n`webpack.DefinePlugin`  编译阶段，往 JS 注入定义的常量。实际上就是字符串的一个替换而已。所以我们在注入的时候，必须注入的是字符串，而非值本身。例如<br />\n\n```javascript\nplugins: [\n  new webpack.DefinePlugin({\n    BUILD_ENV: 'test',\n    BUILD_ENV: JSON.stringify('test'),\n    // 如果是布尔值\n    IS_TRUE: 'true', // 不是 true哦！\n    IS_TRUE: JSON.stringify(true),\n  }),\n];\n```\n\n<br />`HtmlWebpackPlugin`  插件，众所周知是方便创建一个配置好各种脚本注入的 HTML 文件的，可以自己提供一个 HTML 模板作为基础，然后在上面进行各种注入，插件支持 `EJS` ，所以，我们可以在 HTML 模板里使用 `<%= HELLO %>` 。插件本身支持了 `title`  字段，也就是 HTML 的 `title`  可以进行替换。我们也可以使用自定义的其他字段，在 HTML 模板里也可以使用。<br />\n\n```javascript\nplugins: [\n  new HtmlWebpackPlugin({\n    inject: true, // 注入JS\n    title: '文章标题',\n    // custom key\n    myName: 'Jack',\n    flag: true,\n  }),\n];\n```\n\n```html\n<title><%= title %></title>\n<% if(htmlWebpackPlugin.options.flag) {%>\n<script>\n  console.log('hello');\n</script>\n<% } %> ...\n\n<div><%= myName%></div>\n```\n\n<br />CRA 脚手架提供了自带的 `InterpolateHtmlPlugin` ，提供类似上面的方法注入变量，只不过注入后的变量，这么用， `%PRO_ENV%` <br />\n\n```html\n<% if ('%PRO_ENV%' !== 'pro' || '%NODE_ENV%' !== 'development') {%>\n<script src=\"%PUBLIC_URL%/libs/vconsole/vconsole.min.js\"></script>\n<script>\n  if (window.engine.isAttached) {\n    var vConsole = new VConsole();\n  }\n</script>\n<% } %>\n```\n","slug":"2019/webpack-inject-plugins","published":1,"updated":"2021-11-06T07:32:32.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryw00096huf96iohyqx","content":"<p><code>webpack.DefinePlugin</code>  编译阶段，往 JS 注入定义的常量。实际上就是字符串的一个替换而已。所以我们在注入的时候，必须注入的是字符串，而非值本身。例如<br /></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    <span class=\"attr\">BUILD_ENV</span>: <span class=\"string\">&#x27;test&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">BUILD_ENV</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">&#x27;test&#x27;</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 如果是布尔值</span></span><br><span class=\"line\">    <span class=\"attr\">IS_TRUE</span>: <span class=\"string\">&#x27;true&#x27;</span>, <span class=\"comment\">// 不是 true哦！</span></span><br><span class=\"line\">    <span class=\"attr\">IS_TRUE</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>),</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><br /><code>HtmlWebpackPlugin</code>  插件，众所周知是方便创建一个配置好各种脚本注入的 HTML 文件的，可以自己提供一个 HTML 模板作为基础，然后在上面进行各种注入，插件支持 <code>EJS</code> ，所以，我们可以在 HTML 模板里使用 <code>&lt;%= HELLO %&gt;</code> 。插件本身支持了 <code>title</code>  字段，也就是 HTML 的 <code>title</code>  可以进行替换。我们也可以使用自定义的其他字段，在 HTML 模板里也可以使用。<br /></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">    <span class=\"attr\">inject</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 注入JS</span></span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;文章标题&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// custom key</span></span><br><span class=\"line\">    <span class=\"attr\">myName</span>: <span class=\"string\">&#x27;Jack&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">flag</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>&lt;%= title %&gt;<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">&lt;% if(htmlWebpackPlugin.options.flag) &#123;%&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">&lt;% &#125; %&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&lt;%= myName%&gt;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><br />CRA 脚手架提供了自带的 <code>InterpolateHtmlPlugin</code> ，提供类似上面的方法注入变量，只不过注入后的变量，这么用， <code>%PRO_ENV%</code> <br /></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if (&#x27;%PRO_ENV%&#x27; !== &#x27;pro&#x27; || &#x27;%NODE_ENV%&#x27; !== &#x27;development&#x27;) &#123;%&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;%PUBLIC_URL%/libs/vconsole/vconsole.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.engine.isAttached) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> vConsole = <span class=\"keyword\">new</span> VConsole();</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><code>webpack.DefinePlugin</code>  编译阶段，往 JS 注入定义的常量。实际上就是字符串的一个替换而已。所以我们在注入的时候，必须注入的是字符串，而非值本身。例如<br /></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    <span class=\"attr\">BUILD_ENV</span>: <span class=\"string\">&#x27;test&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">BUILD_ENV</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">&#x27;test&#x27;</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 如果是布尔值</span></span><br><span class=\"line\">    <span class=\"attr\">IS_TRUE</span>: <span class=\"string\">&#x27;true&#x27;</span>, <span class=\"comment\">// 不是 true哦！</span></span><br><span class=\"line\">    <span class=\"attr\">IS_TRUE</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>),</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><br /><code>HtmlWebpackPlugin</code>  插件，众所周知是方便创建一个配置好各种脚本注入的 HTML 文件的，可以自己提供一个 HTML 模板作为基础，然后在上面进行各种注入，插件支持 <code>EJS</code> ，所以，我们可以在 HTML 模板里使用 <code>&lt;%= HELLO %&gt;</code> 。插件本身支持了 <code>title</code>  字段，也就是 HTML 的 <code>title</code>  可以进行替换。我们也可以使用自定义的其他字段，在 HTML 模板里也可以使用。<br /></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">    <span class=\"attr\">inject</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 注入JS</span></span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;文章标题&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// custom key</span></span><br><span class=\"line\">    <span class=\"attr\">myName</span>: <span class=\"string\">&#x27;Jack&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">flag</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>&lt;%= title %&gt;<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">&lt;% if(htmlWebpackPlugin.options.flag) &#123;%&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">&lt;% &#125; %&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&lt;%= myName%&gt;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><br />CRA 脚手架提供了自带的 <code>InterpolateHtmlPlugin</code> ，提供类似上面的方法注入变量，只不过注入后的变量，这么用， <code>%PRO_ENV%</code> <br /></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if (&#x27;%PRO_ENV%&#x27; !== &#x27;pro&#x27; || &#x27;%NODE_ENV%&#x27; !== &#x27;development&#x27;) &#123;%&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;%PUBLIC_URL%/libs/vconsole/vconsole.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.engine.isAttached) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> vConsole = <span class=\"keyword\">new</span> VConsole();</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"异步和同步","date":"2018-12-29T16:00:00.000Z","_content":"\n## 同步函数\n>调用即可立即得到结果，不用等待\n\n\n```js\n  function syncFn() {\n    console.log('我是同步，立刻得到结果')\n  }\n```\n\n## 异步函数\n>调用后不能立即得到结果，需要等待一段时间或者是下一轮**tick**(事件循环的一轮叫做一个tick)\n>这里需要注意的是：异步函数的代码通常有2个部分组成，**现在运行的代码**和**将来运行的代码**，异步函数并不是整体都是异步的。\n\n\n### 点击事件\n```js\n  function asyncFn1() {\n    document.querySelector('.oDiv').addEventListener('click', function(){\n      console.log('别惊讶，点击事件也算异步'); // 将来运行的代码\n    })\n  }\n```\n\n\n### 定时器事件\n```js\n  function asyncFn2() {\n    setTimeout(function(){\n      console.log('定时器，绝对的异步函数')  // 将来运行的代码\n    }, 0)\n  }\n```\n\n\n### ajax事件\n```js\n  function asyncFn3() {\n    // 假设引入了jQuery\n    $.ajax({\n      url: 'xxx',\n      type: 'post',\n      dataType: 'json',\n      success: function(){\n        console.log('ajax异步请求') // 将来运行的代码\n      },\n      fail: function(){\n        console.log('wrong')\n      }\n    })\n  }\n```\n\n### Promise\n```js\n  // ES6中新增的Promise\n  function asyncFn4() {\n    return new Promise(function(resolve, reject) {\n      // do something\n      // 将来运行的代码 start ↓\n      if(true){\n        resolve(data);\n      }else {\n        reject(error);\n      }\n      // 将来运行的代码 end ↑\n    })\n  }\n```\n\n同步和异步函数也是事件循环中不可缺少的重要概念，对事件循环的运行机制有很大帮助。所以一定要清楚辨认哪些是异步，哪些是同步。\n","source":"_posts/2018/async-sync.md","raw":"---\ntitle: 异步和同步\ndate: 2018/12/30\n---\n\n## 同步函数\n>调用即可立即得到结果，不用等待\n\n\n```js\n  function syncFn() {\n    console.log('我是同步，立刻得到结果')\n  }\n```\n\n## 异步函数\n>调用后不能立即得到结果，需要等待一段时间或者是下一轮**tick**(事件循环的一轮叫做一个tick)\n>这里需要注意的是：异步函数的代码通常有2个部分组成，**现在运行的代码**和**将来运行的代码**，异步函数并不是整体都是异步的。\n\n\n### 点击事件\n```js\n  function asyncFn1() {\n    document.querySelector('.oDiv').addEventListener('click', function(){\n      console.log('别惊讶，点击事件也算异步'); // 将来运行的代码\n    })\n  }\n```\n\n\n### 定时器事件\n```js\n  function asyncFn2() {\n    setTimeout(function(){\n      console.log('定时器，绝对的异步函数')  // 将来运行的代码\n    }, 0)\n  }\n```\n\n\n### ajax事件\n```js\n  function asyncFn3() {\n    // 假设引入了jQuery\n    $.ajax({\n      url: 'xxx',\n      type: 'post',\n      dataType: 'json',\n      success: function(){\n        console.log('ajax异步请求') // 将来运行的代码\n      },\n      fail: function(){\n        console.log('wrong')\n      }\n    })\n  }\n```\n\n### Promise\n```js\n  // ES6中新增的Promise\n  function asyncFn4() {\n    return new Promise(function(resolve, reject) {\n      // do something\n      // 将来运行的代码 start ↓\n      if(true){\n        resolve(data);\n      }else {\n        reject(error);\n      }\n      // 将来运行的代码 end ↑\n    })\n  }\n```\n\n同步和异步函数也是事件循环中不可缺少的重要概念，对事件循环的运行机制有很大帮助。所以一定要清楚辨认哪些是异步，哪些是同步。\n","slug":"2018/async-sync","published":1,"updated":"2021-11-06T07:21:43.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryx000a6huf8rea68hw","content":"<h2 id=\"同步函数\"><a href=\"#同步函数\" class=\"headerlink\" title=\"同步函数\"></a>同步函数</h2><blockquote>\n<p>调用即可立即得到结果，不用等待</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">syncFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是同步，立刻得到结果&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><blockquote>\n<p>调用后不能立即得到结果，需要等待一段时间或者是下一轮<strong>tick</strong>(事件循环的一轮叫做一个tick)<br>这里需要注意的是：异步函数的代码通常有2个部分组成，<strong>现在运行的代码</strong>和<strong>将来运行的代码</strong>，异步函数并不是整体都是异步的。</p>\n</blockquote>\n<h3 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;.oDiv&#x27;</span>).addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;别惊讶，点击事件也算异步&#x27;</span>); <span class=\"comment\">// 将来运行的代码</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"定时器事件\"><a href=\"#定时器事件\" class=\"headerlink\" title=\"定时器事件\"></a>定时器事件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;定时器，绝对的异步函数&#x27;</span>)  <span class=\"comment\">// 将来运行的代码</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"ajax事件\"><a href=\"#ajax事件\" class=\"headerlink\" title=\"ajax事件\"></a>ajax事件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 假设引入了jQuery</span></span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">&#x27;xxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;post&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dataType</span>: <span class=\"string\">&#x27;json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ajax异步请求&#x27;</span>) <span class=\"comment\">// 将来运行的代码</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;wrong&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6中新增的Promise</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn4</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"comment\">// 将来运行的代码 start ↓</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      reject(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将来运行的代码 end ↑</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步和异步函数也是事件循环中不可缺少的重要概念，对事件循环的运行机制有很大帮助。所以一定要清楚辨认哪些是异步，哪些是同步。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"同步函数\"><a href=\"#同步函数\" class=\"headerlink\" title=\"同步函数\"></a>同步函数</h2><blockquote>\n<p>调用即可立即得到结果，不用等待</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">syncFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是同步，立刻得到结果&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><blockquote>\n<p>调用后不能立即得到结果，需要等待一段时间或者是下一轮<strong>tick</strong>(事件循环的一轮叫做一个tick)<br>这里需要注意的是：异步函数的代码通常有2个部分组成，<strong>现在运行的代码</strong>和<strong>将来运行的代码</strong>，异步函数并不是整体都是异步的。</p>\n</blockquote>\n<h3 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;.oDiv&#x27;</span>).addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;别惊讶，点击事件也算异步&#x27;</span>); <span class=\"comment\">// 将来运行的代码</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"定时器事件\"><a href=\"#定时器事件\" class=\"headerlink\" title=\"定时器事件\"></a>定时器事件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;定时器，绝对的异步函数&#x27;</span>)  <span class=\"comment\">// 将来运行的代码</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"ajax事件\"><a href=\"#ajax事件\" class=\"headerlink\" title=\"ajax事件\"></a>ajax事件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 假设引入了jQuery</span></span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">&#x27;xxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;post&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dataType</span>: <span class=\"string\">&#x27;json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ajax异步请求&#x27;</span>) <span class=\"comment\">// 将来运行的代码</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;wrong&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6中新增的Promise</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFn4</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"comment\">// 将来运行的代码 start ↓</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      reject(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将来运行的代码 end ↑</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步和异步函数也是事件循环中不可缺少的重要概念，对事件循环的运行机制有很大帮助。所以一定要清楚辨认哪些是异步，哪些是同步。</p>\n"},{"title":"事件循环","date":"2018-12-29T16:00:00.000Z","_content":"\n## 为什么会有事件循环Event Loop?\n因为JS是单线程的（执行JS代码的只有1个线程，通常会说主线程）。一个线程，执行过多任务或者任务过复杂，就会出现阻塞，因此有些如ajax耗时函数则交由其他线程处理，一旦有结果则会将为其事件条件满足设置的回调函数加入到任务队列中，EventLoop是一个机制，当当前执行栈清空后，则从任务队列中查询任务，拉出来执行，重复执行该过程。\n\n\n## 图形话EventLoop\n图片摘自掘金作者【奉献】的事件循环文章\n\n![eventloop](/images/eventloop.jpg)\n\n图中有2个新的概念**Macrotask**和**Microtask**\n\n## Macrotask\n通常所说的任务队列，也就是Task。在ES6提出Promise之前，应该只有Task这个队列，后来规范规定清楚了2种队列，Task就成了Macrotask，也叫宏任务队列。满足条件的事件，则进入该队列，如定时器函数（setTimeout, setInterval, setImmediate等），ajax回调函数，UI交互事件（click等）\n\n## Microtask\n微任务队列，也叫Job，粒度比Task小。存放Promise.nextTick，Promise.then()之流的任务。\n\n## 两个队列的优先级和插入执行时机\n微任务处理优先于宏任务处理。只有处理完清空了微任务队列，EventLoop才会从Macrotask取一个宏任务进行处理。微任务会插入到下个Tick之前执行\n\n## 事件循环的一轮怎么界定？\n这个问题困扰我比较久，查了很多资料，从【这波能反杀】作者写的事件循环机制中找到了明显的答案，结合参考了其他多篇事件循环不错的博文，如掘金的【王下邀月熊】和【奉献】2位作者的文章。\n\n**事件循环**的开始：JS全局代码（算宏任务）入栈。\n\n**事件循环**的结束：全局代码执行完，检查Micro是否有微任务，如果有，将微任务队列中函数放入执行栈依次执行完。清空微任务队列。至此第一轮事件循环结束。第二轮，即从下一个Macro任务开始，如此循环。\n图片摘自掘金【王下邀月熊】的事件循环文章\n![micro and macro](/images/micro_and_macro.jpg)\n\n\n## 代码上理解\n> 纯文字解释不容易理解，结合代码\n```js\n  var beginEventFlag = '开始事件循环'; \n  console.log(beginEventFlag);\n\n  setTimeout(() => { // 异步\n    console.log('500s执行')\n  },500)\n\n  var p = new Promise(function(resolve, reject){\n    resolve(5);\n  })\n  p.then(function(r){\n    console.log(r);\n    var p2 = new Promise(function(resolve, reject){\n      resolve('又是5')\n    })\n    p2.then(function(d) {\n      console.log(d)\n    })     \n    setTimeout(() => {\n      console.log('又是500s执行')     \n    },1000)\n  })\n```\nChrome中打印结果为：'开始时间循环'，5，又是5，500s执行，又是500s执行。\n\n结合概念中来分析此段代码：\n1. 全局代码（同步函数，宏任务）入栈，打印‘开始事件循环’。\n2. 遇到setTimeout（第一个），计时交由浏览器对应的定时器线程，并将其回调塞入宏任务队列中。\n2. 执行new Promise代码，立刻决议这个p。并将其p.then放入微任务队列中。\n3. 没有其他同步代码了，检查微任务队列，执行，打印‘5’。遇到p2，立刻决议，将p2.then塞入微任务队列。遇到setTimeout（第二个），塞入宏任务队列。\n4. 继续检查微任务队列，发现刚塞入微任务队列的p2.then，执行，打印‘又是5’。至此微任务队列清空完毕。\n5. 下一轮事件循环开始，宏任务队列中第一个setTimeout的回调执行，打印‘500s执行’。\n6. 检查微任务队列，没有Job需要执行。\n7. 再下一轮事件循环开始，宏任务队列中的第二个setTiemout的回调执行，打印‘又是500s执行’。\n\n## 总结\n本文参考了很多博文，简化不少东西，笔者主要是为了记录并方便自己的理解，如果有问题，欢迎指正。\n","source":"_posts/2018/event-loop.md","raw":"---\ntitle: 事件循环\ndate: 2018/12/30\n---\n\n## 为什么会有事件循环Event Loop?\n因为JS是单线程的（执行JS代码的只有1个线程，通常会说主线程）。一个线程，执行过多任务或者任务过复杂，就会出现阻塞，因此有些如ajax耗时函数则交由其他线程处理，一旦有结果则会将为其事件条件满足设置的回调函数加入到任务队列中，EventLoop是一个机制，当当前执行栈清空后，则从任务队列中查询任务，拉出来执行，重复执行该过程。\n\n\n## 图形话EventLoop\n图片摘自掘金作者【奉献】的事件循环文章\n\n![eventloop](/images/eventloop.jpg)\n\n图中有2个新的概念**Macrotask**和**Microtask**\n\n## Macrotask\n通常所说的任务队列，也就是Task。在ES6提出Promise之前，应该只有Task这个队列，后来规范规定清楚了2种队列，Task就成了Macrotask，也叫宏任务队列。满足条件的事件，则进入该队列，如定时器函数（setTimeout, setInterval, setImmediate等），ajax回调函数，UI交互事件（click等）\n\n## Microtask\n微任务队列，也叫Job，粒度比Task小。存放Promise.nextTick，Promise.then()之流的任务。\n\n## 两个队列的优先级和插入执行时机\n微任务处理优先于宏任务处理。只有处理完清空了微任务队列，EventLoop才会从Macrotask取一个宏任务进行处理。微任务会插入到下个Tick之前执行\n\n## 事件循环的一轮怎么界定？\n这个问题困扰我比较久，查了很多资料，从【这波能反杀】作者写的事件循环机制中找到了明显的答案，结合参考了其他多篇事件循环不错的博文，如掘金的【王下邀月熊】和【奉献】2位作者的文章。\n\n**事件循环**的开始：JS全局代码（算宏任务）入栈。\n\n**事件循环**的结束：全局代码执行完，检查Micro是否有微任务，如果有，将微任务队列中函数放入执行栈依次执行完。清空微任务队列。至此第一轮事件循环结束。第二轮，即从下一个Macro任务开始，如此循环。\n图片摘自掘金【王下邀月熊】的事件循环文章\n![micro and macro](/images/micro_and_macro.jpg)\n\n\n## 代码上理解\n> 纯文字解释不容易理解，结合代码\n```js\n  var beginEventFlag = '开始事件循环'; \n  console.log(beginEventFlag);\n\n  setTimeout(() => { // 异步\n    console.log('500s执行')\n  },500)\n\n  var p = new Promise(function(resolve, reject){\n    resolve(5);\n  })\n  p.then(function(r){\n    console.log(r);\n    var p2 = new Promise(function(resolve, reject){\n      resolve('又是5')\n    })\n    p2.then(function(d) {\n      console.log(d)\n    })     \n    setTimeout(() => {\n      console.log('又是500s执行')     \n    },1000)\n  })\n```\nChrome中打印结果为：'开始时间循环'，5，又是5，500s执行，又是500s执行。\n\n结合概念中来分析此段代码：\n1. 全局代码（同步函数，宏任务）入栈，打印‘开始事件循环’。\n2. 遇到setTimeout（第一个），计时交由浏览器对应的定时器线程，并将其回调塞入宏任务队列中。\n2. 执行new Promise代码，立刻决议这个p。并将其p.then放入微任务队列中。\n3. 没有其他同步代码了，检查微任务队列，执行，打印‘5’。遇到p2，立刻决议，将p2.then塞入微任务队列。遇到setTimeout（第二个），塞入宏任务队列。\n4. 继续检查微任务队列，发现刚塞入微任务队列的p2.then，执行，打印‘又是5’。至此微任务队列清空完毕。\n5. 下一轮事件循环开始，宏任务队列中第一个setTimeout的回调执行，打印‘500s执行’。\n6. 检查微任务队列，没有Job需要执行。\n7. 再下一轮事件循环开始，宏任务队列中的第二个setTiemout的回调执行，打印‘又是500s执行’。\n\n## 总结\n本文参考了很多博文，简化不少东西，笔者主要是为了记录并方便自己的理解，如果有问题，欢迎指正。\n","slug":"2018/event-loop","published":1,"updated":"2021-11-06T07:22:42.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryy000b6huf4k5pdhbe","content":"<h2 id=\"为什么会有事件循环Event-Loop\"><a href=\"#为什么会有事件循环Event-Loop\" class=\"headerlink\" title=\"为什么会有事件循环Event Loop?\"></a>为什么会有事件循环Event Loop?</h2><p>因为JS是单线程的（执行JS代码的只有1个线程，通常会说主线程）。一个线程，执行过多任务或者任务过复杂，就会出现阻塞，因此有些如ajax耗时函数则交由其他线程处理，一旦有结果则会将为其事件条件满足设置的回调函数加入到任务队列中，EventLoop是一个机制，当当前执行栈清空后，则从任务队列中查询任务，拉出来执行，重复执行该过程。</p>\n<h2 id=\"图形话EventLoop\"><a href=\"#图形话EventLoop\" class=\"headerlink\" title=\"图形话EventLoop\"></a>图形话EventLoop</h2><p>图片摘自掘金作者【奉献】的事件循环文章</p>\n<p><img src=\"/images/eventloop.jpg\" alt=\"eventloop\"></p>\n<p>图中有2个新的概念<strong>Macrotask</strong>和<strong>Microtask</strong></p>\n<h2 id=\"Macrotask\"><a href=\"#Macrotask\" class=\"headerlink\" title=\"Macrotask\"></a>Macrotask</h2><p>通常所说的任务队列，也就是Task。在ES6提出Promise之前，应该只有Task这个队列，后来规范规定清楚了2种队列，Task就成了Macrotask，也叫宏任务队列。满足条件的事件，则进入该队列，如定时器函数（setTimeout, setInterval, setImmediate等），ajax回调函数，UI交互事件（click等）</p>\n<h2 id=\"Microtask\"><a href=\"#Microtask\" class=\"headerlink\" title=\"Microtask\"></a>Microtask</h2><p>微任务队列，也叫Job，粒度比Task小。存放Promise.nextTick，Promise.then()之流的任务。</p>\n<h2 id=\"两个队列的优先级和插入执行时机\"><a href=\"#两个队列的优先级和插入执行时机\" class=\"headerlink\" title=\"两个队列的优先级和插入执行时机\"></a>两个队列的优先级和插入执行时机</h2><p>微任务处理优先于宏任务处理。只有处理完清空了微任务队列，EventLoop才会从Macrotask取一个宏任务进行处理。微任务会插入到下个Tick之前执行</p>\n<h2 id=\"事件循环的一轮怎么界定？\"><a href=\"#事件循环的一轮怎么界定？\" class=\"headerlink\" title=\"事件循环的一轮怎么界定？\"></a>事件循环的一轮怎么界定？</h2><p>这个问题困扰我比较久，查了很多资料，从【这波能反杀】作者写的事件循环机制中找到了明显的答案，结合参考了其他多篇事件循环不错的博文，如掘金的【王下邀月熊】和【奉献】2位作者的文章。</p>\n<p><strong>事件循环</strong>的开始：JS全局代码（算宏任务）入栈。</p>\n<p><strong>事件循环</strong>的结束：全局代码执行完，检查Micro是否有微任务，如果有，将微任务队列中函数放入执行栈依次执行完。清空微任务队列。至此第一轮事件循环结束。第二轮，即从下一个Macro任务开始，如此循环。<br>图片摘自掘金【王下邀月熊】的事件循环文章<br><img src=\"/images/micro_and_macro.jpg\" alt=\"micro and macro\"></p>\n<h2 id=\"代码上理解\"><a href=\"#代码上理解\" class=\"headerlink\" title=\"代码上理解\"></a>代码上理解</h2><blockquote>\n<p>纯文字解释不容易理解，结合代码</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> beginEventFlag = <span class=\"string\">&#x27;开始事件循环&#x27;</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(beginEventFlag);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 异步</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;500s执行&#x27;</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">500</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(r);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">&#x27;又是5&#x27;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  p2.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(d)</span><br><span class=\"line\">  &#125;)     </span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;又是500s执行&#x27;</span>)     </span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Chrome中打印结果为：’开始时间循环’，5，又是5，500s执行，又是500s执行。</p>\n<p>结合概念中来分析此段代码：</p>\n<ol>\n<li>全局代码（同步函数，宏任务）入栈，打印‘开始事件循环’。</li>\n<li>遇到setTimeout（第一个），计时交由浏览器对应的定时器线程，并将其回调塞入宏任务队列中。</li>\n<li>执行new Promise代码，立刻决议这个p。并将其p.then放入微任务队列中。</li>\n<li>没有其他同步代码了，检查微任务队列，执行，打印‘5’。遇到p2，立刻决议，将p2.then塞入微任务队列。遇到setTimeout（第二个），塞入宏任务队列。</li>\n<li>继续检查微任务队列，发现刚塞入微任务队列的p2.then，执行，打印‘又是5’。至此微任务队列清空完毕。</li>\n<li>下一轮事件循环开始，宏任务队列中第一个setTimeout的回调执行，打印‘500s执行’。</li>\n<li>检查微任务队列，没有Job需要执行。</li>\n<li>再下一轮事件循环开始，宏任务队列中的第二个setTiemout的回调执行，打印‘又是500s执行’。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文参考了很多博文，简化不少东西，笔者主要是为了记录并方便自己的理解，如果有问题，欢迎指正。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么会有事件循环Event-Loop\"><a href=\"#为什么会有事件循环Event-Loop\" class=\"headerlink\" title=\"为什么会有事件循环Event Loop?\"></a>为什么会有事件循环Event Loop?</h2><p>因为JS是单线程的（执行JS代码的只有1个线程，通常会说主线程）。一个线程，执行过多任务或者任务过复杂，就会出现阻塞，因此有些如ajax耗时函数则交由其他线程处理，一旦有结果则会将为其事件条件满足设置的回调函数加入到任务队列中，EventLoop是一个机制，当当前执行栈清空后，则从任务队列中查询任务，拉出来执行，重复执行该过程。</p>\n<h2 id=\"图形话EventLoop\"><a href=\"#图形话EventLoop\" class=\"headerlink\" title=\"图形话EventLoop\"></a>图形话EventLoop</h2><p>图片摘自掘金作者【奉献】的事件循环文章</p>\n<p><img src=\"/images/eventloop.jpg\" alt=\"eventloop\"></p>\n<p>图中有2个新的概念<strong>Macrotask</strong>和<strong>Microtask</strong></p>\n<h2 id=\"Macrotask\"><a href=\"#Macrotask\" class=\"headerlink\" title=\"Macrotask\"></a>Macrotask</h2><p>通常所说的任务队列，也就是Task。在ES6提出Promise之前，应该只有Task这个队列，后来规范规定清楚了2种队列，Task就成了Macrotask，也叫宏任务队列。满足条件的事件，则进入该队列，如定时器函数（setTimeout, setInterval, setImmediate等），ajax回调函数，UI交互事件（click等）</p>\n<h2 id=\"Microtask\"><a href=\"#Microtask\" class=\"headerlink\" title=\"Microtask\"></a>Microtask</h2><p>微任务队列，也叫Job，粒度比Task小。存放Promise.nextTick，Promise.then()之流的任务。</p>\n<h2 id=\"两个队列的优先级和插入执行时机\"><a href=\"#两个队列的优先级和插入执行时机\" class=\"headerlink\" title=\"两个队列的优先级和插入执行时机\"></a>两个队列的优先级和插入执行时机</h2><p>微任务处理优先于宏任务处理。只有处理完清空了微任务队列，EventLoop才会从Macrotask取一个宏任务进行处理。微任务会插入到下个Tick之前执行</p>\n<h2 id=\"事件循环的一轮怎么界定？\"><a href=\"#事件循环的一轮怎么界定？\" class=\"headerlink\" title=\"事件循环的一轮怎么界定？\"></a>事件循环的一轮怎么界定？</h2><p>这个问题困扰我比较久，查了很多资料，从【这波能反杀】作者写的事件循环机制中找到了明显的答案，结合参考了其他多篇事件循环不错的博文，如掘金的【王下邀月熊】和【奉献】2位作者的文章。</p>\n<p><strong>事件循环</strong>的开始：JS全局代码（算宏任务）入栈。</p>\n<p><strong>事件循环</strong>的结束：全局代码执行完，检查Micro是否有微任务，如果有，将微任务队列中函数放入执行栈依次执行完。清空微任务队列。至此第一轮事件循环结束。第二轮，即从下一个Macro任务开始，如此循环。<br>图片摘自掘金【王下邀月熊】的事件循环文章<br><img src=\"/images/micro_and_macro.jpg\" alt=\"micro and macro\"></p>\n<h2 id=\"代码上理解\"><a href=\"#代码上理解\" class=\"headerlink\" title=\"代码上理解\"></a>代码上理解</h2><blockquote>\n<p>纯文字解释不容易理解，结合代码</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> beginEventFlag = <span class=\"string\">&#x27;开始事件循环&#x27;</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(beginEventFlag);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 异步</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;500s执行&#x27;</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">500</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(r);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">&#x27;又是5&#x27;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  p2.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(d)</span><br><span class=\"line\">  &#125;)     </span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;又是500s执行&#x27;</span>)     </span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Chrome中打印结果为：’开始时间循环’，5，又是5，500s执行，又是500s执行。</p>\n<p>结合概念中来分析此段代码：</p>\n<ol>\n<li>全局代码（同步函数，宏任务）入栈，打印‘开始事件循环’。</li>\n<li>遇到setTimeout（第一个），计时交由浏览器对应的定时器线程，并将其回调塞入宏任务队列中。</li>\n<li>执行new Promise代码，立刻决议这个p。并将其p.then放入微任务队列中。</li>\n<li>没有其他同步代码了，检查微任务队列，执行，打印‘5’。遇到p2，立刻决议，将p2.then塞入微任务队列。遇到setTimeout（第二个），塞入宏任务队列。</li>\n<li>继续检查微任务队列，发现刚塞入微任务队列的p2.then，执行，打印‘又是5’。至此微任务队列清空完毕。</li>\n<li>下一轮事件循环开始，宏任务队列中第一个setTimeout的回调执行，打印‘500s执行’。</li>\n<li>检查微任务队列，没有Job需要执行。</li>\n<li>再下一轮事件循环开始，宏任务队列中的第二个setTiemout的回调执行，打印‘又是500s执行’。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文参考了很多博文，简化不少东西，笔者主要是为了记录并方便自己的理解，如果有问题，欢迎指正。</p>\n"},{"title":"Vue的钩子","date":"2018-12-29T16:00:00.000Z","_content":"\n\n单页面应用通常都会用到vue-router，在一个组件或者页面被展示或销毁时，生命周期钩子和路由守卫协作搭配，能够时刻控制组件和页面在不同阶段触发我们自己的函数。然而，分清楚生命周期和路由守卫各自的使用场景很重要，不能混为一谈。未区分清楚，就容易犯错，如下场景案例，都是我犯错的真实案例。\n\n## 错误案例\n如下实际工作中用错的案例。\n\n### 错用场景1\nA页面(组件)中打开了A-1页面(组件)，然后由A-1页面返回到A页面，在A页面的`activated`钩子中写了函数，期待能够在A-1返回至A时触发，事实是没有触发，因为没有弄清楚`activated`钩子函数的触发场景，这里实际应该用路由守卫来触发。\n\n### 错用场景2\nHome页面中打开A页面，A页面返回Home页面。\nHome页面中打开B页面，B页面返回Home页面。\n以上操作，需要在进入A,B页面时根据页面更改title为A或B，均需要在返回Home页面时，在把title改为home。我在Home，A，B三个组件中写了`beforeRouteEnter`守卫，挂载了修改title的函数。然后只有A，B有效，Home只有在初次进入时有效。没有弄清楚操作行为B->Home，A->Home不属于`beforeRouteEnter`，路由变化是这样的: `/home/A`->`/home`。\n解决方式：Home组件中使用`beforeRouteUpdate`，判断`to.path === '/home'`触发修改title。A,B组件中使用`beforeRouteLeave`判断`to.path === '/home'`触发修改title。或者在`beforeEach`中对路由的各个操作做判断。\n\n## 生命周期钩子\n生命周期钩子是比较常用的，不管是在根实例还是在单文件组件中。都经常会用到。\n\n### 写法注意\n所有钩子函数，自动绑定this（实例本身）。所以不能使用箭头函数，箭头函数绑定的this是父作用域。\n```js\n// 注意，这里是最简单的引用vue.js后，然后直接在全局实例化Vue\n// 因此var vm 等同于window.vm\nvar vm = new Vue({\n  // right\n  created() {\n\n  }\n\n  // 上面写法等同于如下写法\n  created: function() {\n    // this指向Vue实例本身\n  }\n\n\n  // error 这种写法错误\n  created: () => {\n    // 箭头函数绑定的是父作用域，这个例子中this指向window\n    // 因此箭头函数的话this指向并不是你期待的\n  }\n})\n```\n\n### 生命周期函数\n**beforeCreate**：实例初始化之后，实例还没有创建完成，因此访问this的话，是undefined。\n\n**created**：实例创建完成，但是未完成DOM挂载。因此this.$el是访问不到的。这里可以执行watch，methods等方法了。常用来挂载页面数据初始化（不涉及到DOM操作）。\n\n> 涉及到dom挂载，挂载后的重新打补丁渲染，销毁等钩子，都不会在服务端渲染阶段被调用。可以理解，因为服务端只会对页面做一次初始化，按照初始渲染，生成HTML，发送到客户端（浏览器端）。这块猜测如此，后期学习ssr方式后验证。\n\n**beforeMount**：在挂载DOM到之前的一个钩子函数。能访问到this.$el，就是需要挂载的元素DOM（原始模板）。**注意**：$el即挂载的根节点，如`<div id=\"app\"></div>`，如单文件组件`<template><div></div></template>`中的div根节点。如果是单文件的方式，在组建中beforeMount不一定能获取到$el，官方文档在**mounted**钩子函数中有说明。\n\n> 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。\n\n**mounted**：el选项被新创建的$el替换，且$el挂载到实例上之后（即vm.$el），调用该钩子。通常会在该钩子阶段，操作DOM。这里可以访问到ref标记的DOM结构。\n\n**beforeUpdate**：数据发生变化时，在虚拟DOM打补丁之前调用。可以访问数据更新前那个状态下的DOM。\n\n**updated**：数据发生变化且虚拟DOM补丁打完之后。DOM更新成功，可以执行一些依赖DOM的操作。不应该在该钩子重新更改状态，考虑用watch和computed。类似mounted，不保证所有组件都重绘完成。如果需要确认所有组件重绘完成，使用$nextTick。\n\n**beforeDestroy**：实例销毁之前调用。实例销毁，如v-if，vue-router中切换视图等都会触发该钩子。\n\n**destroyed**：实例销毁之后调用，完全销毁，包括子实例也会销毁，同触发该钩子函数。\n\n**activated**：组件相关的钩子，只有keep-alive包裹的组件，重新激活时会触发。通常我们会在`<router-view></router-view>`外套一层`<keep-alive></keep-alive>`，单页面应用，频繁切换视图，减小重新渲染开销。如果使用了keep-alice，会触发`activated`钩子，但是由于组件被缓存在内存中，没有销毁，也没有重新创建，因此从第二次渲染同样组件时不会触发`beforeCreate`,`created`,`beforeMount`,`mounted`等钩子，这点应该很好理解。而`beforeDestroy`,`destroyed`则永远不会被触发。\n\n**deactivated**：组件相关的钩子，只有keep-alive包裹的组件，被停用时触发，类似于destroyed，但是不是真的销毁，而是存到内存放到一边，暂时不用这个组件，keep-alive形式的组件切换会触发该钩子。\n\n## 路由守卫\n分为3种类型守卫：全局型，单个路由独享型，组件内调用型。\n通常回调函数有3个参数to, from, next。to，from均为对象，存放路由跳转目的地的参数和来源地的参数，而next为函数，类似于管道操作，进入到下一个钩子，不执行的话，通常会导致路由中断。\n\n## 全局型\n### beforeEach\n全局前置路由。进入某路由之前触发。\n\n### beforeResolve\n全局解析路由。导航确认之前，同时在所有组件内调用型路由守卫和异步路由组件被解析之后，该解析守卫就会被调用。这里涉及的执行条件需要理解的是，1是`导航确认之前`，导航的确认是指全部的钩子执行完，导航状态就是确认的(confirmed状态)。2是`组件内路由守卫和异步路由组件都被解析`，指的是路由内调用型的3个守卫`beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave`，异步路由组件解析后(懒加载，通过Import()函数或require方式，用到的时候会去加载再解析，没用到就不存在加载解析一说)。简单来说，等组件内调用型守卫执行完了，异步组件也加载完了，才会执行`beforeResolve`。\n\n### afterEach\n全局后置钩子。没有next参数，可以理解，毕竟都已经后置了。在路由操作流程的最后触发。需要注意的是，这个钩子看起来是最后一个执行的钩子没错，但是在组件内调用守卫`beforeRouteEnter`的参数`next`中的回调函数，才是最后执行的，此时实例已创建好，所以可以在回调中访问到vue实例！！！\n\n```js\nvar router = new VueRouter({\n  routes: []\n})\n\nrouter.beforeEach((to, from, next) => {\n  console.log('我是老大，第一个执行')\n  next();\n})\n\nrouter.beforeResolve((to, from, next) => {\n  console.log('我是保姆，大家都加载好，我在加载')\n  next();\n})\n\nrouter.afterEach((to, from, next) => {\n  console.log('我是看起来的最后一名，不过好像有一个哥们比我还靠后，这哥们是beforeRouteEnter的回调参数next')\n  next();\n})\n```\n没有路由地址的情况下，上述3个全局路由会被各自执行一遍！。\n\n## 单个路由独享守卫\n### beforeEnter\n在路由配置里面单独配置的。\n```js\nvar router = new VueRouter({\n  routes: [\n    {\n      path: '/name',\n      componet: Name,\n      beforeEnter: (to, from, next) => {\n        console.log('进入name时调用，在组件内调用的守卫之前')\n        next();\n      }\n    }\n  ]\n})\n```\n\n\n## 组件内调用守卫\n### beforeRouteEnter\n在渲染当前路由组件对应路由被`完全确认(confirm)`前调用。因为此时，组件实例还未被创建。所以拿不到this即组件实例。但可以通过next的回调函数拿到实例\n```js\nexport default {\n  name: 'comp',\n  beforeRouteEnter(to, from, next) => {\n    console.log('进了当前组件且在路由确认前调用')\n    next((vm) => {\n      console.log(vm)\n    })\n  },\n  beforeRouteUpdate(to, from, next) => {\n    console.log('进了当前组件，或在当前组件打开子路由组件父组件仍存在，但内容已经不一样了，需要更新，会调用')\n    // 如 home中打开A组件，/home -> /home/A。 回到home组件，/home/A -> /home\n    next();\n  },\n  beforeRouteLeave(to, from, next) => {\n    console.log('离开当前路由组件对应的路由时调用')\n    next();\n  }\n}\n```\n\n## 导航完整的解析流程\n导航触发，肯定是从一个路由地址跳往另一个。我们这里考虑这种情况`/home/A -> /home/B`，涉及到所有守卫;\n1. 触发A的`beforeRouteLeave`\n2. 触发全局的`beforeEach`\n3. 触发Home组件中的`beforeRouteUpdate`\n4. 触发B的独享路由守卫`beforeEnter`\n5. 解析异步组件\n6. 触发B的组件级守卫`beforeRouteEnter`\n7. 触发全局的`beforeResolve`\n8. 导航确认\n9. 触发全局的`afterEach`\n10. 触发DOM更新\n11. 组件实例创建完成，调用`beforeRouterEnter`中传递给`next`的回调函数，回调函数可传vm，即实例对象。\n","source":"_posts/2018/life-circle-in-vue.md","raw":"---\ntitle: Vue的钩子\ndate: 2018/12/30\n---\n\n\n单页面应用通常都会用到vue-router，在一个组件或者页面被展示或销毁时，生命周期钩子和路由守卫协作搭配，能够时刻控制组件和页面在不同阶段触发我们自己的函数。然而，分清楚生命周期和路由守卫各自的使用场景很重要，不能混为一谈。未区分清楚，就容易犯错，如下场景案例，都是我犯错的真实案例。\n\n## 错误案例\n如下实际工作中用错的案例。\n\n### 错用场景1\nA页面(组件)中打开了A-1页面(组件)，然后由A-1页面返回到A页面，在A页面的`activated`钩子中写了函数，期待能够在A-1返回至A时触发，事实是没有触发，因为没有弄清楚`activated`钩子函数的触发场景，这里实际应该用路由守卫来触发。\n\n### 错用场景2\nHome页面中打开A页面，A页面返回Home页面。\nHome页面中打开B页面，B页面返回Home页面。\n以上操作，需要在进入A,B页面时根据页面更改title为A或B，均需要在返回Home页面时，在把title改为home。我在Home，A，B三个组件中写了`beforeRouteEnter`守卫，挂载了修改title的函数。然后只有A，B有效，Home只有在初次进入时有效。没有弄清楚操作行为B->Home，A->Home不属于`beforeRouteEnter`，路由变化是这样的: `/home/A`->`/home`。\n解决方式：Home组件中使用`beforeRouteUpdate`，判断`to.path === '/home'`触发修改title。A,B组件中使用`beforeRouteLeave`判断`to.path === '/home'`触发修改title。或者在`beforeEach`中对路由的各个操作做判断。\n\n## 生命周期钩子\n生命周期钩子是比较常用的，不管是在根实例还是在单文件组件中。都经常会用到。\n\n### 写法注意\n所有钩子函数，自动绑定this（实例本身）。所以不能使用箭头函数，箭头函数绑定的this是父作用域。\n```js\n// 注意，这里是最简单的引用vue.js后，然后直接在全局实例化Vue\n// 因此var vm 等同于window.vm\nvar vm = new Vue({\n  // right\n  created() {\n\n  }\n\n  // 上面写法等同于如下写法\n  created: function() {\n    // this指向Vue实例本身\n  }\n\n\n  // error 这种写法错误\n  created: () => {\n    // 箭头函数绑定的是父作用域，这个例子中this指向window\n    // 因此箭头函数的话this指向并不是你期待的\n  }\n})\n```\n\n### 生命周期函数\n**beforeCreate**：实例初始化之后，实例还没有创建完成，因此访问this的话，是undefined。\n\n**created**：实例创建完成，但是未完成DOM挂载。因此this.$el是访问不到的。这里可以执行watch，methods等方法了。常用来挂载页面数据初始化（不涉及到DOM操作）。\n\n> 涉及到dom挂载，挂载后的重新打补丁渲染，销毁等钩子，都不会在服务端渲染阶段被调用。可以理解，因为服务端只会对页面做一次初始化，按照初始渲染，生成HTML，发送到客户端（浏览器端）。这块猜测如此，后期学习ssr方式后验证。\n\n**beforeMount**：在挂载DOM到之前的一个钩子函数。能访问到this.$el，就是需要挂载的元素DOM（原始模板）。**注意**：$el即挂载的根节点，如`<div id=\"app\"></div>`，如单文件组件`<template><div></div></template>`中的div根节点。如果是单文件的方式，在组建中beforeMount不一定能获取到$el，官方文档在**mounted**钩子函数中有说明。\n\n> 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。\n\n**mounted**：el选项被新创建的$el替换，且$el挂载到实例上之后（即vm.$el），调用该钩子。通常会在该钩子阶段，操作DOM。这里可以访问到ref标记的DOM结构。\n\n**beforeUpdate**：数据发生变化时，在虚拟DOM打补丁之前调用。可以访问数据更新前那个状态下的DOM。\n\n**updated**：数据发生变化且虚拟DOM补丁打完之后。DOM更新成功，可以执行一些依赖DOM的操作。不应该在该钩子重新更改状态，考虑用watch和computed。类似mounted，不保证所有组件都重绘完成。如果需要确认所有组件重绘完成，使用$nextTick。\n\n**beforeDestroy**：实例销毁之前调用。实例销毁，如v-if，vue-router中切换视图等都会触发该钩子。\n\n**destroyed**：实例销毁之后调用，完全销毁，包括子实例也会销毁，同触发该钩子函数。\n\n**activated**：组件相关的钩子，只有keep-alive包裹的组件，重新激活时会触发。通常我们会在`<router-view></router-view>`外套一层`<keep-alive></keep-alive>`，单页面应用，频繁切换视图，减小重新渲染开销。如果使用了keep-alice，会触发`activated`钩子，但是由于组件被缓存在内存中，没有销毁，也没有重新创建，因此从第二次渲染同样组件时不会触发`beforeCreate`,`created`,`beforeMount`,`mounted`等钩子，这点应该很好理解。而`beforeDestroy`,`destroyed`则永远不会被触发。\n\n**deactivated**：组件相关的钩子，只有keep-alive包裹的组件，被停用时触发，类似于destroyed，但是不是真的销毁，而是存到内存放到一边，暂时不用这个组件，keep-alive形式的组件切换会触发该钩子。\n\n## 路由守卫\n分为3种类型守卫：全局型，单个路由独享型，组件内调用型。\n通常回调函数有3个参数to, from, next。to，from均为对象，存放路由跳转目的地的参数和来源地的参数，而next为函数，类似于管道操作，进入到下一个钩子，不执行的话，通常会导致路由中断。\n\n## 全局型\n### beforeEach\n全局前置路由。进入某路由之前触发。\n\n### beforeResolve\n全局解析路由。导航确认之前，同时在所有组件内调用型路由守卫和异步路由组件被解析之后，该解析守卫就会被调用。这里涉及的执行条件需要理解的是，1是`导航确认之前`，导航的确认是指全部的钩子执行完，导航状态就是确认的(confirmed状态)。2是`组件内路由守卫和异步路由组件都被解析`，指的是路由内调用型的3个守卫`beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave`，异步路由组件解析后(懒加载，通过Import()函数或require方式，用到的时候会去加载再解析，没用到就不存在加载解析一说)。简单来说，等组件内调用型守卫执行完了，异步组件也加载完了，才会执行`beforeResolve`。\n\n### afterEach\n全局后置钩子。没有next参数，可以理解，毕竟都已经后置了。在路由操作流程的最后触发。需要注意的是，这个钩子看起来是最后一个执行的钩子没错，但是在组件内调用守卫`beforeRouteEnter`的参数`next`中的回调函数，才是最后执行的，此时实例已创建好，所以可以在回调中访问到vue实例！！！\n\n```js\nvar router = new VueRouter({\n  routes: []\n})\n\nrouter.beforeEach((to, from, next) => {\n  console.log('我是老大，第一个执行')\n  next();\n})\n\nrouter.beforeResolve((to, from, next) => {\n  console.log('我是保姆，大家都加载好，我在加载')\n  next();\n})\n\nrouter.afterEach((to, from, next) => {\n  console.log('我是看起来的最后一名，不过好像有一个哥们比我还靠后，这哥们是beforeRouteEnter的回调参数next')\n  next();\n})\n```\n没有路由地址的情况下，上述3个全局路由会被各自执行一遍！。\n\n## 单个路由独享守卫\n### beforeEnter\n在路由配置里面单独配置的。\n```js\nvar router = new VueRouter({\n  routes: [\n    {\n      path: '/name',\n      componet: Name,\n      beforeEnter: (to, from, next) => {\n        console.log('进入name时调用，在组件内调用的守卫之前')\n        next();\n      }\n    }\n  ]\n})\n```\n\n\n## 组件内调用守卫\n### beforeRouteEnter\n在渲染当前路由组件对应路由被`完全确认(confirm)`前调用。因为此时，组件实例还未被创建。所以拿不到this即组件实例。但可以通过next的回调函数拿到实例\n```js\nexport default {\n  name: 'comp',\n  beforeRouteEnter(to, from, next) => {\n    console.log('进了当前组件且在路由确认前调用')\n    next((vm) => {\n      console.log(vm)\n    })\n  },\n  beforeRouteUpdate(to, from, next) => {\n    console.log('进了当前组件，或在当前组件打开子路由组件父组件仍存在，但内容已经不一样了，需要更新，会调用')\n    // 如 home中打开A组件，/home -> /home/A。 回到home组件，/home/A -> /home\n    next();\n  },\n  beforeRouteLeave(to, from, next) => {\n    console.log('离开当前路由组件对应的路由时调用')\n    next();\n  }\n}\n```\n\n## 导航完整的解析流程\n导航触发，肯定是从一个路由地址跳往另一个。我们这里考虑这种情况`/home/A -> /home/B`，涉及到所有守卫;\n1. 触发A的`beforeRouteLeave`\n2. 触发全局的`beforeEach`\n3. 触发Home组件中的`beforeRouteUpdate`\n4. 触发B的独享路由守卫`beforeEnter`\n5. 解析异步组件\n6. 触发B的组件级守卫`beforeRouteEnter`\n7. 触发全局的`beforeResolve`\n8. 导航确认\n9. 触发全局的`afterEach`\n10. 触发DOM更新\n11. 组件实例创建完成，调用`beforeRouterEnter`中传递给`next`的回调函数，回调函数可传vm，即实例对象。\n","slug":"2018/life-circle-in-vue","published":1,"updated":"2021-11-06T07:21:56.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryy000c6huf8kfnhytf","content":"<p>单页面应用通常都会用到vue-router，在一个组件或者页面被展示或销毁时，生命周期钩子和路由守卫协作搭配，能够时刻控制组件和页面在不同阶段触发我们自己的函数。然而，分清楚生命周期和路由守卫各自的使用场景很重要，不能混为一谈。未区分清楚，就容易犯错，如下场景案例，都是我犯错的真实案例。</p>\n<h2 id=\"错误案例\"><a href=\"#错误案例\" class=\"headerlink\" title=\"错误案例\"></a>错误案例</h2><p>如下实际工作中用错的案例。</p>\n<h3 id=\"错用场景1\"><a href=\"#错用场景1\" class=\"headerlink\" title=\"错用场景1\"></a>错用场景1</h3><p>A页面(组件)中打开了A-1页面(组件)，然后由A-1页面返回到A页面，在A页面的<code>activated</code>钩子中写了函数，期待能够在A-1返回至A时触发，事实是没有触发，因为没有弄清楚<code>activated</code>钩子函数的触发场景，这里实际应该用路由守卫来触发。</p>\n<h3 id=\"错用场景2\"><a href=\"#错用场景2\" class=\"headerlink\" title=\"错用场景2\"></a>错用场景2</h3><p>Home页面中打开A页面，A页面返回Home页面。<br>Home页面中打开B页面，B页面返回Home页面。<br>以上操作，需要在进入A,B页面时根据页面更改title为A或B，均需要在返回Home页面时，在把title改为home。我在Home，A，B三个组件中写了<code>beforeRouteEnter</code>守卫，挂载了修改title的函数。然后只有A，B有效，Home只有在初次进入时有效。没有弄清楚操作行为B-&gt;Home，A-&gt;Home不属于<code>beforeRouteEnter</code>，路由变化是这样的: <code>/home/A</code>-&gt;<code>/home</code>。<br>解决方式：Home组件中使用<code>beforeRouteUpdate</code>，判断<code>to.path === &#39;/home&#39;</code>触发修改title。A,B组件中使用<code>beforeRouteLeave</code>判断<code>to.path === &#39;/home&#39;</code>触发修改title。或者在<code>beforeEach</code>中对路由的各个操作做判断。</p>\n<h2 id=\"生命周期钩子\"><a href=\"#生命周期钩子\" class=\"headerlink\" title=\"生命周期钩子\"></a>生命周期钩子</h2><p>生命周期钩子是比较常用的，不管是在根实例还是在单文件组件中。都经常会用到。</p>\n<h3 id=\"写法注意\"><a href=\"#写法注意\" class=\"headerlink\" title=\"写法注意\"></a>写法注意</h3><p>所有钩子函数，自动绑定this（实例本身）。所以不能使用箭头函数，箭头函数绑定的this是父作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意，这里是最简单的引用vue.js后，然后直接在全局实例化Vue</span></span><br><span class=\"line\"><span class=\"comment\">// 因此var vm 等同于window.vm</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// right</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">created</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 上面写法等同于如下写法</span></span><br><span class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this指向Vue实例本身</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// error 这种写法错误</span></span><br><span class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数绑定的是父作用域，这个例子中this指向window</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此箭头函数的话this指向并不是你期待的</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生命周期函数\"><a href=\"#生命周期函数\" class=\"headerlink\" title=\"生命周期函数\"></a>生命周期函数</h3><p><strong>beforeCreate</strong>：实例初始化之后，实例还没有创建完成，因此访问this的话，是undefined。</p>\n<p><strong>created</strong>：实例创建完成，但是未完成DOM挂载。因此this.$el是访问不到的。这里可以执行watch，methods等方法了。常用来挂载页面数据初始化（不涉及到DOM操作）。</p>\n<blockquote>\n<p>涉及到dom挂载，挂载后的重新打补丁渲染，销毁等钩子，都不会在服务端渲染阶段被调用。可以理解，因为服务端只会对页面做一次初始化，按照初始渲染，生成HTML，发送到客户端（浏览器端）。这块猜测如此，后期学习ssr方式后验证。</p>\n</blockquote>\n<p><strong>beforeMount</strong>：在挂载DOM到之前的一个钩子函数。能访问到this.$el，就是需要挂载的元素DOM（原始模板）。<strong>注意</strong>：$el即挂载的根节点，如<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，如单文件组件<code>&lt;template&gt;&lt;div&gt;&lt;/div&gt;&lt;/template&gt;</code>中的div根节点。如果是单文件的方式，在组建中beforeMount不一定能获取到$el，官方文档在<strong>mounted</strong>钩子函数中有说明。</p>\n<blockquote>\n<p>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。</p>\n</blockquote>\n<p><strong>mounted</strong>：el选项被新创建的$el替换，且$el挂载到实例上之后（即vm.$el），调用该钩子。通常会在该钩子阶段，操作DOM。这里可以访问到ref标记的DOM结构。</p>\n<p><strong>beforeUpdate</strong>：数据发生变化时，在虚拟DOM打补丁之前调用。可以访问数据更新前那个状态下的DOM。</p>\n<p><strong>updated</strong>：数据发生变化且虚拟DOM补丁打完之后。DOM更新成功，可以执行一些依赖DOM的操作。不应该在该钩子重新更改状态，考虑用watch和computed。类似mounted，不保证所有组件都重绘完成。如果需要确认所有组件重绘完成，使用$nextTick。</p>\n<p><strong>beforeDestroy</strong>：实例销毁之前调用。实例销毁，如v-if，vue-router中切换视图等都会触发该钩子。</p>\n<p><strong>destroyed</strong>：实例销毁之后调用，完全销毁，包括子实例也会销毁，同触发该钩子函数。</p>\n<p><strong>activated</strong>：组件相关的钩子，只有keep-alive包裹的组件，重新激活时会触发。通常我们会在<code>&lt;router-view&gt;&lt;/router-view&gt;</code>外套一层<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>，单页面应用，频繁切换视图，减小重新渲染开销。如果使用了keep-alice，会触发<code>activated</code>钩子，但是由于组件被缓存在内存中，没有销毁，也没有重新创建，因此从第二次渲染同样组件时不会触发<code>beforeCreate</code>,<code>created</code>,<code>beforeMount</code>,<code>mounted</code>等钩子，这点应该很好理解。而<code>beforeDestroy</code>,<code>destroyed</code>则永远不会被触发。</p>\n<p><strong>deactivated</strong>：组件相关的钩子，只有keep-alive包裹的组件，被停用时触发，类似于destroyed，但是不是真的销毁，而是存到内存放到一边，暂时不用这个组件，keep-alive形式的组件切换会触发该钩子。</p>\n<h2 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h2><p>分为3种类型守卫：全局型，单个路由独享型，组件内调用型。<br>通常回调函数有3个参数to, from, next。to，from均为对象，存放路由跳转目的地的参数和来源地的参数，而next为函数，类似于管道操作，进入到下一个钩子，不执行的话，通常会导致路由中断。</p>\n<h2 id=\"全局型\"><a href=\"#全局型\" class=\"headerlink\" title=\"全局型\"></a>全局型</h2><h3 id=\"beforeEach\"><a href=\"#beforeEach\" class=\"headerlink\" title=\"beforeEach\"></a>beforeEach</h3><p>全局前置路由。进入某路由之前触发。</p>\n<h3 id=\"beforeResolve\"><a href=\"#beforeResolve\" class=\"headerlink\" title=\"beforeResolve\"></a>beforeResolve</h3><p>全局解析路由。导航确认之前，同时在所有组件内调用型路由守卫和异步路由组件被解析之后，该解析守卫就会被调用。这里涉及的执行条件需要理解的是，1是<code>导航确认之前</code>，导航的确认是指全部的钩子执行完，导航状态就是确认的(confirmed状态)。2是<code>组件内路由守卫和异步路由组件都被解析</code>，指的是路由内调用型的3个守卫<code>beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave</code>，异步路由组件解析后(懒加载，通过Import()函数或require方式，用到的时候会去加载再解析，没用到就不存在加载解析一说)。简单来说，等组件内调用型守卫执行完了，异步组件也加载完了，才会执行<code>beforeResolve</code>。</p>\n<h3 id=\"afterEach\"><a href=\"#afterEach\" class=\"headerlink\" title=\"afterEach\"></a>afterEach</h3><p>全局后置钩子。没有next参数，可以理解，毕竟都已经后置了。在路由操作流程的最后触发。需要注意的是，这个钩子看起来是最后一个执行的钩子没错，但是在组件内调用守卫<code>beforeRouteEnter</code>的参数<code>next</code>中的回调函数，才是最后执行的，此时实例已创建好，所以可以在回调中访问到vue实例！！！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: []</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是老大，第一个执行&#x27;</span>)</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeResolve(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是保姆，大家都加载好，我在加载&#x27;</span>)</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是看起来的最后一名，不过好像有一个哥们比我还靠后，这哥们是beforeRouteEnter的回调参数next&#x27;</span>)</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>没有路由地址的情况下，上述3个全局路由会被各自执行一遍！。</p>\n<h2 id=\"单个路由独享守卫\"><a href=\"#单个路由独享守卫\" class=\"headerlink\" title=\"单个路由独享守卫\"></a>单个路由独享守卫</h2><h3 id=\"beforeEnter\"><a href=\"#beforeEnter\" class=\"headerlink\" title=\"beforeEnter\"></a>beforeEnter</h3><p>在路由配置里面单独配置的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/name&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">componet</span>: Name,</span><br><span class=\"line\">      <span class=\"attr\">beforeEnter</span>: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;进入name时调用，在组件内调用的守卫之前&#x27;</span>)</span><br><span class=\"line\">        next();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"组件内调用守卫\"><a href=\"#组件内调用守卫\" class=\"headerlink\" title=\"组件内调用守卫\"></a>组件内调用守卫</h2><h3 id=\"beforeRouteEnter\"><a href=\"#beforeRouteEnter\" class=\"headerlink\" title=\"beforeRouteEnter\"></a>beforeRouteEnter</h3><p>在渲染当前路由组件对应路由被<code>完全确认(confirm)</code>前调用。因为此时，组件实例还未被创建。所以拿不到this即组件实例。但可以通过next的回调函数拿到实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;comp&#x27;</span>,</span><br><span class=\"line\">  beforeRouteEnter(to, <span class=\"keyword\">from</span>, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;进了当前组件且在路由确认前调用&#x27;</span>)</span><br><span class=\"line\">    next(<span class=\"function\">(<span class=\"params\">vm</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(vm)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteUpdate(to, <span class=\"keyword\">from</span>, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;进了当前组件，或在当前组件打开子路由组件父组件仍存在，但内容已经不一样了，需要更新，会调用&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 如 home中打开A组件，/home -&gt; /home/A。 回到home组件，/home/A -&gt; /home</span></span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteLeave(to, <span class=\"keyword\">from</span>, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;离开当前路由组件对应的路由时调用&#x27;</span>)</span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"导航完整的解析流程\"><a href=\"#导航完整的解析流程\" class=\"headerlink\" title=\"导航完整的解析流程\"></a>导航完整的解析流程</h2><p>导航触发，肯定是从一个路由地址跳往另一个。我们这里考虑这种情况<code>/home/A -&gt; /home/B</code>，涉及到所有守卫;</p>\n<ol>\n<li>触发A的<code>beforeRouteLeave</code></li>\n<li>触发全局的<code>beforeEach</code></li>\n<li>触发Home组件中的<code>beforeRouteUpdate</code></li>\n<li>触发B的独享路由守卫<code>beforeEnter</code></li>\n<li>解析异步组件</li>\n<li>触发B的组件级守卫<code>beforeRouteEnter</code></li>\n<li>触发全局的<code>beforeResolve</code></li>\n<li>导航确认</li>\n<li>触发全局的<code>afterEach</code></li>\n<li>触发DOM更新</li>\n<li>组件实例创建完成，调用<code>beforeRouterEnter</code>中传递给<code>next</code>的回调函数，回调函数可传vm，即实例对象。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>单页面应用通常都会用到vue-router，在一个组件或者页面被展示或销毁时，生命周期钩子和路由守卫协作搭配，能够时刻控制组件和页面在不同阶段触发我们自己的函数。然而，分清楚生命周期和路由守卫各自的使用场景很重要，不能混为一谈。未区分清楚，就容易犯错，如下场景案例，都是我犯错的真实案例。</p>\n<h2 id=\"错误案例\"><a href=\"#错误案例\" class=\"headerlink\" title=\"错误案例\"></a>错误案例</h2><p>如下实际工作中用错的案例。</p>\n<h3 id=\"错用场景1\"><a href=\"#错用场景1\" class=\"headerlink\" title=\"错用场景1\"></a>错用场景1</h3><p>A页面(组件)中打开了A-1页面(组件)，然后由A-1页面返回到A页面，在A页面的<code>activated</code>钩子中写了函数，期待能够在A-1返回至A时触发，事实是没有触发，因为没有弄清楚<code>activated</code>钩子函数的触发场景，这里实际应该用路由守卫来触发。</p>\n<h3 id=\"错用场景2\"><a href=\"#错用场景2\" class=\"headerlink\" title=\"错用场景2\"></a>错用场景2</h3><p>Home页面中打开A页面，A页面返回Home页面。<br>Home页面中打开B页面，B页面返回Home页面。<br>以上操作，需要在进入A,B页面时根据页面更改title为A或B，均需要在返回Home页面时，在把title改为home。我在Home，A，B三个组件中写了<code>beforeRouteEnter</code>守卫，挂载了修改title的函数。然后只有A，B有效，Home只有在初次进入时有效。没有弄清楚操作行为B-&gt;Home，A-&gt;Home不属于<code>beforeRouteEnter</code>，路由变化是这样的: <code>/home/A</code>-&gt;<code>/home</code>。<br>解决方式：Home组件中使用<code>beforeRouteUpdate</code>，判断<code>to.path === &#39;/home&#39;</code>触发修改title。A,B组件中使用<code>beforeRouteLeave</code>判断<code>to.path === &#39;/home&#39;</code>触发修改title。或者在<code>beforeEach</code>中对路由的各个操作做判断。</p>\n<h2 id=\"生命周期钩子\"><a href=\"#生命周期钩子\" class=\"headerlink\" title=\"生命周期钩子\"></a>生命周期钩子</h2><p>生命周期钩子是比较常用的，不管是在根实例还是在单文件组件中。都经常会用到。</p>\n<h3 id=\"写法注意\"><a href=\"#写法注意\" class=\"headerlink\" title=\"写法注意\"></a>写法注意</h3><p>所有钩子函数，自动绑定this（实例本身）。所以不能使用箭头函数，箭头函数绑定的this是父作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意，这里是最简单的引用vue.js后，然后直接在全局实例化Vue</span></span><br><span class=\"line\"><span class=\"comment\">// 因此var vm 等同于window.vm</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// right</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">created</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 上面写法等同于如下写法</span></span><br><span class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this指向Vue实例本身</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// error 这种写法错误</span></span><br><span class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数绑定的是父作用域，这个例子中this指向window</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此箭头函数的话this指向并不是你期待的</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生命周期函数\"><a href=\"#生命周期函数\" class=\"headerlink\" title=\"生命周期函数\"></a>生命周期函数</h3><p><strong>beforeCreate</strong>：实例初始化之后，实例还没有创建完成，因此访问this的话，是undefined。</p>\n<p><strong>created</strong>：实例创建完成，但是未完成DOM挂载。因此this.$el是访问不到的。这里可以执行watch，methods等方法了。常用来挂载页面数据初始化（不涉及到DOM操作）。</p>\n<blockquote>\n<p>涉及到dom挂载，挂载后的重新打补丁渲染，销毁等钩子，都不会在服务端渲染阶段被调用。可以理解，因为服务端只会对页面做一次初始化，按照初始渲染，生成HTML，发送到客户端（浏览器端）。这块猜测如此，后期学习ssr方式后验证。</p>\n</blockquote>\n<p><strong>beforeMount</strong>：在挂载DOM到之前的一个钩子函数。能访问到this.$el，就是需要挂载的元素DOM（原始模板）。<strong>注意</strong>：$el即挂载的根节点，如<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，如单文件组件<code>&lt;template&gt;&lt;div&gt;&lt;/div&gt;&lt;/template&gt;</code>中的div根节点。如果是单文件的方式，在组建中beforeMount不一定能获取到$el，官方文档在<strong>mounted</strong>钩子函数中有说明。</p>\n<blockquote>\n<p>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。</p>\n</blockquote>\n<p><strong>mounted</strong>：el选项被新创建的$el替换，且$el挂载到实例上之后（即vm.$el），调用该钩子。通常会在该钩子阶段，操作DOM。这里可以访问到ref标记的DOM结构。</p>\n<p><strong>beforeUpdate</strong>：数据发生变化时，在虚拟DOM打补丁之前调用。可以访问数据更新前那个状态下的DOM。</p>\n<p><strong>updated</strong>：数据发生变化且虚拟DOM补丁打完之后。DOM更新成功，可以执行一些依赖DOM的操作。不应该在该钩子重新更改状态，考虑用watch和computed。类似mounted，不保证所有组件都重绘完成。如果需要确认所有组件重绘完成，使用$nextTick。</p>\n<p><strong>beforeDestroy</strong>：实例销毁之前调用。实例销毁，如v-if，vue-router中切换视图等都会触发该钩子。</p>\n<p><strong>destroyed</strong>：实例销毁之后调用，完全销毁，包括子实例也会销毁，同触发该钩子函数。</p>\n<p><strong>activated</strong>：组件相关的钩子，只有keep-alive包裹的组件，重新激活时会触发。通常我们会在<code>&lt;router-view&gt;&lt;/router-view&gt;</code>外套一层<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>，单页面应用，频繁切换视图，减小重新渲染开销。如果使用了keep-alice，会触发<code>activated</code>钩子，但是由于组件被缓存在内存中，没有销毁，也没有重新创建，因此从第二次渲染同样组件时不会触发<code>beforeCreate</code>,<code>created</code>,<code>beforeMount</code>,<code>mounted</code>等钩子，这点应该很好理解。而<code>beforeDestroy</code>,<code>destroyed</code>则永远不会被触发。</p>\n<p><strong>deactivated</strong>：组件相关的钩子，只有keep-alive包裹的组件，被停用时触发，类似于destroyed，但是不是真的销毁，而是存到内存放到一边，暂时不用这个组件，keep-alive形式的组件切换会触发该钩子。</p>\n<h2 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h2><p>分为3种类型守卫：全局型，单个路由独享型，组件内调用型。<br>通常回调函数有3个参数to, from, next。to，from均为对象，存放路由跳转目的地的参数和来源地的参数，而next为函数，类似于管道操作，进入到下一个钩子，不执行的话，通常会导致路由中断。</p>\n<h2 id=\"全局型\"><a href=\"#全局型\" class=\"headerlink\" title=\"全局型\"></a>全局型</h2><h3 id=\"beforeEach\"><a href=\"#beforeEach\" class=\"headerlink\" title=\"beforeEach\"></a>beforeEach</h3><p>全局前置路由。进入某路由之前触发。</p>\n<h3 id=\"beforeResolve\"><a href=\"#beforeResolve\" class=\"headerlink\" title=\"beforeResolve\"></a>beforeResolve</h3><p>全局解析路由。导航确认之前，同时在所有组件内调用型路由守卫和异步路由组件被解析之后，该解析守卫就会被调用。这里涉及的执行条件需要理解的是，1是<code>导航确认之前</code>，导航的确认是指全部的钩子执行完，导航状态就是确认的(confirmed状态)。2是<code>组件内路由守卫和异步路由组件都被解析</code>，指的是路由内调用型的3个守卫<code>beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave</code>，异步路由组件解析后(懒加载，通过Import()函数或require方式，用到的时候会去加载再解析，没用到就不存在加载解析一说)。简单来说，等组件内调用型守卫执行完了，异步组件也加载完了，才会执行<code>beforeResolve</code>。</p>\n<h3 id=\"afterEach\"><a href=\"#afterEach\" class=\"headerlink\" title=\"afterEach\"></a>afterEach</h3><p>全局后置钩子。没有next参数，可以理解，毕竟都已经后置了。在路由操作流程的最后触发。需要注意的是，这个钩子看起来是最后一个执行的钩子没错，但是在组件内调用守卫<code>beforeRouteEnter</code>的参数<code>next</code>中的回调函数，才是最后执行的，此时实例已创建好，所以可以在回调中访问到vue实例！！！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: []</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是老大，第一个执行&#x27;</span>)</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeResolve(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是保姆，大家都加载好，我在加载&#x27;</span>)</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是看起来的最后一名，不过好像有一个哥们比我还靠后，这哥们是beforeRouteEnter的回调参数next&#x27;</span>)</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>没有路由地址的情况下，上述3个全局路由会被各自执行一遍！。</p>\n<h2 id=\"单个路由独享守卫\"><a href=\"#单个路由独享守卫\" class=\"headerlink\" title=\"单个路由独享守卫\"></a>单个路由独享守卫</h2><h3 id=\"beforeEnter\"><a href=\"#beforeEnter\" class=\"headerlink\" title=\"beforeEnter\"></a>beforeEnter</h3><p>在路由配置里面单独配置的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/name&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">componet</span>: Name,</span><br><span class=\"line\">      <span class=\"attr\">beforeEnter</span>: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;进入name时调用，在组件内调用的守卫之前&#x27;</span>)</span><br><span class=\"line\">        next();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"组件内调用守卫\"><a href=\"#组件内调用守卫\" class=\"headerlink\" title=\"组件内调用守卫\"></a>组件内调用守卫</h2><h3 id=\"beforeRouteEnter\"><a href=\"#beforeRouteEnter\" class=\"headerlink\" title=\"beforeRouteEnter\"></a>beforeRouteEnter</h3><p>在渲染当前路由组件对应路由被<code>完全确认(confirm)</code>前调用。因为此时，组件实例还未被创建。所以拿不到this即组件实例。但可以通过next的回调函数拿到实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;comp&#x27;</span>,</span><br><span class=\"line\">  beforeRouteEnter(to, <span class=\"keyword\">from</span>, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;进了当前组件且在路由确认前调用&#x27;</span>)</span><br><span class=\"line\">    next(<span class=\"function\">(<span class=\"params\">vm</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(vm)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteUpdate(to, <span class=\"keyword\">from</span>, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;进了当前组件，或在当前组件打开子路由组件父组件仍存在，但内容已经不一样了，需要更新，会调用&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 如 home中打开A组件，/home -&gt; /home/A。 回到home组件，/home/A -&gt; /home</span></span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteLeave(to, <span class=\"keyword\">from</span>, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;离开当前路由组件对应的路由时调用&#x27;</span>)</span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"导航完整的解析流程\"><a href=\"#导航完整的解析流程\" class=\"headerlink\" title=\"导航完整的解析流程\"></a>导航完整的解析流程</h2><p>导航触发，肯定是从一个路由地址跳往另一个。我们这里考虑这种情况<code>/home/A -&gt; /home/B</code>，涉及到所有守卫;</p>\n<ol>\n<li>触发A的<code>beforeRouteLeave</code></li>\n<li>触发全局的<code>beforeEach</code></li>\n<li>触发Home组件中的<code>beforeRouteUpdate</code></li>\n<li>触发B的独享路由守卫<code>beforeEnter</code></li>\n<li>解析异步组件</li>\n<li>触发B的组件级守卫<code>beforeRouteEnter</code></li>\n<li>触发全局的<code>beforeResolve</code></li>\n<li>导航确认</li>\n<li>触发全局的<code>afterEach</code></li>\n<li>触发DOM更新</li>\n<li>组件实例创建完成，调用<code>beforeRouterEnter</code>中传递给<code>next</code>的回调函数，回调函数可传vm，即实例对象。</li>\n</ol>\n"},{"title":"简单的实现Promise","date":"2018-12-29T16:00:00.000Z","_content":"\n> promise 作为 es6 中的重点核心内容，除了只会用之外，还要弄明白其中的原理和规范。本文结合参阅的其他 Promise 实现的文章，还有 PromiseA+的规范，结合自己的理解，记录下如何实现 Promise。\n\n```js\nimport 'babel-polyfill'\n\n// 简单实用promise的例子。\n// var promiseA = new Promise(function(resolve, reject) {\n//   setTimeout(() => {\n//     resolve(1)\n//   }, 2000)\n// })\n\n// then方法可以无限调用，返回一个新的Promise，如果then中没有传递任何参数，则应该将上一个Promise的值传递到后面去\n// promiseA.then().then().then().then(r => {\n//   console.log(r)\n// })\n\n// then方法接受另一个promise，则等待接收的promise决议，其链式调用的then是接收的promise的回调\n// promiseA.then(function(r) {\n//   return new Promise(function(resolve, reject){\n//     setTimeout(() => {\n//       resolve(r + 1)\n//     },2000)\n//   })\n// }).then(r => {\n//   console.log(r)\n// })\n\nfunction MyPromise(fn) {\n  let callbackFn = []\n  let result = null\n  let status = 'pedding'\n  this.then = function(fullfilledFn) { // 前一个promise的then\n    return new MyPromise(function(resolve) { // 后一个新返回的promise\n      handle({\n        fullfilledFn: fullfilledFn || null,\n        resolve: resolve\n      })\n    })\n  }\n\n  function handle(callback) {\n    // 如果未决议，塞入回调中\n    if (status === 'pedding') {\n      callbackFn.push(callback)\n      return\n    }\n\n    // 根据PromiseA+的规范，如果fullfilled不是一个函数，且promise1执行成功，Promise2必须成功执行并返回相同的值。\n\n    // 让Promise2成功执行，就是调用返回的新promise中的resolve方法，并传递相同的值，这里即result（在promise1的resolve阶段，已经执行了result = asyncReturnValue）\n    // 如果已经决议，且then中未注册fullfilled函数，应该将值，带入返回的那个新promise的resovle中，继续传递下去\n    if (!callback.fullfilledFn) {\n      callback.resolve(result)\n      return\n    }\n    // 如果已经决议，且then中有注册fullfilled函数，执行前一个promise.then中的fullfilled。\n    var ret = callback.fullfilledFn(result)\n    // 处理的结果，应该传递给新返回的promise的resolve中。\n    callback.resolve(ret)\n  }\n\n  function resolve(asyncReturnValue) {\n    setTimeout(() => {\n      result = asyncReturnValue\n      status = 'fullfilled'\n      callbackFn.forEach(item => {\n        item(asyncReturnValue)\n      })\n    }, 0)\n  }\n  fn(resolve)\n}\n\nwindow.a = new MyPromise(function(resolve) {\n  setTimeout(() => {\n    resolve(1)\n  }, 2000)\n})\n\nwindow.a\n  .then(value => {\n    console.log(value)\n  })\n  .then(value => {\n    console.log(value + 1)\n  })\n```\n","source":"_posts/2018/promise.md","raw":"---\ntitle: 简单的实现Promise\ndate: 2018/12/30\n---\n\n> promise 作为 es6 中的重点核心内容，除了只会用之外，还要弄明白其中的原理和规范。本文结合参阅的其他 Promise 实现的文章，还有 PromiseA+的规范，结合自己的理解，记录下如何实现 Promise。\n\n```js\nimport 'babel-polyfill'\n\n// 简单实用promise的例子。\n// var promiseA = new Promise(function(resolve, reject) {\n//   setTimeout(() => {\n//     resolve(1)\n//   }, 2000)\n// })\n\n// then方法可以无限调用，返回一个新的Promise，如果then中没有传递任何参数，则应该将上一个Promise的值传递到后面去\n// promiseA.then().then().then().then(r => {\n//   console.log(r)\n// })\n\n// then方法接受另一个promise，则等待接收的promise决议，其链式调用的then是接收的promise的回调\n// promiseA.then(function(r) {\n//   return new Promise(function(resolve, reject){\n//     setTimeout(() => {\n//       resolve(r + 1)\n//     },2000)\n//   })\n// }).then(r => {\n//   console.log(r)\n// })\n\nfunction MyPromise(fn) {\n  let callbackFn = []\n  let result = null\n  let status = 'pedding'\n  this.then = function(fullfilledFn) { // 前一个promise的then\n    return new MyPromise(function(resolve) { // 后一个新返回的promise\n      handle({\n        fullfilledFn: fullfilledFn || null,\n        resolve: resolve\n      })\n    })\n  }\n\n  function handle(callback) {\n    // 如果未决议，塞入回调中\n    if (status === 'pedding') {\n      callbackFn.push(callback)\n      return\n    }\n\n    // 根据PromiseA+的规范，如果fullfilled不是一个函数，且promise1执行成功，Promise2必须成功执行并返回相同的值。\n\n    // 让Promise2成功执行，就是调用返回的新promise中的resolve方法，并传递相同的值，这里即result（在promise1的resolve阶段，已经执行了result = asyncReturnValue）\n    // 如果已经决议，且then中未注册fullfilled函数，应该将值，带入返回的那个新promise的resovle中，继续传递下去\n    if (!callback.fullfilledFn) {\n      callback.resolve(result)\n      return\n    }\n    // 如果已经决议，且then中有注册fullfilled函数，执行前一个promise.then中的fullfilled。\n    var ret = callback.fullfilledFn(result)\n    // 处理的结果，应该传递给新返回的promise的resolve中。\n    callback.resolve(ret)\n  }\n\n  function resolve(asyncReturnValue) {\n    setTimeout(() => {\n      result = asyncReturnValue\n      status = 'fullfilled'\n      callbackFn.forEach(item => {\n        item(asyncReturnValue)\n      })\n    }, 0)\n  }\n  fn(resolve)\n}\n\nwindow.a = new MyPromise(function(resolve) {\n  setTimeout(() => {\n    resolve(1)\n  }, 2000)\n})\n\nwindow.a\n  .then(value => {\n    console.log(value)\n  })\n  .then(value => {\n    console.log(value + 1)\n  })\n```\n","slug":"2018/promise","published":1,"updated":"2021-11-06T07:22:01.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjeryz000d6hufgnfb1nh5","content":"<blockquote>\n<p>promise 作为 es6 中的重点核心内容，除了只会用之外，还要弄明白其中的原理和规范。本文结合参阅的其他 Promise 实现的文章，还有 PromiseA+的规范，结合自己的理解，记录下如何实现 Promise。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;babel-polyfill&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单实用promise的例子。</span></span><br><span class=\"line\"><span class=\"comment\">// var promiseA = new Promise(function(resolve, reject) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     resolve(1)</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;, 2000)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then方法可以无限调用，返回一个新的Promise，如果then中没有传递任何参数，则应该将上一个Promise的值传递到后面去</span></span><br><span class=\"line\"><span class=\"comment\">// promiseA.then().then().then().then(r =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(r)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then方法接受另一个promise，则等待接收的promise决议，其链式调用的then是接收的promise的回调</span></span><br><span class=\"line\"><span class=\"comment\">// promiseA.then(function(r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   return new Promise(function(resolve, reject)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(r + 1)</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;,2000)</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;).then(r =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(r)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> callbackFn = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> status = <span class=\"string\">&#x27;pedding&#x27;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fullfilledFn</span>) </span>&#123; <span class=\"comment\">// 前一个promise的then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123; <span class=\"comment\">// 后一个新返回的promise</span></span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        <span class=\"attr\">fullfilledFn</span>: fullfilledFn || <span class=\"literal\">null</span>,</span><br><span class=\"line\">        <span class=\"attr\">resolve</span>: resolve</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果未决议，塞入回调中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      callbackFn.push(callback)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据PromiseA+的规范，如果fullfilled不是一个函数，且promise1执行成功，Promise2必须成功执行并返回相同的值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让Promise2成功执行，就是调用返回的新promise中的resolve方法，并传递相同的值，这里即result（在promise1的resolve阶段，已经执行了result = asyncReturnValue）</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果已经决议，且then中未注册fullfilled函数，应该将值，带入返回的那个新promise的resovle中，继续传递下去</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!callback.fullfilledFn) &#123;</span><br><span class=\"line\">      callback.resolve(result)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果已经决议，且then中有注册fullfilled函数，执行前一个promise.then中的fullfilled。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = callback.fullfilledFn(result)</span><br><span class=\"line\">    <span class=\"comment\">// 处理的结果，应该传递给新返回的promise的resolve中。</span></span><br><span class=\"line\">    callback.resolve(ret)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">asyncReturnValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      result = asyncReturnValue</span><br><span class=\"line\">      status = <span class=\"string\">&#x27;fullfilled&#x27;</span></span><br><span class=\"line\">      callbackFn.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">        item(asyncReturnValue)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fn(resolve)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.a = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.a</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>promise 作为 es6 中的重点核心内容，除了只会用之外，还要弄明白其中的原理和规范。本文结合参阅的其他 Promise 实现的文章，还有 PromiseA+的规范，结合自己的理解，记录下如何实现 Promise。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;babel-polyfill&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单实用promise的例子。</span></span><br><span class=\"line\"><span class=\"comment\">// var promiseA = new Promise(function(resolve, reject) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     resolve(1)</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;, 2000)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then方法可以无限调用，返回一个新的Promise，如果then中没有传递任何参数，则应该将上一个Promise的值传递到后面去</span></span><br><span class=\"line\"><span class=\"comment\">// promiseA.then().then().then().then(r =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(r)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then方法接受另一个promise，则等待接收的promise决议，其链式调用的then是接收的promise的回调</span></span><br><span class=\"line\"><span class=\"comment\">// promiseA.then(function(r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   return new Promise(function(resolve, reject)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(r + 1)</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;,2000)</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;).then(r =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(r)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> callbackFn = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> status = <span class=\"string\">&#x27;pedding&#x27;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fullfilledFn</span>) </span>&#123; <span class=\"comment\">// 前一个promise的then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123; <span class=\"comment\">// 后一个新返回的promise</span></span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        <span class=\"attr\">fullfilledFn</span>: fullfilledFn || <span class=\"literal\">null</span>,</span><br><span class=\"line\">        <span class=\"attr\">resolve</span>: resolve</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果未决议，塞入回调中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      callbackFn.push(callback)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据PromiseA+的规范，如果fullfilled不是一个函数，且promise1执行成功，Promise2必须成功执行并返回相同的值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让Promise2成功执行，就是调用返回的新promise中的resolve方法，并传递相同的值，这里即result（在promise1的resolve阶段，已经执行了result = asyncReturnValue）</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果已经决议，且then中未注册fullfilled函数，应该将值，带入返回的那个新promise的resovle中，继续传递下去</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!callback.fullfilledFn) &#123;</span><br><span class=\"line\">      callback.resolve(result)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果已经决议，且then中有注册fullfilled函数，执行前一个promise.then中的fullfilled。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = callback.fullfilledFn(result)</span><br><span class=\"line\">    <span class=\"comment\">// 处理的结果，应该传递给新返回的promise的resolve中。</span></span><br><span class=\"line\">    callback.resolve(ret)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">asyncReturnValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      result = asyncReturnValue</span><br><span class=\"line\">      status = <span class=\"string\">&#x27;fullfilled&#x27;</span></span><br><span class=\"line\">      callbackFn.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">        item(asyncReturnValue)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fn(resolve)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.a = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.a</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"webpack中的less引入","date":"2018-12-29T16:00:00.000Z","_content":"\n> 项目本身是用vue-cli搭建的模板。使用了less写样式。考虑到充分使用less的特性，所以肯定会有如mixin.less，base.less之类的公用less模块。\n\n```css\n@import '../../common/style/base.less';\n@import '../../common/style/mixin.less';\n```\n当然可以这么写，完全的相对路径。经测试是没问题的。\n\n但是既然是webpack，当然应该充分利用其特性。我也是在看了如慕课网的实战教程后，才了解过还有这种写法。\n```css\n@import '~common/style/base.less'\n@import '~common/style/mixin.less'\n```\n\n平时一直这么写，没有关注过~这个符号到底代表的是什么。直到有一次写到一个背景图片的less通用函数，出了问题，如下\n```css\n  /*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/\n  .bg-set(@img) {\n    background-image: url(@img);\n    background-repeat: no-repeat;\n    background-size: 100%;\n  }\n\n  /*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/\n  .bg-set('./arrow.png')\n```\n结果报错，webpack提示大致意思是找不到Module：arrow.png。看了下报错详细，引用的arrow.png路径尽然是**src/common/style/arrow.png**，而不是理想下的**src/page/index/arrow.png**。\n\n这个问题的确不好描述，网上搜索过相关问题，基本没有。后来在慕课网中发现有人回答了该问题。\n```css\n  /*mixin.less中函数改写为*/\n  .bg-set(@img) {\n    background-image: ~'url(@{img})';\n    background-size: 100%;\n    background-repeat: no-repeat;\n  }\n```\n这里的关键其实就是多了个~，因此顺腾摸瓜，从webpack官网查找~相关的，在官方中文文档的LOADERS列表中，关于less-loader中有介绍，~利用了webpack的高级特性，将查询参数（这里应该就是传递的图片路径）传递给webpack resolver，告诉webpack***以模块查找的方式对待该路径***。有点懵逼，没关系，看下例子。\n\n## 先看下js模块的的导入规则\n```js\n  <!-- 引用Vue模块，优先会从Node核心模块查找，找不到的话，就从node_modules查找 -->\n  var vue = require('vue')\n  import Vue from 'vue'\n\n  <!-- 如果传入的是一个相对路径，则按相对路径查找 -->\n  var util = require('./utils')\n  import util from './utils'\n\n  <!-- webpack中可以配置alias（别名），假设@指代src/ -->\n  import main from '@/common/main' // 这里加载的路径就是src/common/main.js\n```\n从上面大概能了解，webpack中，对js的引入，就是模块导入。webpack官方网站在less-loader和sass-loader中有这么一段相同话。\n> 只要加一个 ~ 前缀，告诉 webpack 去查询模块。\n\n因此，我们在css模块，或者html中只要在路径前面加一个~，实际上就是告诉webpack，按照模块加载方式来寻找对应的资源。\n以下代码我们还是假设@是src的别名。\n```css\n  <!-- 因此问题迎刃而解 -->\n  /*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/\n  .bg-set(@img) {\n    background-image: url(@img);\n    background-repeat: no-repeat;\n    background-size: 100%;\n  }\n  /*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/\n  .bg-set('~@/page/index/arrow.png') // 可以 遇到~，模块方式加载，将@/page/index/arrow.png 解析为 src/page/index/arrow.png。\n\n  .bg-set('~./arrow.png') // 可以 遇到~，模块方式加载，将./arrow.png 按相对路径访问加载该模块资源，即在当前index文件夹中找到arrow.png。因此没问题。\n```\n至于改动less函数的方法。原理差不多\n\n```css\n  <!-- 对'url(@{img})'以模块方式搜索，因该函数被导入到当前less中，当传入./arrow.png时，以'~./arrow.png'的方式进行路径解析，跟上面第二种方式一致。 -->\n  background-image: ~'url(@{img})';\n```\n\n至此，webpack中的~，大家应该都清楚不少。如果有不对的地方，欢迎指正。\n","source":"_posts/2018/less-module-in-webpack.md","raw":"---\ntitle: webpack中的less引入\ndate: 2018/12/30\n---\n\n> 项目本身是用vue-cli搭建的模板。使用了less写样式。考虑到充分使用less的特性，所以肯定会有如mixin.less，base.less之类的公用less模块。\n\n```css\n@import '../../common/style/base.less';\n@import '../../common/style/mixin.less';\n```\n当然可以这么写，完全的相对路径。经测试是没问题的。\n\n但是既然是webpack，当然应该充分利用其特性。我也是在看了如慕课网的实战教程后，才了解过还有这种写法。\n```css\n@import '~common/style/base.less'\n@import '~common/style/mixin.less'\n```\n\n平时一直这么写，没有关注过~这个符号到底代表的是什么。直到有一次写到一个背景图片的less通用函数，出了问题，如下\n```css\n  /*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/\n  .bg-set(@img) {\n    background-image: url(@img);\n    background-repeat: no-repeat;\n    background-size: 100%;\n  }\n\n  /*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/\n  .bg-set('./arrow.png')\n```\n结果报错，webpack提示大致意思是找不到Module：arrow.png。看了下报错详细，引用的arrow.png路径尽然是**src/common/style/arrow.png**，而不是理想下的**src/page/index/arrow.png**。\n\n这个问题的确不好描述，网上搜索过相关问题，基本没有。后来在慕课网中发现有人回答了该问题。\n```css\n  /*mixin.less中函数改写为*/\n  .bg-set(@img) {\n    background-image: ~'url(@{img})';\n    background-size: 100%;\n    background-repeat: no-repeat;\n  }\n```\n这里的关键其实就是多了个~，因此顺腾摸瓜，从webpack官网查找~相关的，在官方中文文档的LOADERS列表中，关于less-loader中有介绍，~利用了webpack的高级特性，将查询参数（这里应该就是传递的图片路径）传递给webpack resolver，告诉webpack***以模块查找的方式对待该路径***。有点懵逼，没关系，看下例子。\n\n## 先看下js模块的的导入规则\n```js\n  <!-- 引用Vue模块，优先会从Node核心模块查找，找不到的话，就从node_modules查找 -->\n  var vue = require('vue')\n  import Vue from 'vue'\n\n  <!-- 如果传入的是一个相对路径，则按相对路径查找 -->\n  var util = require('./utils')\n  import util from './utils'\n\n  <!-- webpack中可以配置alias（别名），假设@指代src/ -->\n  import main from '@/common/main' // 这里加载的路径就是src/common/main.js\n```\n从上面大概能了解，webpack中，对js的引入，就是模块导入。webpack官方网站在less-loader和sass-loader中有这么一段相同话。\n> 只要加一个 ~ 前缀，告诉 webpack 去查询模块。\n\n因此，我们在css模块，或者html中只要在路径前面加一个~，实际上就是告诉webpack，按照模块加载方式来寻找对应的资源。\n以下代码我们还是假设@是src的别名。\n```css\n  <!-- 因此问题迎刃而解 -->\n  /*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/\n  .bg-set(@img) {\n    background-image: url(@img);\n    background-repeat: no-repeat;\n    background-size: 100%;\n  }\n  /*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/\n  .bg-set('~@/page/index/arrow.png') // 可以 遇到~，模块方式加载，将@/page/index/arrow.png 解析为 src/page/index/arrow.png。\n\n  .bg-set('~./arrow.png') // 可以 遇到~，模块方式加载，将./arrow.png 按相对路径访问加载该模块资源，即在当前index文件夹中找到arrow.png。因此没问题。\n```\n至于改动less函数的方法。原理差不多\n\n```css\n  <!-- 对'url(@{img})'以模块方式搜索，因该函数被导入到当前less中，当传入./arrow.png时，以'~./arrow.png'的方式进行路径解析，跟上面第二种方式一致。 -->\n  background-image: ~'url(@{img})';\n```\n\n至此，webpack中的~，大家应该都清楚不少。如果有不对的地方，欢迎指正。\n","slug":"2018/less-module-in-webpack","published":1,"updated":"2021-11-06T07:21:50.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz0000e6hufae2nh1c5","content":"<blockquote>\n<p>项目本身是用vue-cli搭建的模板。使用了less写样式。考虑到充分使用less的特性，所以肯定会有如mixin.less，base.less之类的公用less模块。</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&#x27;../../common/style/base.less&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&#x27;../../common/style/mixin.less&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>当然可以这么写，完全的相对路径。经测试是没问题的。</p>\n<p>但是既然是webpack，当然应该充分利用其特性。我也是在看了如慕课网的实战教程后，才了解过还有这种写法。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&#x27;~common/style/base.less&#x27;</span></span><br><span class=\"line\">@import <span class=\"string\">&#x27;~common/style/mixin.less&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>平时一直这么写，没有关注过~这个符号到底代表的是什么。直到有一次写到一个背景图片的less通用函数，出了问题，如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(<span class=\"keyword\">@img</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">@img</span>);</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(&#x27;./arrow<span class=\"selector-class\">.png</span>&#x27;)</span><br></pre></td></tr></table></figure>\n<p>结果报错，webpack提示大致意思是找不到Module：arrow.png。看了下报错详细，引用的arrow.png路径尽然是<strong>src/common/style/arrow.png</strong>，而不是理想下的<strong>src/page/index/arrow.png</strong>。</p>\n<p>这个问题的确不好描述，网上搜索过相关问题，基本没有。后来在慕课网中发现有人回答了该问题。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*mixin.less中函数改写为*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(<span class=\"keyword\">@img</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: ~<span class=\"string\">&#x27;url(@&#123;img&#125;)&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的关键其实就是多了个<del>，因此顺腾摸瓜，从webpack官网查找</del>相关的，在官方中文文档的LOADERS列表中，关于less-loader中有介绍，~利用了webpack的高级特性，将查询参数（这里应该就是传递的图片路径）传递给webpack resolver，告诉webpack<em><strong>以模块查找的方式对待该路径</strong></em>。有点懵逼，没关系，看下例子。</p>\n<h2 id=\"先看下js模块的的导入规则\"><a href=\"#先看下js模块的的导入规则\" class=\"headerlink\" title=\"先看下js模块的的导入规则\"></a>先看下js模块的的导入规则</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 引用Vue模块，优先会从Node核心模块查找，找不到的话，就从node_modules查找 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> vue = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;vue&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 如果传入的是一个相对路径，则按相对路径查找 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./utils&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">import</span> util <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./utils&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- webpack中可以配置alias（别名），假设@指代src/ --&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> main <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/common/main&#x27;</span> <span class=\"comment\">// 这里加载的路径就是src/common/main.js</span></span><br></pre></td></tr></table></figure>\n<p>从上面大概能了解，webpack中，对js的引入，就是模块导入。webpack官方网站在less-loader和sass-loader中有这么一段相同话。</p>\n<blockquote>\n<p>只要加一个 ~ 前缀，告诉 webpack 去查询模块。</p>\n</blockquote>\n<p>因此，我们在css模块，或者html中只要在路径前面加一个~，实际上就是告诉webpack，按照模块加载方式来寻找对应的资源。<br>以下代码我们还是假设@是src的别名。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 因此问题迎刃而解 --&gt;</span><br><span class=\"line\"><span class=\"comment\">/*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(<span class=\"keyword\">@img</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">@img</span>);</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(&#x27;~@/page/index/arrow.png&#x27;) // 可以 遇到~，模块方式加载，将@/page/index/arrow.png 解析为 src/page/index/arrow.png。</span><br><span class=\"line\"></span><br><span class=\"line\">.bg-set(<span class=\"string\">&#x27;~./arrow.png&#x27;</span>) // 可以 遇到~，模块方式加载，将./arrow.png 按相对路径访问加载该模块资源，即在当前index文件夹中找到arrow.png。因此没问题。</span><br></pre></td></tr></table></figure>\n<p>至于改动less函数的方法。原理差不多</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 对&#x27;url(@&#123;<span class=\"selector-tag\">img</span>&#125;)&#x27;以模块方式搜索，因该函数被导入到当前less中，当传入./arrow<span class=\"selector-class\">.png</span>时，以&#x27;~./arrow<span class=\"selector-class\">.png</span>&#x27;的方式进行路径解析，跟上面第二种方式一致。 --&gt;</span><br><span class=\"line\"><span class=\"attribute\">background-image</span>: ~<span class=\"string\">&#x27;url(@&#123;img&#125;)&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>至此，webpack中的~，大家应该都清楚不少。如果有不对的地方，欢迎指正。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>项目本身是用vue-cli搭建的模板。使用了less写样式。考虑到充分使用less的特性，所以肯定会有如mixin.less，base.less之类的公用less模块。</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&#x27;../../common/style/base.less&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&#x27;../../common/style/mixin.less&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>当然可以这么写，完全的相对路径。经测试是没问题的。</p>\n<p>但是既然是webpack，当然应该充分利用其特性。我也是在看了如慕课网的实战教程后，才了解过还有这种写法。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&#x27;~common/style/base.less&#x27;</span></span><br><span class=\"line\">@import <span class=\"string\">&#x27;~common/style/mixin.less&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>平时一直这么写，没有关注过~这个符号到底代表的是什么。直到有一次写到一个背景图片的less通用函数，出了问题，如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(<span class=\"keyword\">@img</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">@img</span>);</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(&#x27;./arrow<span class=\"selector-class\">.png</span>&#x27;)</span><br></pre></td></tr></table></figure>\n<p>结果报错，webpack提示大致意思是找不到Module：arrow.png。看了下报错详细，引用的arrow.png路径尽然是<strong>src/common/style/arrow.png</strong>，而不是理想下的<strong>src/page/index/arrow.png</strong>。</p>\n<p>这个问题的确不好描述，网上搜索过相关问题，基本没有。后来在慕课网中发现有人回答了该问题。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*mixin.less中函数改写为*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(<span class=\"keyword\">@img</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: ~<span class=\"string\">&#x27;url(@&#123;img&#125;)&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的关键其实就是多了个<del>，因此顺腾摸瓜，从webpack官网查找</del>相关的，在官方中文文档的LOADERS列表中，关于less-loader中有介绍，~利用了webpack的高级特性，将查询参数（这里应该就是传递的图片路径）传递给webpack resolver，告诉webpack<em><strong>以模块查找的方式对待该路径</strong></em>。有点懵逼，没关系，看下例子。</p>\n<h2 id=\"先看下js模块的的导入规则\"><a href=\"#先看下js模块的的导入规则\" class=\"headerlink\" title=\"先看下js模块的的导入规则\"></a>先看下js模块的的导入规则</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 引用Vue模块，优先会从Node核心模块查找，找不到的话，就从node_modules查找 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> vue = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;vue&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 如果传入的是一个相对路径，则按相对路径查找 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./utils&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">import</span> util <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./utils&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- webpack中可以配置alias（别名），假设@指代src/ --&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> main <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/common/main&#x27;</span> <span class=\"comment\">// 这里加载的路径就是src/common/main.js</span></span><br></pre></td></tr></table></figure>\n<p>从上面大概能了解，webpack中，对js的引入，就是模块导入。webpack官方网站在less-loader和sass-loader中有这么一段相同话。</p>\n<blockquote>\n<p>只要加一个 ~ 前缀，告诉 webpack 去查询模块。</p>\n</blockquote>\n<p>因此，我们在css模块，或者html中只要在路径前面加一个~，实际上就是告诉webpack，按照模块加载方式来寻找对应的资源。<br>以下代码我们还是假设@是src的别名。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 因此问题迎刃而解 --&gt;</span><br><span class=\"line\"><span class=\"comment\">/*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(<span class=\"keyword\">@img</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">@img</span>);</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.bg-set</span>(&#x27;~@/page/index/arrow.png&#x27;) // 可以 遇到~，模块方式加载，将@/page/index/arrow.png 解析为 src/page/index/arrow.png。</span><br><span class=\"line\"></span><br><span class=\"line\">.bg-set(<span class=\"string\">&#x27;~./arrow.png&#x27;</span>) // 可以 遇到~，模块方式加载，将./arrow.png 按相对路径访问加载该模块资源，即在当前index文件夹中找到arrow.png。因此没问题。</span><br></pre></td></tr></table></figure>\n<p>至于改动less函数的方法。原理差不多</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 对&#x27;url(@&#123;<span class=\"selector-tag\">img</span>&#125;)&#x27;以模块方式搜索，因该函数被导入到当前less中，当传入./arrow<span class=\"selector-class\">.png</span>时，以&#x27;~./arrow<span class=\"selector-class\">.png</span>&#x27;的方式进行路径解析，跟上面第二种方式一致。 --&gt;</span><br><span class=\"line\"><span class=\"attribute\">background-image</span>: ~<span class=\"string\">&#x27;url(@&#123;img&#125;)&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>至此，webpack中的~，大家应该都清楚不少。如果有不对的地方，欢迎指正。</p>\n"},{"title":"导航流程","date":"2020-12-29T16:00:00.000Z","_content":"\n这里先配流程图，后面描述在丰富一下。\n\n## 导航阶段\n\n![导航阶段](/images/browser_navigator.png)\n\n## 渲染阶段\n\n![渲染阶段](/images/browser_render.png)\n","source":"_posts/2020/URL输入到页面渲染流程.md","raw":"---\ntitle: 导航流程\ndate: 2020/12/30\n---\n\n这里先配流程图，后面描述在丰富一下。\n\n## 导航阶段\n\n![导航阶段](/images/browser_navigator.png)\n\n## 渲染阶段\n\n![渲染阶段](/images/browser_render.png)\n","slug":"2020/URL输入到页面渲染流程","published":1,"updated":"2021-11-06T07:36:21.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz0000f6huf97o7bss0","content":"<p>这里先配流程图，后面描述在丰富一下。</p>\n<h2 id=\"导航阶段\"><a href=\"#导航阶段\" class=\"headerlink\" title=\"导航阶段\"></a>导航阶段</h2><p><img src=\"/images/browser_navigator.png\" alt=\"导航阶段\"></p>\n<h2 id=\"渲染阶段\"><a href=\"#渲染阶段\" class=\"headerlink\" title=\"渲染阶段\"></a>渲染阶段</h2><p><img src=\"/images/browser_render.png\" alt=\"渲染阶段\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里先配流程图，后面描述在丰富一下。</p>\n<h2 id=\"导航阶段\"><a href=\"#导航阶段\" class=\"headerlink\" title=\"导航阶段\"></a>导航阶段</h2><p><img src=\"/images/browser_navigator.png\" alt=\"导航阶段\"></p>\n<h2 id=\"渲染阶段\"><a href=\"#渲染阶段\" class=\"headerlink\" title=\"渲染阶段\"></a>渲染阶段</h2><p><img src=\"/images/browser_render.png\" alt=\"渲染阶段\"></p>\n"},{"title":"Vue的render函数","date":"2018-12-29T16:00:00.000Z","_content":"\n工作和学习中大部分的vue工程都是通过vue-cli脚手架生成的，所以很少关注到vue实例创建那块，偶尔自己手写则会出现各种报错，比如该版本不包含编译器，请下载完整版本（带有编译器）的。因此趁着这个机会，详细了解了下vue的版本区别以及render函数的使用。\n\n## 先认识下Vue提供的版本\n\n## 完整版\n包含了编译器的Vue代码。\n\n## 关于runtime版本\n创建Vue实例，渲染并处理虚拟DOM等的代码，不包含编译器\n\n## 编译器是什么\n负责将模板字符串变异成Js渲染函数的代码\n```js\n// 创建Vue实例，传入一个模板作为HTML渲染结构。需要编译器，在客户端进行模板编译的。\nnew Vue({\n  template: '<div>{{title}}</div>'\n})\n\n// 通过render函数进行渲染，在构建时预编译为Js代码，最终生成的bundle中不在需要编译器。\nnew Vue({\n  render(h) {\n    return h('div', this.title)\n  }\n})\n\n```\n可以看出来，runtime版本和完整版本，最终都是编译为Js渲染函数代码。**差异**就是编译一个在开发人员代码构建时（打包器打包阶段），一个在客户端上调用时编译。\n\n使用vue-cli构建的vue工程，可以看到vue实例的创建是这样的\n```html\n  <!-- App.vue -->\n  <template>\n    <div class=\"wrap\">\n      <v-nav></v-nav>\n      <router-view></router-view>\n    </div>\n  </template>\n  <script>\n    import vNav from 'v-nav.vue'\n    export default {\n      name: 'App'\n    }\n  </script>\n  <style></style>\n```\n\n```js\nimport App from 'App.vue'\n\n// 这里的h实际上是createElement函数\nnew Vue({\n  el: '#app',\n  render: (h) => {\n    return h(App)\n  }\n})\n```\n\n\n***但是***如果你尝试使用template来挂载模板，会报错。提示你需要完整版本\n```html\n<body>\n  <div id=\"app\"></div>\n</body>\n```\n```js\nimport vComp from './v-comp.vue'\n\nnew Vue({\n  el: '#app',\n  template: '<div><v-nav></v-nav><router-view></router-view></div>',\n  components: {\n    vComp\n  }\n})\n```\n这是因为，采用webpack2+，或者parcel这类打包工具，都是引用的运行时版本**node_modules\\vue\\dist\\vue.runtime.esm.js**。\n如果你一定要使用template的话，可以配置一个别名，引用vue的完整版本即可。\n如webpack:\n```js\nmodule.exports = {\n  // ...\n  resolve: {\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js'\n    }\n  }\n}\n```\n\n## 关于render渲染函数\n\n## 某些环境中代码更简练\n> 这里引用官方文档的一个例子\n```html\n<!-- 一个vue单文件 -->\n<template>\n  <div>\n    <h1 v-if=\"level === 1\">\n      <slot></slot>\n    </h1>\n    <h2 v-if=\"level === 2\">\n      <slot></slot>\n    </h2>\n    <h3 v-if=\"level === 3\">\n      <slot></slot>\n    </h3>\n    <h4 v-if=\"level === 4\">\n      <slot></slot>\n    </h4>\n    <h5 v-if=\"level === 5\">\n      <slot></slot>\n    </h5>\n  </div>\n</template>\n```\n```js\nexport default {\n  name: 'title',\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n}\n```\n\n这个组件实际就是根据传递的level来决定使用的到底是h1到h5中的哪一个。虽然思路清晰，但是代码冗长。采用render函数的来重写的话。\n\n```js\nVue.component('heading', {\n  render: (createElement) => {\n    console.log(createElement(\n      'h' + this.level, // h标签\n      this.$slots.default // 插槽内容\n    ))\n    return createElement(\n      'h' + this.level, // h标签\n      this.$slots.default // 插槽内容\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n**注意**的是，createElement函数返回的是一个**虚拟DOM节点**（这个组件只是整个页面的一小部分），即VNode。而**虚拟DOM**则是对Vue组件树建立起来的整个VNode树的称呼。上面代码中的console会打印出如下类似内容。\n![VNode](/images/VNode_object.jpg)\n\n**注意**：createElement的参数有三个。\n1. 参数1必填，可以是String（HTML字符串）, Object（组件选项对象）, Function（解析上述类型任何一种的异步函数）。\n2. 参数2选填，Obejct，包含模板相关属性的数据对象，例如class, title等等。涉及的东西很多，查看官方文档[data对象](https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5-data-%E5%AF%B9%E8%B1%A1)\n3. 参数3选填，Array，String。子节点VNodes，**由createElmenet()函数返回一个VNode对象**，或者是字符串形式的文本节点。\n\n在上例的代码中，我们只传递的2个参数，第二个传入的参数就是createElement函数的第三个参数，一个数组，数组中是多个对象，都是由createElement()函数返回的VNode节点。类似如下\n![createElement返回的对象](/images/VNodes_createElement_return.jpg)\n\n## VNodes(子节点)必须是唯一的\n这里的唯一是指，createElement返回的VNode对象是唯一的，使用上也是唯一的，应该看做一个实例对象。而不能当做引用对象使用。\n官方示例中，如下代码，同一个对象被多次引用使用，就是错误的。\n```js\n  render: function(createElement) {\n    var onlyOneObject = createElement('p','hi'); // 参数1，p标签。参数2，字符串，子节点\n    return createElement('div', [\n      onlyOneObject, onlyOneObject // 数组中引用同一个VNodes\n    ])\n  }\n```\n\n一定需要重复渲染相同的元素/组件（即VNodes），采用工厂函数来实现。\n```js\n  render: function(createElement) {\n    return createElement('div',\n      Array.apply(null, {length: 20}).map(function(){ // apply第二个参数接受数组或类数组生成一个20个长度的数组，map该数组，返回对应的一个应用map传递函数的20长度的数组内容。即[VNodes, VNodes, ..., VNodes]\n        return createElement('p', hi)\n      })\n    )\n  }\n```\n\n## Js代替模板引擎常用的功能实现\n\n### v-if和v-for\n```html\n  <ul v-if=\"items.length\">\n    <li v-for=\"item in items\">{{item.name}}</li>\n  </ul>\n  <p v-else>No items found.</p>\n```\n\n```js\n// render函数中写法\nVue.component('forComp', {\n  render: (createElement) => {\n    if (this.items.length) {\n      return createElement('ul', this.items.map((item,index) => {\n        return createElement('li', item.name)\n      }))\n    }else{\n      return createElement('p', 'No items found')\n    }\n  },\n  props: {\n    items: {\n      type: Array,\n      required: true\n    }\n  }\n})\n```\n### v-model\n```html\n<input type=\"text\" v-model=\"enterVal\">\n```\n```js\n// render函数中写法\nVue.component('oInput', {\n  render: (createElement) => {\n    var self = this;\n    return createElement('input', {\n      // DOM属性\n      domProps: {\n        value: self.enterVal\n      },\n      // 事件监听器，基于on\n      on:{\n        input: function(event){\n          self.$emit('input', event.target.value); // 这里派发一个input事件，实际上对应应该是如下Html代码结构\n        }\n      }\n    })\n  },\n  props: {\n    enterVal: {\n      type: [String, Number],\n      required: true\n    }\n  }\n})\n```\n\n```html\n<!-- 猜测，本质上v-model应该是vue的语法糖，实现监听input事件，然后得到最新输入的值，更新视图 -->\n<input type=\"text\" v-on:input=\"\">\n```\n\n### 插槽\n```js\n  // 普通的插槽内容\n  render: function(createElement) {\n    return createElement('div', this.$slots.default)\n  }\n\n\n  // 生成带有作用域插槽的组件结构（可以传递数据的slot）\n  props: ['message'],\n  render: function(createElement) {=\n    return createElement('div', [\n      // $scopedSlots.default是一个函数，返回VNodes\n      this.$scopedSlots.default({\n        text: this.message\n      })\n    ])\n  }\n\n\n  // 向子组件中传递作用域插槽。\n  rende: function(createElement) {\n    return createElement('div', [\n      createElement('child', {\n        scopedSlots: {\n          default: function(props) {\n            return createElement('span', props.text)\n          }\n        }\n      })\n    ])\n  }\n```\n\n```html\n<!-- 上面3段渲染函数关于插槽的写法，对应的template结构应该是 -->\n  <div>\n    这里是slot的内容\n  </div>\n\n\n  <div>\n    <slot :text=\"message\"></slot>\n  </div>\n\n\n  <div>\n    <child>\n      <span slot-scope=\"props\">{{props.text}}</span>\n    </child>\n  </div>\n```\n\n## 总结\n本文主要是方便自己理解render函数究竟是做什么的，区分不同vue构建版本中使用render方式的差异，后半部分结合官方文档，了解了下render函数的其他简单用法。文章内容还是比较浅，建议大家去官方文档学习。\n","source":"_posts/2018/render-in-vue.md","raw":"---\ntitle: Vue的render函数\ndate: 2018/12/30\n---\n\n工作和学习中大部分的vue工程都是通过vue-cli脚手架生成的，所以很少关注到vue实例创建那块，偶尔自己手写则会出现各种报错，比如该版本不包含编译器，请下载完整版本（带有编译器）的。因此趁着这个机会，详细了解了下vue的版本区别以及render函数的使用。\n\n## 先认识下Vue提供的版本\n\n## 完整版\n包含了编译器的Vue代码。\n\n## 关于runtime版本\n创建Vue实例，渲染并处理虚拟DOM等的代码，不包含编译器\n\n## 编译器是什么\n负责将模板字符串变异成Js渲染函数的代码\n```js\n// 创建Vue实例，传入一个模板作为HTML渲染结构。需要编译器，在客户端进行模板编译的。\nnew Vue({\n  template: '<div>{{title}}</div>'\n})\n\n// 通过render函数进行渲染，在构建时预编译为Js代码，最终生成的bundle中不在需要编译器。\nnew Vue({\n  render(h) {\n    return h('div', this.title)\n  }\n})\n\n```\n可以看出来，runtime版本和完整版本，最终都是编译为Js渲染函数代码。**差异**就是编译一个在开发人员代码构建时（打包器打包阶段），一个在客户端上调用时编译。\n\n使用vue-cli构建的vue工程，可以看到vue实例的创建是这样的\n```html\n  <!-- App.vue -->\n  <template>\n    <div class=\"wrap\">\n      <v-nav></v-nav>\n      <router-view></router-view>\n    </div>\n  </template>\n  <script>\n    import vNav from 'v-nav.vue'\n    export default {\n      name: 'App'\n    }\n  </script>\n  <style></style>\n```\n\n```js\nimport App from 'App.vue'\n\n// 这里的h实际上是createElement函数\nnew Vue({\n  el: '#app',\n  render: (h) => {\n    return h(App)\n  }\n})\n```\n\n\n***但是***如果你尝试使用template来挂载模板，会报错。提示你需要完整版本\n```html\n<body>\n  <div id=\"app\"></div>\n</body>\n```\n```js\nimport vComp from './v-comp.vue'\n\nnew Vue({\n  el: '#app',\n  template: '<div><v-nav></v-nav><router-view></router-view></div>',\n  components: {\n    vComp\n  }\n})\n```\n这是因为，采用webpack2+，或者parcel这类打包工具，都是引用的运行时版本**node_modules\\vue\\dist\\vue.runtime.esm.js**。\n如果你一定要使用template的话，可以配置一个别名，引用vue的完整版本即可。\n如webpack:\n```js\nmodule.exports = {\n  // ...\n  resolve: {\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js'\n    }\n  }\n}\n```\n\n## 关于render渲染函数\n\n## 某些环境中代码更简练\n> 这里引用官方文档的一个例子\n```html\n<!-- 一个vue单文件 -->\n<template>\n  <div>\n    <h1 v-if=\"level === 1\">\n      <slot></slot>\n    </h1>\n    <h2 v-if=\"level === 2\">\n      <slot></slot>\n    </h2>\n    <h3 v-if=\"level === 3\">\n      <slot></slot>\n    </h3>\n    <h4 v-if=\"level === 4\">\n      <slot></slot>\n    </h4>\n    <h5 v-if=\"level === 5\">\n      <slot></slot>\n    </h5>\n  </div>\n</template>\n```\n```js\nexport default {\n  name: 'title',\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n}\n```\n\n这个组件实际就是根据传递的level来决定使用的到底是h1到h5中的哪一个。虽然思路清晰，但是代码冗长。采用render函数的来重写的话。\n\n```js\nVue.component('heading', {\n  render: (createElement) => {\n    console.log(createElement(\n      'h' + this.level, // h标签\n      this.$slots.default // 插槽内容\n    ))\n    return createElement(\n      'h' + this.level, // h标签\n      this.$slots.default // 插槽内容\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n**注意**的是，createElement函数返回的是一个**虚拟DOM节点**（这个组件只是整个页面的一小部分），即VNode。而**虚拟DOM**则是对Vue组件树建立起来的整个VNode树的称呼。上面代码中的console会打印出如下类似内容。\n![VNode](/images/VNode_object.jpg)\n\n**注意**：createElement的参数有三个。\n1. 参数1必填，可以是String（HTML字符串）, Object（组件选项对象）, Function（解析上述类型任何一种的异步函数）。\n2. 参数2选填，Obejct，包含模板相关属性的数据对象，例如class, title等等。涉及的东西很多，查看官方文档[data对象](https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5-data-%E5%AF%B9%E8%B1%A1)\n3. 参数3选填，Array，String。子节点VNodes，**由createElmenet()函数返回一个VNode对象**，或者是字符串形式的文本节点。\n\n在上例的代码中，我们只传递的2个参数，第二个传入的参数就是createElement函数的第三个参数，一个数组，数组中是多个对象，都是由createElement()函数返回的VNode节点。类似如下\n![createElement返回的对象](/images/VNodes_createElement_return.jpg)\n\n## VNodes(子节点)必须是唯一的\n这里的唯一是指，createElement返回的VNode对象是唯一的，使用上也是唯一的，应该看做一个实例对象。而不能当做引用对象使用。\n官方示例中，如下代码，同一个对象被多次引用使用，就是错误的。\n```js\n  render: function(createElement) {\n    var onlyOneObject = createElement('p','hi'); // 参数1，p标签。参数2，字符串，子节点\n    return createElement('div', [\n      onlyOneObject, onlyOneObject // 数组中引用同一个VNodes\n    ])\n  }\n```\n\n一定需要重复渲染相同的元素/组件（即VNodes），采用工厂函数来实现。\n```js\n  render: function(createElement) {\n    return createElement('div',\n      Array.apply(null, {length: 20}).map(function(){ // apply第二个参数接受数组或类数组生成一个20个长度的数组，map该数组，返回对应的一个应用map传递函数的20长度的数组内容。即[VNodes, VNodes, ..., VNodes]\n        return createElement('p', hi)\n      })\n    )\n  }\n```\n\n## Js代替模板引擎常用的功能实现\n\n### v-if和v-for\n```html\n  <ul v-if=\"items.length\">\n    <li v-for=\"item in items\">{{item.name}}</li>\n  </ul>\n  <p v-else>No items found.</p>\n```\n\n```js\n// render函数中写法\nVue.component('forComp', {\n  render: (createElement) => {\n    if (this.items.length) {\n      return createElement('ul', this.items.map((item,index) => {\n        return createElement('li', item.name)\n      }))\n    }else{\n      return createElement('p', 'No items found')\n    }\n  },\n  props: {\n    items: {\n      type: Array,\n      required: true\n    }\n  }\n})\n```\n### v-model\n```html\n<input type=\"text\" v-model=\"enterVal\">\n```\n```js\n// render函数中写法\nVue.component('oInput', {\n  render: (createElement) => {\n    var self = this;\n    return createElement('input', {\n      // DOM属性\n      domProps: {\n        value: self.enterVal\n      },\n      // 事件监听器，基于on\n      on:{\n        input: function(event){\n          self.$emit('input', event.target.value); // 这里派发一个input事件，实际上对应应该是如下Html代码结构\n        }\n      }\n    })\n  },\n  props: {\n    enterVal: {\n      type: [String, Number],\n      required: true\n    }\n  }\n})\n```\n\n```html\n<!-- 猜测，本质上v-model应该是vue的语法糖，实现监听input事件，然后得到最新输入的值，更新视图 -->\n<input type=\"text\" v-on:input=\"\">\n```\n\n### 插槽\n```js\n  // 普通的插槽内容\n  render: function(createElement) {\n    return createElement('div', this.$slots.default)\n  }\n\n\n  // 生成带有作用域插槽的组件结构（可以传递数据的slot）\n  props: ['message'],\n  render: function(createElement) {=\n    return createElement('div', [\n      // $scopedSlots.default是一个函数，返回VNodes\n      this.$scopedSlots.default({\n        text: this.message\n      })\n    ])\n  }\n\n\n  // 向子组件中传递作用域插槽。\n  rende: function(createElement) {\n    return createElement('div', [\n      createElement('child', {\n        scopedSlots: {\n          default: function(props) {\n            return createElement('span', props.text)\n          }\n        }\n      })\n    ])\n  }\n```\n\n```html\n<!-- 上面3段渲染函数关于插槽的写法，对应的template结构应该是 -->\n  <div>\n    这里是slot的内容\n  </div>\n\n\n  <div>\n    <slot :text=\"message\"></slot>\n  </div>\n\n\n  <div>\n    <child>\n      <span slot-scope=\"props\">{{props.text}}</span>\n    </child>\n  </div>\n```\n\n## 总结\n本文主要是方便自己理解render函数究竟是做什么的，区分不同vue构建版本中使用render方式的差异，后半部分结合官方文档，了解了下render函数的其他简单用法。文章内容还是比较浅，建议大家去官方文档学习。\n","slug":"2018/render-in-vue","published":1,"updated":"2021-11-06T07:22:04.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz1000g6hufhllicf4z","content":"<p>工作和学习中大部分的vue工程都是通过vue-cli脚手架生成的，所以很少关注到vue实例创建那块，偶尔自己手写则会出现各种报错，比如该版本不包含编译器，请下载完整版本（带有编译器）的。因此趁着这个机会，详细了解了下vue的版本区别以及render函数的使用。</p>\n<h2 id=\"先认识下Vue提供的版本\"><a href=\"#先认识下Vue提供的版本\" class=\"headerlink\" title=\"先认识下Vue提供的版本\"></a>先认识下Vue提供的版本</h2><h2 id=\"完整版\"><a href=\"#完整版\" class=\"headerlink\" title=\"完整版\"></a>完整版</h2><p>包含了编译器的Vue代码。</p>\n<h2 id=\"关于runtime版本\"><a href=\"#关于runtime版本\" class=\"headerlink\" title=\"关于runtime版本\"></a>关于runtime版本</h2><p>创建Vue实例，渲染并处理虚拟DOM等的代码，不包含编译器</p>\n<h2 id=\"编译器是什么\"><a href=\"#编译器是什么\" class=\"headerlink\" title=\"编译器是什么\"></a>编译器是什么</h2><p>负责将模板字符串变异成Js渲染函数的代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建Vue实例，传入一个模板作为HTML渲染结构。需要编译器，在客户端进行模板编译的。</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过render函数进行渲染，在构建时预编译为Js代码，最终生成的bundle中不在需要编译器。</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\">h</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">&#x27;div&#x27;</span>, <span class=\"built_in\">this</span>.title)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看出来，runtime版本和完整版本，最终都是编译为Js渲染函数代码。<strong>差异</strong>就是编译一个在开发人员代码构建时（打包器打包阶段），一个在客户端上调用时编译。</p>\n<p>使用vue-cli构建的vue工程，可以看到vue实例的创建是这样的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- App.vue --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrap&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">v-nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">v-nav</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> vNav <span class=\"keyword\">from</span> <span class=\"string\">&#x27;v-nav.vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;App&#x27;</span></span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&#x27;App.vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的h实际上是createElement函数</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(App)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<p><em><strong>但是</strong></em>如果你尝试使用template来挂载模板，会报错。提示你需要完整版本</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> vComp <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./v-comp.vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;div&gt;&lt;v-nav&gt;&lt;/v-nav&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123;</span><br><span class=\"line\">    vComp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这是因为，采用webpack2+，或者parcel这类打包工具，都是引用的运行时版本<strong>node_modules\\vue\\dist\\vue.runtime.esm.js</strong>。<br>如果你一定要使用template的话，可以配置一个别名，引用vue的完整版本即可。<br>如webpack:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">resolve</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">alias</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;vue$&#x27;</span>: <span class=\"string\">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于render渲染函数\"><a href=\"#关于render渲染函数\" class=\"headerlink\" title=\"关于render渲染函数\"></a>关于render渲染函数</h2><h2 id=\"某些环境中代码更简练\"><a href=\"#某些环境中代码更简练\" class=\"headerlink\" title=\"某些环境中代码更简练\"></a>某些环境中代码更简练</h2><blockquote>\n<p>这里引用官方文档的一个例子</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 一个vue单文件 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 1&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 2&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 3&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h4</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 4&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 5&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;title&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">level</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个组件实际就是根据传递的level来决定使用的到底是h1到h5中的哪一个。虽然思路清晰，但是代码冗长。采用render函数的来重写的话。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">&#x27;heading&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">createElement</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(createElement(</span><br><span class=\"line\">      <span class=\"string\">&#x27;h&#x27;</span> + <span class=\"built_in\">this</span>.level, <span class=\"comment\">// h标签</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.$slots.default <span class=\"comment\">// 插槽内容</span></span><br><span class=\"line\">    ))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createElement(</span><br><span class=\"line\">      <span class=\"string\">&#x27;h&#x27;</span> + <span class=\"built_in\">this</span>.level, <span class=\"comment\">// h标签</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.$slots.default <span class=\"comment\">// 插槽内容</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">level</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>的是，createElement函数返回的是一个<strong>虚拟DOM节点</strong>（这个组件只是整个页面的一小部分），即VNode。而<strong>虚拟DOM</strong>则是对Vue组件树建立起来的整个VNode树的称呼。上面代码中的console会打印出如下类似内容。<br><img src=\"/images/VNode_object.jpg\" alt=\"VNode\"></p>\n<p><strong>注意</strong>：createElement的参数有三个。</p>\n<ol>\n<li>参数1必填，可以是String（HTML字符串）, Object（组件选项对象）, Function（解析上述类型任何一种的异步函数）。</li>\n<li>参数2选填，Obejct，包含模板相关属性的数据对象，例如class, title等等。涉及的东西很多，查看官方文档<a href=\"https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5-data-%E5%AF%B9%E8%B1%A1\">data对象</a></li>\n<li>参数3选填，Array，String。子节点VNodes，<strong>由createElmenet()函数返回一个VNode对象</strong>，或者是字符串形式的文本节点。</li>\n</ol>\n<p>在上例的代码中，我们只传递的2个参数，第二个传入的参数就是createElement函数的第三个参数，一个数组，数组中是多个对象，都是由createElement()函数返回的VNode节点。类似如下<br><img src=\"/images/VNodes_createElement_return.jpg\" alt=\"createElement返回的对象\"></p>\n<h2 id=\"VNodes-子节点-必须是唯一的\"><a href=\"#VNodes-子节点-必须是唯一的\" class=\"headerlink\" title=\"VNodes(子节点)必须是唯一的\"></a>VNodes(子节点)必须是唯一的</h2><p>这里的唯一是指，createElement返回的VNode对象是唯一的，使用上也是唯一的，应该看做一个实例对象。而不能当做引用对象使用。<br>官方示例中，如下代码，同一个对象被多次引用使用，就是错误的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> onlyOneObject = createElement(<span class=\"string\">&#x27;p&#x27;</span>,<span class=\"string\">&#x27;hi&#x27;</span>); <span class=\"comment\">// 参数1，p标签。参数2，字符串，子节点</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, [</span><br><span class=\"line\">    onlyOneObject, onlyOneObject <span class=\"comment\">// 数组中引用同一个VNodes</span></span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一定需要重复渲染相同的元素/组件（即VNodes），采用工厂函数来实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.apply(<span class=\"literal\">null</span>, &#123;<span class=\"attr\">length</span>: <span class=\"number\">20</span>&#125;).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// apply第二个参数接受数组或类数组生成一个20个长度的数组，map该数组，返回对应的一个应用map传递函数的20长度的数组内容。即[VNodes, VNodes, ..., VNodes]</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;p&#x27;</span>, hi)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Js代替模板引擎常用的功能实现\"><a href=\"#Js代替模板引擎常用的功能实现\" class=\"headerlink\" title=\"Js代替模板引擎常用的功能实现\"></a>Js代替模板引擎常用的功能实现</h2><h3 id=\"v-if和v-for\"><a href=\"#v-if和v-for\" class=\"headerlink\" title=\"v-if和v-for\"></a>v-if和v-for</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;items.length&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// render函数中写法</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">&#x27;forComp&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">createElement</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.items.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;ul&#x27;</span>, <span class=\"built_in\">this</span>.items.map(<span class=\"function\">(<span class=\"params\">item,index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;li&#x27;</span>, item.name)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;p&#x27;</span>, <span class=\"string\">&#x27;No items found&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">items</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Array</span>,</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;enterVal&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// render函数中写法</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">&#x27;oInput&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">createElement</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;input&#x27;</span>, &#123;</span><br><span class=\"line\">      <span class=\"comment\">// DOM属性</span></span><br><span class=\"line\">      <span class=\"attr\">domProps</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">value</span>: self.enterVal</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 事件监听器，基于on</span></span><br><span class=\"line\">      <span class=\"attr\">on</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">input</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">          self.$emit(<span class=\"string\">&#x27;input&#x27;</span>, event.target.value); <span class=\"comment\">// 这里派发一个input事件，实际上对应应该是如下Html代码结构</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">enterVal</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: [<span class=\"built_in\">String</span>, <span class=\"built_in\">Number</span>],</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 猜测，本质上v-model应该是vue的语法糖，实现监听input事件，然后得到最新输入的值，更新视图 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插槽\"><a href=\"#插槽\" class=\"headerlink\" title=\"插槽\"></a>插槽</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通的插槽内容</span></span><br><span class=\"line\"><span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, <span class=\"built_in\">this</span>.$slots.default)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成带有作用域插槽的组件结构（可以传递数据的slot）</span></span><br><span class=\"line\"><span class=\"attr\">props</span>: [<span class=\"string\">&#x27;message&#x27;</span>],</span><br><span class=\"line\"><span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;=</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, [</span><br><span class=\"line\">    <span class=\"comment\">// $scopedSlots.default是一个函数，返回VNodes</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.$scopedSlots.default(&#123;</span><br><span class=\"line\">      <span class=\"attr\">text</span>: <span class=\"built_in\">this</span>.message</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向子组件中传递作用域插槽。</span></span><br><span class=\"line\"><span class=\"attr\">rende</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, [</span><br><span class=\"line\">    createElement(<span class=\"string\">&#x27;child&#x27;</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">scopedSlots</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;span&#x27;</span>, props.text)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 上面3段渲染函数关于插槽的写法，对应的template结构应该是 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    这里是slot的内容</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">:text</span>=<span class=\"string\">&quot;message&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">slot-scope</span>=<span class=\"string\">&quot;props&quot;</span>&gt;</span>&#123;&#123;props.text&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要是方便自己理解render函数究竟是做什么的，区分不同vue构建版本中使用render方式的差异，后半部分结合官方文档，了解了下render函数的其他简单用法。文章内容还是比较浅，建议大家去官方文档学习。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>工作和学习中大部分的vue工程都是通过vue-cli脚手架生成的，所以很少关注到vue实例创建那块，偶尔自己手写则会出现各种报错，比如该版本不包含编译器，请下载完整版本（带有编译器）的。因此趁着这个机会，详细了解了下vue的版本区别以及render函数的使用。</p>\n<h2 id=\"先认识下Vue提供的版本\"><a href=\"#先认识下Vue提供的版本\" class=\"headerlink\" title=\"先认识下Vue提供的版本\"></a>先认识下Vue提供的版本</h2><h2 id=\"完整版\"><a href=\"#完整版\" class=\"headerlink\" title=\"完整版\"></a>完整版</h2><p>包含了编译器的Vue代码。</p>\n<h2 id=\"关于runtime版本\"><a href=\"#关于runtime版本\" class=\"headerlink\" title=\"关于runtime版本\"></a>关于runtime版本</h2><p>创建Vue实例，渲染并处理虚拟DOM等的代码，不包含编译器</p>\n<h2 id=\"编译器是什么\"><a href=\"#编译器是什么\" class=\"headerlink\" title=\"编译器是什么\"></a>编译器是什么</h2><p>负责将模板字符串变异成Js渲染函数的代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建Vue实例，传入一个模板作为HTML渲染结构。需要编译器，在客户端进行模板编译的。</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过render函数进行渲染，在构建时预编译为Js代码，最终生成的bundle中不在需要编译器。</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\">h</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">&#x27;div&#x27;</span>, <span class=\"built_in\">this</span>.title)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看出来，runtime版本和完整版本，最终都是编译为Js渲染函数代码。<strong>差异</strong>就是编译一个在开发人员代码构建时（打包器打包阶段），一个在客户端上调用时编译。</p>\n<p>使用vue-cli构建的vue工程，可以看到vue实例的创建是这样的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- App.vue --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrap&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">v-nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">v-nav</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">import</span> vNav <span class=\"keyword\">from</span> <span class=\"string\">&#x27;v-nav.vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;App&#x27;</span></span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&#x27;App.vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的h实际上是createElement函数</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(App)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<p><em><strong>但是</strong></em>如果你尝试使用template来挂载模板，会报错。提示你需要完整版本</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> vComp <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./v-comp.vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;div&gt;&lt;v-nav&gt;&lt;/v-nav&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123;</span><br><span class=\"line\">    vComp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这是因为，采用webpack2+，或者parcel这类打包工具，都是引用的运行时版本<strong>node_modules\\vue\\dist\\vue.runtime.esm.js</strong>。<br>如果你一定要使用template的话，可以配置一个别名，引用vue的完整版本即可。<br>如webpack:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">resolve</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">alias</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;vue$&#x27;</span>: <span class=\"string\">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于render渲染函数\"><a href=\"#关于render渲染函数\" class=\"headerlink\" title=\"关于render渲染函数\"></a>关于render渲染函数</h2><h2 id=\"某些环境中代码更简练\"><a href=\"#某些环境中代码更简练\" class=\"headerlink\" title=\"某些环境中代码更简练\"></a>某些环境中代码更简练</h2><blockquote>\n<p>这里引用官方文档的一个例子</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 一个vue单文件 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 1&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 2&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 3&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h4</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 4&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;level === 5&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;title&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">level</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个组件实际就是根据传递的level来决定使用的到底是h1到h5中的哪一个。虽然思路清晰，但是代码冗长。采用render函数的来重写的话。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">&#x27;heading&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">createElement</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(createElement(</span><br><span class=\"line\">      <span class=\"string\">&#x27;h&#x27;</span> + <span class=\"built_in\">this</span>.level, <span class=\"comment\">// h标签</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.$slots.default <span class=\"comment\">// 插槽内容</span></span><br><span class=\"line\">    ))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createElement(</span><br><span class=\"line\">      <span class=\"string\">&#x27;h&#x27;</span> + <span class=\"built_in\">this</span>.level, <span class=\"comment\">// h标签</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.$slots.default <span class=\"comment\">// 插槽内容</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">level</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>的是，createElement函数返回的是一个<strong>虚拟DOM节点</strong>（这个组件只是整个页面的一小部分），即VNode。而<strong>虚拟DOM</strong>则是对Vue组件树建立起来的整个VNode树的称呼。上面代码中的console会打印出如下类似内容。<br><img src=\"/images/VNode_object.jpg\" alt=\"VNode\"></p>\n<p><strong>注意</strong>：createElement的参数有三个。</p>\n<ol>\n<li>参数1必填，可以是String（HTML字符串）, Object（组件选项对象）, Function（解析上述类型任何一种的异步函数）。</li>\n<li>参数2选填，Obejct，包含模板相关属性的数据对象，例如class, title等等。涉及的东西很多，查看官方文档<a href=\"https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5-data-%E5%AF%B9%E8%B1%A1\">data对象</a></li>\n<li>参数3选填，Array，String。子节点VNodes，<strong>由createElmenet()函数返回一个VNode对象</strong>，或者是字符串形式的文本节点。</li>\n</ol>\n<p>在上例的代码中，我们只传递的2个参数，第二个传入的参数就是createElement函数的第三个参数，一个数组，数组中是多个对象，都是由createElement()函数返回的VNode节点。类似如下<br><img src=\"/images/VNodes_createElement_return.jpg\" alt=\"createElement返回的对象\"></p>\n<h2 id=\"VNodes-子节点-必须是唯一的\"><a href=\"#VNodes-子节点-必须是唯一的\" class=\"headerlink\" title=\"VNodes(子节点)必须是唯一的\"></a>VNodes(子节点)必须是唯一的</h2><p>这里的唯一是指，createElement返回的VNode对象是唯一的，使用上也是唯一的，应该看做一个实例对象。而不能当做引用对象使用。<br>官方示例中，如下代码，同一个对象被多次引用使用，就是错误的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> onlyOneObject = createElement(<span class=\"string\">&#x27;p&#x27;</span>,<span class=\"string\">&#x27;hi&#x27;</span>); <span class=\"comment\">// 参数1，p标签。参数2，字符串，子节点</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, [</span><br><span class=\"line\">    onlyOneObject, onlyOneObject <span class=\"comment\">// 数组中引用同一个VNodes</span></span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一定需要重复渲染相同的元素/组件（即VNodes），采用工厂函数来实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.apply(<span class=\"literal\">null</span>, &#123;<span class=\"attr\">length</span>: <span class=\"number\">20</span>&#125;).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// apply第二个参数接受数组或类数组生成一个20个长度的数组，map该数组，返回对应的一个应用map传递函数的20长度的数组内容。即[VNodes, VNodes, ..., VNodes]</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;p&#x27;</span>, hi)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Js代替模板引擎常用的功能实现\"><a href=\"#Js代替模板引擎常用的功能实现\" class=\"headerlink\" title=\"Js代替模板引擎常用的功能实现\"></a>Js代替模板引擎常用的功能实现</h2><h3 id=\"v-if和v-for\"><a href=\"#v-if和v-for\" class=\"headerlink\" title=\"v-if和v-for\"></a>v-if和v-for</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;items.length&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No items found.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// render函数中写法</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">&#x27;forComp&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">createElement</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.items.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;ul&#x27;</span>, <span class=\"built_in\">this</span>.items.map(<span class=\"function\">(<span class=\"params\">item,index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;li&#x27;</span>, item.name)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;p&#x27;</span>, <span class=\"string\">&#x27;No items found&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">items</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Array</span>,</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;enterVal&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// render函数中写法</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">&#x27;oInput&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">createElement</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;input&#x27;</span>, &#123;</span><br><span class=\"line\">      <span class=\"comment\">// DOM属性</span></span><br><span class=\"line\">      <span class=\"attr\">domProps</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">value</span>: self.enterVal</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 事件监听器，基于on</span></span><br><span class=\"line\">      <span class=\"attr\">on</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">input</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">          self.$emit(<span class=\"string\">&#x27;input&#x27;</span>, event.target.value); <span class=\"comment\">// 这里派发一个input事件，实际上对应应该是如下Html代码结构</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">enterVal</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: [<span class=\"built_in\">String</span>, <span class=\"built_in\">Number</span>],</span><br><span class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 猜测，本质上v-model应该是vue的语法糖，实现监听input事件，然后得到最新输入的值，更新视图 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插槽\"><a href=\"#插槽\" class=\"headerlink\" title=\"插槽\"></a>插槽</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通的插槽内容</span></span><br><span class=\"line\"><span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, <span class=\"built_in\">this</span>.$slots.default)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成带有作用域插槽的组件结构（可以传递数据的slot）</span></span><br><span class=\"line\"><span class=\"attr\">props</span>: [<span class=\"string\">&#x27;message&#x27;</span>],</span><br><span class=\"line\"><span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;=</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, [</span><br><span class=\"line\">    <span class=\"comment\">// $scopedSlots.default是一个函数，返回VNodes</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.$scopedSlots.default(&#123;</span><br><span class=\"line\">      <span class=\"attr\">text</span>: <span class=\"built_in\">this</span>.message</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向子组件中传递作用域插槽。</span></span><br><span class=\"line\"><span class=\"attr\">rende</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;div&#x27;</span>, [</span><br><span class=\"line\">    createElement(<span class=\"string\">&#x27;child&#x27;</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">scopedSlots</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">default</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> createElement(<span class=\"string\">&#x27;span&#x27;</span>, props.text)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 上面3段渲染函数关于插槽的写法，对应的template结构应该是 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    这里是slot的内容</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">:text</span>=<span class=\"string\">&quot;message&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">slot-scope</span>=<span class=\"string\">&quot;props&quot;</span>&gt;</span>&#123;&#123;props.text&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要是方便自己理解render函数究竟是做什么的，区分不同vue构建版本中使用render方式的差异，后半部分结合官方文档，了解了下render函数的其他简单用法。文章内容还是比较浅，建议大家去官方文档学习。</p>\n"},{"title":"进程，线程","date":"2018-12-29T16:00:00.000Z","_content":"\n本篇主要先了解浏览器的进程和线程，为事件循环的内容做铺垫。\n\n## 进程\n简单点理解，可以独立运行的程序一次执行的过程。看作是一个工厂，工厂之间一般都是独立的，各干各的。\n\n## 线程\n归进程管辖，也能拥有资源，独立运行。进程里可以有多个线程。看作是工厂里的工人，很多工人。\n\n## 内存\n按我自己的理解，电脑硬盘只负责存储内容，如果开个游戏，会把游戏内容读取出来放到内存里面去跑，这样我们才能玩。\n\n## 三者关系\n一个工厂（**进程**）有自己的的地盘（**分配的内存空间**），工厂里有很多工人（**线程**），工人们在同一个工厂干活，可以共享这个工厂的大部分公共空间，比如厕所，食堂，宿舍。\n\n## 浏览器的进程\n浏览器是多进程的，一个tab就是个进程，还有插件，一个激活使用的插件也占一个进程。因为进程之间相互独立，所以某一个崩了，不会影响其他的进程。\n\n## 浏览器最重要的进程——浏览器内核\n内核也是多线程的，一个tab选项卡有一个自己的内核（Chrome应该是指V8引擎）。内核有一般有如下常驻线程：\n* GUI渲染线程\n* Javascript引擎线程（通常说的单线程指的就是它）\n* 定时器触发器线程\n* 事件触发线程\n* 异步Http请求线程\n\n### GUI渲染引擎\n渲染浏览器界面的HTML元素，当界面需要**重绘**和**回流**时，该线程就会执行。**该线程和Javascript引擎线程互斥。**\n\n### Javascript引擎线程（主线程）\n解释JS脚本的。通常说的JS是单线程的，就是由此而来。为啥是单线程？为了简单！假设有这么个情况（多线程），两个人（JS引擎线程假如有2个）同时拿枪指着你的脑袋（DOM元素），一个让你站着（插入），一个让你趴着（删除），你到底听谁的？**该线程和GUI渲染引擎互斥。**\n\n>GUI渲染线程和Javascript引擎线程为什么互斥？\n因为前者是渲染HTML（DOM和CSS），后者是可以操作DOM和CSS的。如果同时运行，会造成GUI渲染线程绘制元素数据前后表现不一致。所以这2个线程，一定是一个被挂起，另一个在运行。JS操作时，GUI渲染挂起，更新的内容保存在一个队列中，等JS空闲了再执行GUI渲染。\n\n>JS会阻塞页面加载，2个线程互斥，大量且复杂的JS代码，会让JS引擎运行时间变长，导致GUI渲染挂起，一直等待JS引擎空闲才回去渲染。\n\n### 定时触发器线程\n浏览器的定时器***setTimeout***和***setInterval***，JS引擎线程并不负责定时器的计时，可想而知，JS引擎如果一直在倒计时数数，其他代码就无法运行了，阻塞整个代码的运行。事实上，定时器是异步的，就是因为JS引擎线程并没有管他们，而是交由定时触发器线程在计时。\n\n### 事件触发线程\n比如***click***事件，当点击事件触发时，该线程会把事件处理函数放到消息队列的队尾，等待JS引擎按顺序处理点击事件的回调函数。\n>个人以为是只响应DOM事件，不过看网上大多数文章（基本都是同样内容copy，没啥深入的），时间出发线程还管辖了ajax事件和定时器事件的触发。有个疑问，已经有了定时触发器线程和异步Http请求线程，为啥事件触发线程还会跟ajax事件和定时器事件挂钩？（8月17日自答，考虑下Node里面的Event核心模块，Node是基于事件的，其他模块基本都继承了Event模块。类比这里，ajax事件和定时器事件也应该交由（继承自）事件触发线程来统一处理）\n\n### 异步http请求线程\n顾名思义，发送XMLHttpRequest连接的，连接发出后，浏览器新开一个线程来管理发出的请求，当请求回来或者挂掉，状态变更，如果设置了回调函数，该线程就会产生状态变更事件放到JS引擎的处理队列的队尾等待处理。\n","source":"_posts/2018/thread-process.md","raw":"---\ntitle: 进程，线程\ndate: 2018/12/30\n---\n\n本篇主要先了解浏览器的进程和线程，为事件循环的内容做铺垫。\n\n## 进程\n简单点理解，可以独立运行的程序一次执行的过程。看作是一个工厂，工厂之间一般都是独立的，各干各的。\n\n## 线程\n归进程管辖，也能拥有资源，独立运行。进程里可以有多个线程。看作是工厂里的工人，很多工人。\n\n## 内存\n按我自己的理解，电脑硬盘只负责存储内容，如果开个游戏，会把游戏内容读取出来放到内存里面去跑，这样我们才能玩。\n\n## 三者关系\n一个工厂（**进程**）有自己的的地盘（**分配的内存空间**），工厂里有很多工人（**线程**），工人们在同一个工厂干活，可以共享这个工厂的大部分公共空间，比如厕所，食堂，宿舍。\n\n## 浏览器的进程\n浏览器是多进程的，一个tab就是个进程，还有插件，一个激活使用的插件也占一个进程。因为进程之间相互独立，所以某一个崩了，不会影响其他的进程。\n\n## 浏览器最重要的进程——浏览器内核\n内核也是多线程的，一个tab选项卡有一个自己的内核（Chrome应该是指V8引擎）。内核有一般有如下常驻线程：\n* GUI渲染线程\n* Javascript引擎线程（通常说的单线程指的就是它）\n* 定时器触发器线程\n* 事件触发线程\n* 异步Http请求线程\n\n### GUI渲染引擎\n渲染浏览器界面的HTML元素，当界面需要**重绘**和**回流**时，该线程就会执行。**该线程和Javascript引擎线程互斥。**\n\n### Javascript引擎线程（主线程）\n解释JS脚本的。通常说的JS是单线程的，就是由此而来。为啥是单线程？为了简单！假设有这么个情况（多线程），两个人（JS引擎线程假如有2个）同时拿枪指着你的脑袋（DOM元素），一个让你站着（插入），一个让你趴着（删除），你到底听谁的？**该线程和GUI渲染引擎互斥。**\n\n>GUI渲染线程和Javascript引擎线程为什么互斥？\n因为前者是渲染HTML（DOM和CSS），后者是可以操作DOM和CSS的。如果同时运行，会造成GUI渲染线程绘制元素数据前后表现不一致。所以这2个线程，一定是一个被挂起，另一个在运行。JS操作时，GUI渲染挂起，更新的内容保存在一个队列中，等JS空闲了再执行GUI渲染。\n\n>JS会阻塞页面加载，2个线程互斥，大量且复杂的JS代码，会让JS引擎运行时间变长，导致GUI渲染挂起，一直等待JS引擎空闲才回去渲染。\n\n### 定时触发器线程\n浏览器的定时器***setTimeout***和***setInterval***，JS引擎线程并不负责定时器的计时，可想而知，JS引擎如果一直在倒计时数数，其他代码就无法运行了，阻塞整个代码的运行。事实上，定时器是异步的，就是因为JS引擎线程并没有管他们，而是交由定时触发器线程在计时。\n\n### 事件触发线程\n比如***click***事件，当点击事件触发时，该线程会把事件处理函数放到消息队列的队尾，等待JS引擎按顺序处理点击事件的回调函数。\n>个人以为是只响应DOM事件，不过看网上大多数文章（基本都是同样内容copy，没啥深入的），时间出发线程还管辖了ajax事件和定时器事件的触发。有个疑问，已经有了定时触发器线程和异步Http请求线程，为啥事件触发线程还会跟ajax事件和定时器事件挂钩？（8月17日自答，考虑下Node里面的Event核心模块，Node是基于事件的，其他模块基本都继承了Event模块。类比这里，ajax事件和定时器事件也应该交由（继承自）事件触发线程来统一处理）\n\n### 异步http请求线程\n顾名思义，发送XMLHttpRequest连接的，连接发出后，浏览器新开一个线程来管理发出的请求，当请求回来或者挂掉，状态变更，如果设置了回调函数，该线程就会产生状态变更事件放到JS引擎的处理队列的队尾等待处理。\n","slug":"2018/thread-process","published":1,"updated":"2021-11-06T07:22:06.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz1000h6huf8tgy38lz","content":"<p>本篇主要先了解浏览器的进程和线程，为事件循环的内容做铺垫。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>简单点理解，可以独立运行的程序一次执行的过程。看作是一个工厂，工厂之间一般都是独立的，各干各的。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>归进程管辖，也能拥有资源，独立运行。进程里可以有多个线程。看作是工厂里的工人，很多工人。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>按我自己的理解，电脑硬盘只负责存储内容，如果开个游戏，会把游戏内容读取出来放到内存里面去跑，这样我们才能玩。</p>\n<h2 id=\"三者关系\"><a href=\"#三者关系\" class=\"headerlink\" title=\"三者关系\"></a>三者关系</h2><p>一个工厂（<strong>进程</strong>）有自己的的地盘（<strong>分配的内存空间</strong>），工厂里有很多工人（<strong>线程</strong>），工人们在同一个工厂干活，可以共享这个工厂的大部分公共空间，比如厕所，食堂，宿舍。</p>\n<h2 id=\"浏览器的进程\"><a href=\"#浏览器的进程\" class=\"headerlink\" title=\"浏览器的进程\"></a>浏览器的进程</h2><p>浏览器是多进程的，一个tab就是个进程，还有插件，一个激活使用的插件也占一个进程。因为进程之间相互独立，所以某一个崩了，不会影响其他的进程。</p>\n<h2 id=\"浏览器最重要的进程——浏览器内核\"><a href=\"#浏览器最重要的进程——浏览器内核\" class=\"headerlink\" title=\"浏览器最重要的进程——浏览器内核\"></a>浏览器最重要的进程——浏览器内核</h2><p>内核也是多线程的，一个tab选项卡有一个自己的内核（Chrome应该是指V8引擎）。内核有一般有如下常驻线程：</p>\n<ul>\n<li>GUI渲染线程</li>\n<li>Javascript引擎线程（通常说的单线程指的就是它）</li>\n<li>定时器触发器线程</li>\n<li>事件触发线程</li>\n<li>异步Http请求线程</li>\n</ul>\n<h3 id=\"GUI渲染引擎\"><a href=\"#GUI渲染引擎\" class=\"headerlink\" title=\"GUI渲染引擎\"></a>GUI渲染引擎</h3><p>渲染浏览器界面的HTML元素，当界面需要<strong>重绘</strong>和<strong>回流</strong>时，该线程就会执行。<strong>该线程和Javascript引擎线程互斥。</strong></p>\n<h3 id=\"Javascript引擎线程（主线程）\"><a href=\"#Javascript引擎线程（主线程）\" class=\"headerlink\" title=\"Javascript引擎线程（主线程）\"></a>Javascript引擎线程（主线程）</h3><p>解释JS脚本的。通常说的JS是单线程的，就是由此而来。为啥是单线程？为了简单！假设有这么个情况（多线程），两个人（JS引擎线程假如有2个）同时拿枪指着你的脑袋（DOM元素），一个让你站着（插入），一个让你趴着（删除），你到底听谁的？<strong>该线程和GUI渲染引擎互斥。</strong></p>\n<blockquote>\n<p>GUI渲染线程和Javascript引擎线程为什么互斥？<br>因为前者是渲染HTML（DOM和CSS），后者是可以操作DOM和CSS的。如果同时运行，会造成GUI渲染线程绘制元素数据前后表现不一致。所以这2个线程，一定是一个被挂起，另一个在运行。JS操作时，GUI渲染挂起，更新的内容保存在一个队列中，等JS空闲了再执行GUI渲染。</p>\n</blockquote>\n<blockquote>\n<p>JS会阻塞页面加载，2个线程互斥，大量且复杂的JS代码，会让JS引擎运行时间变长，导致GUI渲染挂起，一直等待JS引擎空闲才回去渲染。</p>\n</blockquote>\n<h3 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h3><p>浏览器的定时器<em><strong>setTimeout</strong></em>和<em><strong>setInterval</strong></em>，JS引擎线程并不负责定时器的计时，可想而知，JS引擎如果一直在倒计时数数，其他代码就无法运行了，阻塞整个代码的运行。事实上，定时器是异步的，就是因为JS引擎线程并没有管他们，而是交由定时触发器线程在计时。</p>\n<h3 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h3><p>比如<em><strong>click</strong></em>事件，当点击事件触发时，该线程会把事件处理函数放到消息队列的队尾，等待JS引擎按顺序处理点击事件的回调函数。</p>\n<blockquote>\n<p>个人以为是只响应DOM事件，不过看网上大多数文章（基本都是同样内容copy，没啥深入的），时间出发线程还管辖了ajax事件和定时器事件的触发。有个疑问，已经有了定时触发器线程和异步Http请求线程，为啥事件触发线程还会跟ajax事件和定时器事件挂钩？（8月17日自答，考虑下Node里面的Event核心模块，Node是基于事件的，其他模块基本都继承了Event模块。类比这里，ajax事件和定时器事件也应该交由（继承自）事件触发线程来统一处理）</p>\n</blockquote>\n<h3 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步http请求线程</h3><p>顾名思义，发送XMLHttpRequest连接的，连接发出后，浏览器新开一个线程来管理发出的请求，当请求回来或者挂掉，状态变更，如果设置了回调函数，该线程就会产生状态变更事件放到JS引擎的处理队列的队尾等待处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇主要先了解浏览器的进程和线程，为事件循环的内容做铺垫。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>简单点理解，可以独立运行的程序一次执行的过程。看作是一个工厂，工厂之间一般都是独立的，各干各的。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>归进程管辖，也能拥有资源，独立运行。进程里可以有多个线程。看作是工厂里的工人，很多工人。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>按我自己的理解，电脑硬盘只负责存储内容，如果开个游戏，会把游戏内容读取出来放到内存里面去跑，这样我们才能玩。</p>\n<h2 id=\"三者关系\"><a href=\"#三者关系\" class=\"headerlink\" title=\"三者关系\"></a>三者关系</h2><p>一个工厂（<strong>进程</strong>）有自己的的地盘（<strong>分配的内存空间</strong>），工厂里有很多工人（<strong>线程</strong>），工人们在同一个工厂干活，可以共享这个工厂的大部分公共空间，比如厕所，食堂，宿舍。</p>\n<h2 id=\"浏览器的进程\"><a href=\"#浏览器的进程\" class=\"headerlink\" title=\"浏览器的进程\"></a>浏览器的进程</h2><p>浏览器是多进程的，一个tab就是个进程，还有插件，一个激活使用的插件也占一个进程。因为进程之间相互独立，所以某一个崩了，不会影响其他的进程。</p>\n<h2 id=\"浏览器最重要的进程——浏览器内核\"><a href=\"#浏览器最重要的进程——浏览器内核\" class=\"headerlink\" title=\"浏览器最重要的进程——浏览器内核\"></a>浏览器最重要的进程——浏览器内核</h2><p>内核也是多线程的，一个tab选项卡有一个自己的内核（Chrome应该是指V8引擎）。内核有一般有如下常驻线程：</p>\n<ul>\n<li>GUI渲染线程</li>\n<li>Javascript引擎线程（通常说的单线程指的就是它）</li>\n<li>定时器触发器线程</li>\n<li>事件触发线程</li>\n<li>异步Http请求线程</li>\n</ul>\n<h3 id=\"GUI渲染引擎\"><a href=\"#GUI渲染引擎\" class=\"headerlink\" title=\"GUI渲染引擎\"></a>GUI渲染引擎</h3><p>渲染浏览器界面的HTML元素，当界面需要<strong>重绘</strong>和<strong>回流</strong>时，该线程就会执行。<strong>该线程和Javascript引擎线程互斥。</strong></p>\n<h3 id=\"Javascript引擎线程（主线程）\"><a href=\"#Javascript引擎线程（主线程）\" class=\"headerlink\" title=\"Javascript引擎线程（主线程）\"></a>Javascript引擎线程（主线程）</h3><p>解释JS脚本的。通常说的JS是单线程的，就是由此而来。为啥是单线程？为了简单！假设有这么个情况（多线程），两个人（JS引擎线程假如有2个）同时拿枪指着你的脑袋（DOM元素），一个让你站着（插入），一个让你趴着（删除），你到底听谁的？<strong>该线程和GUI渲染引擎互斥。</strong></p>\n<blockquote>\n<p>GUI渲染线程和Javascript引擎线程为什么互斥？<br>因为前者是渲染HTML（DOM和CSS），后者是可以操作DOM和CSS的。如果同时运行，会造成GUI渲染线程绘制元素数据前后表现不一致。所以这2个线程，一定是一个被挂起，另一个在运行。JS操作时，GUI渲染挂起，更新的内容保存在一个队列中，等JS空闲了再执行GUI渲染。</p>\n</blockquote>\n<blockquote>\n<p>JS会阻塞页面加载，2个线程互斥，大量且复杂的JS代码，会让JS引擎运行时间变长，导致GUI渲染挂起，一直等待JS引擎空闲才回去渲染。</p>\n</blockquote>\n<h3 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h3><p>浏览器的定时器<em><strong>setTimeout</strong></em>和<em><strong>setInterval</strong></em>，JS引擎线程并不负责定时器的计时，可想而知，JS引擎如果一直在倒计时数数，其他代码就无法运行了，阻塞整个代码的运行。事实上，定时器是异步的，就是因为JS引擎线程并没有管他们，而是交由定时触发器线程在计时。</p>\n<h3 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h3><p>比如<em><strong>click</strong></em>事件，当点击事件触发时，该线程会把事件处理函数放到消息队列的队尾，等待JS引擎按顺序处理点击事件的回调函数。</p>\n<blockquote>\n<p>个人以为是只响应DOM事件，不过看网上大多数文章（基本都是同样内容copy，没啥深入的），时间出发线程还管辖了ajax事件和定时器事件的触发。有个疑问，已经有了定时触发器线程和异步Http请求线程，为啥事件触发线程还会跟ajax事件和定时器事件挂钩？（8月17日自答，考虑下Node里面的Event核心模块，Node是基于事件的，其他模块基本都继承了Event模块。类比这里，ajax事件和定时器事件也应该交由（继承自）事件触发线程来统一处理）</p>\n</blockquote>\n<h3 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步http请求线程</h3><p>顾名思义，发送XMLHttpRequest连接的，连接发出后，浏览器新开一个线程来管理发出的请求，当请求回来或者挂掉，状态变更，如果设置了回调函数，该线程就会产生状态变更事件放到JS引擎的处理队列的队尾等待处理。</p>\n"},{"title":"JS原型和继承","date":"2020-12-29T16:00:00.000Z","_content":"\n初步介绍下原型和继承，以及相关的 API.\n\n## 原型是什么\n\n所有的对象（包括函数）都有一个隐藏的内部属性`[[Prototype]]`，该属性引用的就是**原型**，原型本身也是一个对象，所以原型自己也有原型。\n\n## 原型长什么样\n\n因为`[[Prototype]]`是内部属性，所以通过代码无法访问，但是我们有其他方式访问到原型。\n\n### 构造函数才有的 prototype\n\n这是 JS 早期就有的属性，**只有函数才有，字面量对象是没有的**，可以在控制台尝试访问一个字面量对象的`prototype`，发现是`undefined`。所以这个功能有限。\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nconsole.log(Person.prototype);\n```\n\n结果如图：\n![prototype](/images/Jietu20200525-160258.jpg)\n\n### \\_\\_proto\\_\\_\n\n2012 年，`Object.create()`被写入标准，提供了使用给定原型创建对象的能力，然后还是没有提供`set/get`原型的能力，浏览器厂商们因此实现了非标准的`__proto__`访问器属性，允许用户随时修改和获取原型对象。\n\n```js\nvar a = {};\nconsole.log(a.__proto__);\n\nfunction b() {}\nconsole.log(b.__proto__);\n```\n\n结果如图：\n![prototype](/images/Jietu20200525-170153.jpg)\n\n### 标准方法 Object.getPrototypeOf 和 Object.setPrototypeOf\n\n2015 年，这 2 个方法被加入到标准中。但是因为`__proto__`在很多浏览器都得到了实现，即便过时，但也被加入到标准的附件中了。\n\n```js\nvar a = {};\nObject.getPrototypeOf(a);\n```\n\n结果如图\n![prototype](/images/Jietu20200525-170710.jpg)\n\n总结：从上面的几个代码案例看出来，我们所打印的**原型就是对象**。\n\n## 原型的作用\n\n当我们想要访问一个对象的属性时，先从对象自身查找，如果没有，会去对象的私有属性`[[Prototype]]` 所引用的原型对象上去找。\n\n```js\nvar parent = {\n  run: true,\n};\n\nvar son = {};\n\nObject.setPrototypeOf(son, parent); // 等于 son.__proto__ = parent\n\nson.run; // true son对象本身没有run属性，所以会沿着[[Prototype]]指向的原型对象上去找\n```\n\n这个特性可以让我们复用逻辑，实现面向对象语言中的 **继承** 特性。\n\n## JS 中的继承\n\nJS 中的继承是通过`[[Prototype]]`来实现的，即便在 ES6 时代有了`class`关键字。\n\n早期的函数方式继承：\n\n```js\nfunction Person() {\n  this.run = true;\n}\n\nfunction Son() {}\n\nSon.prototype = new Person();\n\nvar son = new Son();\nson.run; // true\n```\n\n使用 es6 关键字`class`实现\n\n```js\nclass Parent {\n  constructor() {\n    this.run = true;\n  }\n}\n\nclass Son extends Parent {\n  constructor() {\n    super();\n  }\n}\n\nconst son = new Son();\nson.run;\n```\n\n# 总结\n\n原型是一个对象的内部属性`[[Prototype]]`所引用的一个对象。从 JS 诞生开始，就有`F.prototype`的方式可以访问到原型，和修改原型，但是只有函数才有`prototype`，后来浏览器厂商自己实现了`__proto__`访问器属性来实现对原型的`set/get`，直到 ES 标准规定了原型的访问和设置的方法`Object.getPrototypeOf`和`Object.setPrototypeOf`。\n\n原型存在的最大作用是**继承**，JS 中的继承都是**原型继承**，从以前的`函数继承`到现在的`class`类语法糖来实现继承。\n","source":"_posts/2020/原型和继承初识.md","raw":"---\ntitle: JS原型和继承\ndate: 2020/12/30\n---\n\n初步介绍下原型和继承，以及相关的 API.\n\n## 原型是什么\n\n所有的对象（包括函数）都有一个隐藏的内部属性`[[Prototype]]`，该属性引用的就是**原型**，原型本身也是一个对象，所以原型自己也有原型。\n\n## 原型长什么样\n\n因为`[[Prototype]]`是内部属性，所以通过代码无法访问，但是我们有其他方式访问到原型。\n\n### 构造函数才有的 prototype\n\n这是 JS 早期就有的属性，**只有函数才有，字面量对象是没有的**，可以在控制台尝试访问一个字面量对象的`prototype`，发现是`undefined`。所以这个功能有限。\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nconsole.log(Person.prototype);\n```\n\n结果如图：\n![prototype](/images/Jietu20200525-160258.jpg)\n\n### \\_\\_proto\\_\\_\n\n2012 年，`Object.create()`被写入标准，提供了使用给定原型创建对象的能力，然后还是没有提供`set/get`原型的能力，浏览器厂商们因此实现了非标准的`__proto__`访问器属性，允许用户随时修改和获取原型对象。\n\n```js\nvar a = {};\nconsole.log(a.__proto__);\n\nfunction b() {}\nconsole.log(b.__proto__);\n```\n\n结果如图：\n![prototype](/images/Jietu20200525-170153.jpg)\n\n### 标准方法 Object.getPrototypeOf 和 Object.setPrototypeOf\n\n2015 年，这 2 个方法被加入到标准中。但是因为`__proto__`在很多浏览器都得到了实现，即便过时，但也被加入到标准的附件中了。\n\n```js\nvar a = {};\nObject.getPrototypeOf(a);\n```\n\n结果如图\n![prototype](/images/Jietu20200525-170710.jpg)\n\n总结：从上面的几个代码案例看出来，我们所打印的**原型就是对象**。\n\n## 原型的作用\n\n当我们想要访问一个对象的属性时，先从对象自身查找，如果没有，会去对象的私有属性`[[Prototype]]` 所引用的原型对象上去找。\n\n```js\nvar parent = {\n  run: true,\n};\n\nvar son = {};\n\nObject.setPrototypeOf(son, parent); // 等于 son.__proto__ = parent\n\nson.run; // true son对象本身没有run属性，所以会沿着[[Prototype]]指向的原型对象上去找\n```\n\n这个特性可以让我们复用逻辑，实现面向对象语言中的 **继承** 特性。\n\n## JS 中的继承\n\nJS 中的继承是通过`[[Prototype]]`来实现的，即便在 ES6 时代有了`class`关键字。\n\n早期的函数方式继承：\n\n```js\nfunction Person() {\n  this.run = true;\n}\n\nfunction Son() {}\n\nSon.prototype = new Person();\n\nvar son = new Son();\nson.run; // true\n```\n\n使用 es6 关键字`class`实现\n\n```js\nclass Parent {\n  constructor() {\n    this.run = true;\n  }\n}\n\nclass Son extends Parent {\n  constructor() {\n    super();\n  }\n}\n\nconst son = new Son();\nson.run;\n```\n\n# 总结\n\n原型是一个对象的内部属性`[[Prototype]]`所引用的一个对象。从 JS 诞生开始，就有`F.prototype`的方式可以访问到原型，和修改原型，但是只有函数才有`prototype`，后来浏览器厂商自己实现了`__proto__`访问器属性来实现对原型的`set/get`，直到 ES 标准规定了原型的访问和设置的方法`Object.getPrototypeOf`和`Object.setPrototypeOf`。\n\n原型存在的最大作用是**继承**，JS 中的继承都是**原型继承**，从以前的`函数继承`到现在的`class`类语法糖来实现继承。\n","slug":"2020/原型和继承初识","published":1,"updated":"2021-11-06T07:36:11.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz2000i6hufbo2m4aws","content":"<p>初步介绍下原型和继承，以及相关的 API.</p>\n<h2 id=\"原型是什么\"><a href=\"#原型是什么\" class=\"headerlink\" title=\"原型是什么\"></a>原型是什么</h2><p>所有的对象（包括函数）都有一个隐藏的内部属性<code>[[Prototype]]</code>，该属性引用的就是<strong>原型</strong>，原型本身也是一个对象，所以原型自己也有原型。</p>\n<h2 id=\"原型长什么样\"><a href=\"#原型长什么样\" class=\"headerlink\" title=\"原型长什么样\"></a>原型长什么样</h2><p>因为<code>[[Prototype]]</code>是内部属性，所以通过代码无法访问，但是我们有其他方式访问到原型。</p>\n<h3 id=\"构造函数才有的-prototype\"><a href=\"#构造函数才有的-prototype\" class=\"headerlink\" title=\"构造函数才有的 prototype\"></a>构造函数才有的 prototype</h3><p>这是 JS 早期就有的属性，<strong>只有函数才有，字面量对象是没有的</strong>，可以在控制台尝试访问一个字面量对象的<code>prototype</code>，发现是<code>undefined</code>。所以这个功能有限。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype);</span><br></pre></td></tr></table></figure>\n\n<p>结果如图：<br><img src=\"/images/Jietu20200525-160258.jpg\" alt=\"prototype\"></p>\n<h3 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a>__proto__</h3><p>2012 年，<code>Object.create()</code>被写入标准，提供了使用给定原型创建对象的能力，然后还是没有提供<code>set/get</code>原型的能力，浏览器厂商们因此实现了非标准的<code>__proto__</code>访问器属性，允许用户随时修改和获取原型对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b.__proto__);</span><br></pre></td></tr></table></figure>\n\n<p>结果如图：<br><img src=\"/images/Jietu20200525-170153.jpg\" alt=\"prototype\"></p>\n<h3 id=\"标准方法-Object-getPrototypeOf-和-Object-setPrototypeOf\"><a href=\"#标准方法-Object-getPrototypeOf-和-Object-setPrototypeOf\" class=\"headerlink\" title=\"标准方法 Object.getPrototypeOf 和 Object.setPrototypeOf\"></a>标准方法 Object.getPrototypeOf 和 Object.setPrototypeOf</h3><p>2015 年，这 2 个方法被加入到标准中。但是因为<code>__proto__</code>在很多浏览器都得到了实现，即便过时，但也被加入到标准的附件中了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(a);</span><br></pre></td></tr></table></figure>\n\n<p>结果如图<br><img src=\"/images/Jietu20200525-170710.jpg\" alt=\"prototype\"></p>\n<p>总结：从上面的几个代码案例看出来，我们所打印的<strong>原型就是对象</strong>。</p>\n<h2 id=\"原型的作用\"><a href=\"#原型的作用\" class=\"headerlink\" title=\"原型的作用\"></a>原型的作用</h2><p>当我们想要访问一个对象的属性时，先从对象自身查找，如果没有，会去对象的私有属性<code>[[Prototype]]</code> 所引用的原型对象上去找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">run</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(son, parent); <span class=\"comment\">// 等于 son.__proto__ = parent</span></span><br><span class=\"line\"></span><br><span class=\"line\">son.run; <span class=\"comment\">// true son对象本身没有run属性，所以会沿着[[Prototype]]指向的原型对象上去找</span></span><br></pre></td></tr></table></figure>\n\n<p>这个特性可以让我们复用逻辑，实现面向对象语言中的 <strong>继承</strong> 特性。</p>\n<h2 id=\"JS-中的继承\"><a href=\"#JS-中的继承\" class=\"headerlink\" title=\"JS 中的继承\"></a>JS 中的继承</h2><p>JS 中的继承是通过<code>[[Prototype]]</code>来实现的，即便在 ES6 时代有了<code>class</code>关键字。</p>\n<p>早期的函数方式继承：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.run = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.run; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>使用 es6 关键字<code>class</code>实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.run = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.run;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>原型是一个对象的内部属性<code>[[Prototype]]</code>所引用的一个对象。从 JS 诞生开始，就有<code>F.prototype</code>的方式可以访问到原型，和修改原型，但是只有函数才有<code>prototype</code>，后来浏览器厂商自己实现了<code>__proto__</code>访问器属性来实现对原型的<code>set/get</code>，直到 ES 标准规定了原型的访问和设置的方法<code>Object.getPrototypeOf</code>和<code>Object.setPrototypeOf</code>。</p>\n<p>原型存在的最大作用是<strong>继承</strong>，JS 中的继承都是<strong>原型继承</strong>，从以前的<code>函数继承</code>到现在的<code>class</code>类语法糖来实现继承。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>初步介绍下原型和继承，以及相关的 API.</p>\n<h2 id=\"原型是什么\"><a href=\"#原型是什么\" class=\"headerlink\" title=\"原型是什么\"></a>原型是什么</h2><p>所有的对象（包括函数）都有一个隐藏的内部属性<code>[[Prototype]]</code>，该属性引用的就是<strong>原型</strong>，原型本身也是一个对象，所以原型自己也有原型。</p>\n<h2 id=\"原型长什么样\"><a href=\"#原型长什么样\" class=\"headerlink\" title=\"原型长什么样\"></a>原型长什么样</h2><p>因为<code>[[Prototype]]</code>是内部属性，所以通过代码无法访问，但是我们有其他方式访问到原型。</p>\n<h3 id=\"构造函数才有的-prototype\"><a href=\"#构造函数才有的-prototype\" class=\"headerlink\" title=\"构造函数才有的 prototype\"></a>构造函数才有的 prototype</h3><p>这是 JS 早期就有的属性，<strong>只有函数才有，字面量对象是没有的</strong>，可以在控制台尝试访问一个字面量对象的<code>prototype</code>，发现是<code>undefined</code>。所以这个功能有限。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype);</span><br></pre></td></tr></table></figure>\n\n<p>结果如图：<br><img src=\"/images/Jietu20200525-160258.jpg\" alt=\"prototype\"></p>\n<h3 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a>__proto__</h3><p>2012 年，<code>Object.create()</code>被写入标准，提供了使用给定原型创建对象的能力，然后还是没有提供<code>set/get</code>原型的能力，浏览器厂商们因此实现了非标准的<code>__proto__</code>访问器属性，允许用户随时修改和获取原型对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b.__proto__);</span><br></pre></td></tr></table></figure>\n\n<p>结果如图：<br><img src=\"/images/Jietu20200525-170153.jpg\" alt=\"prototype\"></p>\n<h3 id=\"标准方法-Object-getPrototypeOf-和-Object-setPrototypeOf\"><a href=\"#标准方法-Object-getPrototypeOf-和-Object-setPrototypeOf\" class=\"headerlink\" title=\"标准方法 Object.getPrototypeOf 和 Object.setPrototypeOf\"></a>标准方法 Object.getPrototypeOf 和 Object.setPrototypeOf</h3><p>2015 年，这 2 个方法被加入到标准中。但是因为<code>__proto__</code>在很多浏览器都得到了实现，即便过时，但也被加入到标准的附件中了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(a);</span><br></pre></td></tr></table></figure>\n\n<p>结果如图<br><img src=\"/images/Jietu20200525-170710.jpg\" alt=\"prototype\"></p>\n<p>总结：从上面的几个代码案例看出来，我们所打印的<strong>原型就是对象</strong>。</p>\n<h2 id=\"原型的作用\"><a href=\"#原型的作用\" class=\"headerlink\" title=\"原型的作用\"></a>原型的作用</h2><p>当我们想要访问一个对象的属性时，先从对象自身查找，如果没有，会去对象的私有属性<code>[[Prototype]]</code> 所引用的原型对象上去找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">run</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(son, parent); <span class=\"comment\">// 等于 son.__proto__ = parent</span></span><br><span class=\"line\"></span><br><span class=\"line\">son.run; <span class=\"comment\">// true son对象本身没有run属性，所以会沿着[[Prototype]]指向的原型对象上去找</span></span><br></pre></td></tr></table></figure>\n\n<p>这个特性可以让我们复用逻辑，实现面向对象语言中的 <strong>继承</strong> 特性。</p>\n<h2 id=\"JS-中的继承\"><a href=\"#JS-中的继承\" class=\"headerlink\" title=\"JS 中的继承\"></a>JS 中的继承</h2><p>JS 中的继承是通过<code>[[Prototype]]</code>来实现的，即便在 ES6 时代有了<code>class</code>关键字。</p>\n<p>早期的函数方式继承：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.run = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.run; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>使用 es6 关键字<code>class</code>实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.run = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.run;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>原型是一个对象的内部属性<code>[[Prototype]]</code>所引用的一个对象。从 JS 诞生开始，就有<code>F.prototype</code>的方式可以访问到原型，和修改原型，但是只有函数才有<code>prototype</code>，后来浏览器厂商自己实现了<code>__proto__</code>访问器属性来实现对原型的<code>set/get</code>，直到 ES 标准规定了原型的访问和设置的方法<code>Object.getPrototypeOf</code>和<code>Object.setPrototypeOf</code>。</p>\n<p>原型存在的最大作用是<strong>继承</strong>，JS 中的继承都是<strong>原型继承</strong>，从以前的<code>函数继承</code>到现在的<code>class</code>类语法糖来实现继承。</p>\n"},{"title":"实现Promise（版本1）","date":"2020-12-29T16:00:00.000Z","_content":"\n实现一个`Promise`。\n\n原生的语法如下\n\n```js\nvar p = new Promise(function (resolve) {\n  resolve(1);\n});\np.then(function (val) {\n  console.log(val);\n});\n```\n\n看起来很简单，就是函数有个`then`方法呗。\n\n```js\nfunction miniPromise() {\n  return {\n    then: (callback) => {\n      var value = 1;\n      callback(value);\n    },\n  };\n}\n\nminiPromise().then(function (v) {\n  console.log(v); // 1\n});\n```\n\n实现了一个完全只是语法糖的`promise` 😁，并没有什么用。\n\n## 简单实现\n\n1. promise 接收一个函数 fn，创建 promise 时，fn 自动执行，且 fn 接收`resolve`。\n2. 函数有个`then`方法，接收一个回调函数，回调函数接收终值。\n\n```js\nfunction MyPromise(fn) {\n  var callback = null;\n  this.then = function (cb) {\n    callback = cb;\n  };\n\n  function resolve(value) {\n    callback(value);\n  }\n\n  fn(resolve);\n}\n\nMyPromise(function (resolve) {\n  resolve(1);\n}).then((value) => {\n  console.log(1);\n});\n```\n\n上面代码执行会报错，`callback`不是一个函数。分析看出`MyPromise`执行时调用了`resolve`方法，里面通过`callback`得到值，但是此时`then`还未调用呢，`callback`是 `null`\n\n所以 我们需要等到`then`注册完`callback`后在调用，可以将`callback`异步执行（下一个事件循环），保证同步注册的`then`函数先触发去注册`callback`。\n\n```js\nfunction MyPromise(fn) {\n  var callback = null;\n  this.then = function (cb) {\n    callback = cb;\n  };\n\n  function resolve(value) {\n    setTimeout(() => {\n      callback(value);\n    }, 1);\n  }\n\n  fn(resolve);\n}\n\nMyPromise(function (resolve) {\n  resolve(1);\n}).then((value) => {\n  console.log(1);\n});\n```\n\n看起来可以正常跑，只是当`then`异步调用时，发现又不管用了。\n\n## 加入状态机制\n\n我们来引入`promise`的状态机来解决异步注册的问题。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    state = 'resolved';\n    value = newV;\n    // 如果resolve时，已经有注册过函数，则执行\n    if (deferred) {\n      deferred(value);\n    }\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    if (state === 'pedding') {\n      deferred = onResolved;\n    } else {\n      onResolved(value);\n    }\n  };\n\n  fn(resolve);\n}\n```\n\n上面代码的`deferred`和`onResolved`其实是同一个东西，只不过如果`state`还是`pedding`状态，则`onResolved`需要延迟到`resolve`调用后执行。所以我们可以统一调度调用`deferred`（或者说是`onResolved`）\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    state = 'resolved';\n    value = newV;\n    // 如果resolve时，已经有注册过函数，则执行\n    if (deferred) {\n      deferred(value);\n    }\n  }\n\n  // 统一调度调用onResolved\n  function handle(onResolved) {\n    if (state === 'pedding') {\n      deferred = onResolved;\n      return;\n    }\n    onResolved(value);\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    handle(onResolved);\n  };\n\n  fn(resolve);\n}\n```\n\n这段代码已经实现了`promise`的基本功能。即便是异步`resolve`也可以获取到终值。\n\n```js\nvar promise = new MyPromise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\npromise.then((v) => {\n  console.log(v);\n});\n```\n\n## then 返回新的 promise\n\n- `then`方法返回一个`promise`，并接受前一个上一个的`then`返回值作为入参。\n- 如果上一个`then`没有注册`resolved`方法，则透传之前的终值。\n- 如果上一个`then`有注册`resolved`方法，执行，并将执行结果传递给下一个`then`\n\n我们先看下原生的效果\n\n```js\nvar p = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\n// then 返回新的promise。因为可以链式调用then。\n// 链式的then并非之前的promise，而是新的promise\np.then()\n  .then()\n  .then((v) => {\n    console.log(v); // 前2个then没有获取到终值，透传终值1\n  });\n\np.then((v) => {\n  return v + 1;\n}).then((v) => {\n  console.log(v); // 2\n});\n```\n\n> **注意**：上面 2 个调用有个很有意思的地方，透传的有 3 个 then，非直接透传的有 2 个 then，打印结果，先 2，后 1。因为透传的多了一层 then\n\n现在我们来改造`MyPromise`\n\n1. `then`可能注册了`onResolved`，也可能没有，没有则需要透传终值，要改状态\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    state = 'resolved';\n    value = newV;\n    // 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  // 统一调度调用onResolved\n  // 改造3：接收的是个对象了，所以要改\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n    var handledValue = value;\n    // 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值\n    if (handler.onResolved) {\n      handledValue = handler.onResolved(handledValue);\n    }\n    // 将处理过或默认的终值传递给能够确定终值和状态的resolve\n    handler.resolve(handledValue);\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    // 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。\n    return new MyPromise((resolve) => {\n      // 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！\n      // 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。\n      handle({\n        onResolved,\n        resolve,\n      });\n    });\n  };\n\n  fn(resolve);\n}\n```\n\n我们来调用试试。\n\n```js\nvar p1 = new MyPromise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np1.then()\n  .then()\n  .then()\n  .then((v) => {\n    console.log(v); // 1\n  });\n\nvar p2 = new MyPromise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np2.then((v) => {\n  return v + 1;\n}).then((v) => {\n  console.log(v); // 2\n});\n```\n\n> **注意**打印顺序是 1，2，并非原生的 2，1。因为我们模拟的函数里并没有让 then 异步处理，而是同步的。\n\n## 如果 then 返回的是 promise\n\n上面的链式调用，只处理了普通的终值，如果终值本身就是`promise`的话，我们就需要在`then`中对终值在进行`then`的写法，嵌套会越来越深。如：\n\n```js\np.then(promise1 => {\n  promise1.then(promise2 => {\n    promise2.then(promise3 => {\n      promise3.then(...)\n    })\n  })\n})\n```\n\n看看原生是怎么处理的。\n\n```js\nvar time = [];\nvar p = new Promise((resolve) => {\n  time.push(Date.now());\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np.then(\n  () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(2);\n      }, 2000);\n    })\n).then((v) => {\n  time.push(Date.now());\n  console.log(v, time[1] - time[0]); // 2 3000\n});\n```\n\n原生的 `promise.then`返回的如果是新的`promise`，则后续的链都是以这个新的`promise`的`resolved`后的终值来传递了，跟最开始的旧`promise`无关了。\n所以我们要对`then`返回的是`promise`做个判断处理，如果`then`返回的是一个`promise`，等待其`resolved`后，传递它的终值。\n\n因为无论有没有上一个`promise`注册的`onResolved`方法，最终都会走`resolve`来确定新`promise`的状态和终值，我们就在`resolve`做判断处理就好了。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    // 改造5：如果接收到的终值是一个promise，则调用其then方法，终止旧的promise，开启基于返回的新的promise进行传递\n    if (newV && typeof newV.then === 'function') {\n      newV.then(resolve);\n      return;\n    }\n\n    state = 'resolved';\n    value = newV;\n    // 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  // 统一调度调用onResolved\n  // 改造3：接收的是个对象了，所以要改\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n    var handledValue = value;\n    // 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值\n    if (handler.onResolved) {\n      handledValue = handler.onResolved(handledValue);\n    }\n    // 将处理过或默认的终值传递给能够确定终值和状态的resolve\n    handler.resolve(handledValue);\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    // 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。\n    return new MyPromise((resolve) => {\n      // 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！\n      // 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。\n      handle({\n        onResolved,\n        resolve,\n      });\n    });\n  };\n\n  fn(resolve);\n}\n```\n\n测试看看\n\n```js\nvar time = [];\nvar p = new MyPromise((resolve) => {\n  time.push(Date.now());\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np.then(\n  () =>\n    new MyPromise((resolve) => {\n      setTimeout(() => {\n        resolve(2);\n      }, 2000);\n    })\n).then((v) => {\n  time.push(Date.now());\n  console.log(v, time[1] - time[0]); // 2 3009\n});\n```\n\n## 处理错误\n\n`promise`的异常处理`rejected`，我们来加上。\n\n先看原生的用法\n\n```js\nvar p = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error('is a error'));\n  });\n});\n\np.then(\n  (v) => {},\n  (err) => {\n    console.log(err); // 捕获异常打印\n  }\n);\n```\n\n我们看到，初始化时加入了`reject`函数，接收一个`Error`类型的值。在`then`中第二个参数，来接收该错误，处理。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  function resolve(newV) {\n    if (newV && typeof newV.then === 'function') {\n      newV.then(resolve);\n      return;\n    }\n\n    state = 'resolved';\n    value = newV;\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  // 改造1：增加reject函数，将状态变为 rejected。\n  function reject(err) {\n    state = 'rejected';\n    value = err;\n\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n\n    var handledValue = value;\n\n    // 改造6：handler比之前多了onRejected和reject，根据state状态调用对应的then处理函数\n    var handleCallback;\n\n    if (state === 'resolved') {\n      handleCallback = handler.onResolved;\n    } else if (state === 'rejected') {\n      handleCallback = handler.onRejected;\n    }\n\n    if (handleCallback) {\n      handledValue = handleCallback(handledValue);\n    }\n\n    handler.resolve(handledValue);\n  }\n\n  // 改造4：then方法接收第二个参数处理error\n  this.then = function (onResolved, onRejected) {\n    return new MyPromise((resolve) => {\n      handle({\n        onResolved,\n        resolve,\n        // 改造5：将上一个处理异常的onRejected和当前reject交给handle来统一调度\n        onRejected,\n        reject,\n      });\n    });\n  };\n  //改造3：接收第二个参数reject\n  fn(resolve, reject);\n}\n```\n\n测试下\n\n```js\nvar p = new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error('hello'));\n  }, 1000);\n});\n\np.then(\n  (v) => {\n    console.log('succ', v);\n  },\n  (err) => {\n    console.log('fail', err); // fail Error: hello\n  }\n);\n```\n\n## promise.catch\n\n平时捕获异常用的最多的应该还是`promise.catch`。\n\n我们来看下原生的用法\n\n```js\n// 已知错误\nvar p = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('123');\n  }, 1000);\n});\n\np.then().catch((err) => {\n  console.log(err); // 123\n});\n\n// 未知错误，通常在resolve执行中，或then的onResolved出错，我们也应该捕获。\n\nvar p2 = new Promise((resolve) => {\n  resolve(a);\n});\n```\n\n尝试实现下\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  // 改造5：标志符，用来控制实例化promise时有无注册catch来控制抛错还是用catch(实际上就是then中的onResovled)处理\n  var catcher = null;\n  var deferred = null;\n\n  function resolve(newV) {\n    // 改造1：捕获resolve可能出现的问题\n    try {\n      if (newV && typeof newV.then === 'function') {\n        newV.then(resolve);\n        return;\n      }\n\n      state = 'resolved';\n      value = newV;\n      if (deferred) {\n        handle(deferred);\n      }\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  function reject(err) {\n    state = 'rejected';\n    value = err;\n\n    if (deferred) {\n      handle(deferred);\n    } else {\n      setTimeout(() => {\n        if (!catcher) {\n          throw value;\n        }\n      }, 0);\n    }\n  }\n\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n\n    // 改造3：因为promise是异步的，所有操作需要异步处理\n    var handledValue = value;\n\n    var handleCallback;\n    // 改造2：捕获handle传入的处理函数时可能出现的问题\n    try {\n      if (state === 'resolved') {\n        handleCallback = handler.onResolved;\n      } else if (state === 'rejected') {\n        handleCallback = handler.onRejected;\n      }\n      if (handleCallback) {\n        handledValue = handleCallback(handledValue);\n      }\n    } catch (err) {\n      handler.reject(err);\n    }\n\n    handler.resolve(handledValue);\n  }\n\n  this.then = function (onResolved, onRejected) {\n    return new MyPromise((resolve) => {\n      handle({\n        onResolved,\n        resolve,\n        onRejected,\n        reject,\n      });\n    });\n  };\n\n  // catch方法也会返回一个promise，实际上就等于then方法第一个参数不传，第二个参数处理err\n  this.catch = function (fn) {\n    // 如果注册了catch，则异常交给catch来做\n    catcher = true;\n    // 注册catch\n    this.then(null, fn);\n  };\n\n  // 改造4：初始化promise时也可能出错，若出错，直接调用reject\n  try {\n    fn(resolve, reject);\n  } catch (err) {\n    reject(err);\n  }\n}\n```\n\n## promise 需要异步\n\nPromiseA+规范要求解决程序，也就是 resolve 和 reject 的执行都是异步的。\n\n所以我们需要对`handle`函数做异步调用，我们使用`setTimeout`模拟。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var catcher = null;\n  var deferred = null;\n\n  function resolve(newV) {\n    try {\n      if (newV && typeof newV.then === 'function') {\n        newV.then(resolve);\n        return;\n      }\n\n      state = 'resolved';\n      value = newV;\n      if (deferred) {\n        handle(deferred);\n      }\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  function reject(err) {\n    state = 'rejected';\n    value = err;\n\n    if (deferred) {\n      handle(deferred);\n    } else {\n      setTimeout(() => {\n        if (!catcher) {\n          throw value;\n        }\n      }, 0);\n    }\n  }\n\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n\n    // 改造：因为promise是异步的，所有操作需要异步处理\n    setTimeout(() => {\n      var handledValue = value;\n\n      var handleCallback;\n      try {\n        if (state === 'resolved') {\n          handleCallback = handler.onResolved;\n        } else if (state === 'rejected') {\n          handleCallback = handler.onRejected;\n        }\n        if (handleCallback) {\n          handledValue = handleCallback(handledValue);\n        }\n      } catch (err) {\n        handler.reject(err);\n      }\n      handler.resolve(handledValue);\n    }, 0);\n  }\n\n  this.then = function (onResolved, onRejected) {\n    return new MyPromise((resolve) => {\n      handle({\n        onResolved,\n        resolve,\n        onRejected,\n        reject,\n      });\n    });\n  };\n\n  this.catch = function (fn) {\n    catcher = true;\n    this.then(null, fn);\n  };\n\n  try {\n    fn(resolve, reject);\n  } catch (err) {\n    reject(err);\n  }\n}\n```\n\n## Promise.all 方法\n\n- 接收一个数组，数组成员都是`promise`。\n- 数组中所有的`promise`都`resolved`，整体才能`resolve`，否则`reject`掉第一个出错的数组成员`promise`。\n- 该函数返回一个新的`promise`，终值是所有数组成员的终值构成的数组。\n\n```js\nMyPromise.all = function (arr) {\n  var resArr = [];\n  return new MyPromise((resolve, reject) => {\n    for (let i = 0; i < arr.length; i++) {\n      arr[i]\n        .then((r) => {\n          resArr.push(r);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    }\n    resolve(resArr);\n  });\n};\n```\n\n# 总结\n\n这个版本的实现虽然可以达到`promise`基本的功能，但是思路有点绕。\n\n而且有个`bug`，未实现`catch`和`onRejected`函数的话，不会抛错，内部逻辑里`handle`函数判断已经`reject`了，不在会设置`deferred`，导致静默报错了。\n","source":"_posts/2020/实现promise_v1.md","raw":"---\ntitle: 实现Promise（版本1）\ndate: 2020/12/30\n---\n\n实现一个`Promise`。\n\n原生的语法如下\n\n```js\nvar p = new Promise(function (resolve) {\n  resolve(1);\n});\np.then(function (val) {\n  console.log(val);\n});\n```\n\n看起来很简单，就是函数有个`then`方法呗。\n\n```js\nfunction miniPromise() {\n  return {\n    then: (callback) => {\n      var value = 1;\n      callback(value);\n    },\n  };\n}\n\nminiPromise().then(function (v) {\n  console.log(v); // 1\n});\n```\n\n实现了一个完全只是语法糖的`promise` 😁，并没有什么用。\n\n## 简单实现\n\n1. promise 接收一个函数 fn，创建 promise 时，fn 自动执行，且 fn 接收`resolve`。\n2. 函数有个`then`方法，接收一个回调函数，回调函数接收终值。\n\n```js\nfunction MyPromise(fn) {\n  var callback = null;\n  this.then = function (cb) {\n    callback = cb;\n  };\n\n  function resolve(value) {\n    callback(value);\n  }\n\n  fn(resolve);\n}\n\nMyPromise(function (resolve) {\n  resolve(1);\n}).then((value) => {\n  console.log(1);\n});\n```\n\n上面代码执行会报错，`callback`不是一个函数。分析看出`MyPromise`执行时调用了`resolve`方法，里面通过`callback`得到值，但是此时`then`还未调用呢，`callback`是 `null`\n\n所以 我们需要等到`then`注册完`callback`后在调用，可以将`callback`异步执行（下一个事件循环），保证同步注册的`then`函数先触发去注册`callback`。\n\n```js\nfunction MyPromise(fn) {\n  var callback = null;\n  this.then = function (cb) {\n    callback = cb;\n  };\n\n  function resolve(value) {\n    setTimeout(() => {\n      callback(value);\n    }, 1);\n  }\n\n  fn(resolve);\n}\n\nMyPromise(function (resolve) {\n  resolve(1);\n}).then((value) => {\n  console.log(1);\n});\n```\n\n看起来可以正常跑，只是当`then`异步调用时，发现又不管用了。\n\n## 加入状态机制\n\n我们来引入`promise`的状态机来解决异步注册的问题。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    state = 'resolved';\n    value = newV;\n    // 如果resolve时，已经有注册过函数，则执行\n    if (deferred) {\n      deferred(value);\n    }\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    if (state === 'pedding') {\n      deferred = onResolved;\n    } else {\n      onResolved(value);\n    }\n  };\n\n  fn(resolve);\n}\n```\n\n上面代码的`deferred`和`onResolved`其实是同一个东西，只不过如果`state`还是`pedding`状态，则`onResolved`需要延迟到`resolve`调用后执行。所以我们可以统一调度调用`deferred`（或者说是`onResolved`）\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    state = 'resolved';\n    value = newV;\n    // 如果resolve时，已经有注册过函数，则执行\n    if (deferred) {\n      deferred(value);\n    }\n  }\n\n  // 统一调度调用onResolved\n  function handle(onResolved) {\n    if (state === 'pedding') {\n      deferred = onResolved;\n      return;\n    }\n    onResolved(value);\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    handle(onResolved);\n  };\n\n  fn(resolve);\n}\n```\n\n这段代码已经实现了`promise`的基本功能。即便是异步`resolve`也可以获取到终值。\n\n```js\nvar promise = new MyPromise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\npromise.then((v) => {\n  console.log(v);\n});\n```\n\n## then 返回新的 promise\n\n- `then`方法返回一个`promise`，并接受前一个上一个的`then`返回值作为入参。\n- 如果上一个`then`没有注册`resolved`方法，则透传之前的终值。\n- 如果上一个`then`有注册`resolved`方法，执行，并将执行结果传递给下一个`then`\n\n我们先看下原生的效果\n\n```js\nvar p = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\n// then 返回新的promise。因为可以链式调用then。\n// 链式的then并非之前的promise，而是新的promise\np.then()\n  .then()\n  .then((v) => {\n    console.log(v); // 前2个then没有获取到终值，透传终值1\n  });\n\np.then((v) => {\n  return v + 1;\n}).then((v) => {\n  console.log(v); // 2\n});\n```\n\n> **注意**：上面 2 个调用有个很有意思的地方，透传的有 3 个 then，非直接透传的有 2 个 then，打印结果，先 2，后 1。因为透传的多了一层 then\n\n现在我们来改造`MyPromise`\n\n1. `then`可能注册了`onResolved`，也可能没有，没有则需要透传终值，要改状态\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    state = 'resolved';\n    value = newV;\n    // 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  // 统一调度调用onResolved\n  // 改造3：接收的是个对象了，所以要改\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n    var handledValue = value;\n    // 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值\n    if (handler.onResolved) {\n      handledValue = handler.onResolved(handledValue);\n    }\n    // 将处理过或默认的终值传递给能够确定终值和状态的resolve\n    handler.resolve(handledValue);\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    // 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。\n    return new MyPromise((resolve) => {\n      // 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！\n      // 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。\n      handle({\n        onResolved,\n        resolve,\n      });\n    });\n  };\n\n  fn(resolve);\n}\n```\n\n我们来调用试试。\n\n```js\nvar p1 = new MyPromise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np1.then()\n  .then()\n  .then()\n  .then((v) => {\n    console.log(v); // 1\n  });\n\nvar p2 = new MyPromise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np2.then((v) => {\n  return v + 1;\n}).then((v) => {\n  console.log(v); // 2\n});\n```\n\n> **注意**打印顺序是 1，2，并非原生的 2，1。因为我们模拟的函数里并没有让 then 异步处理，而是同步的。\n\n## 如果 then 返回的是 promise\n\n上面的链式调用，只处理了普通的终值，如果终值本身就是`promise`的话，我们就需要在`then`中对终值在进行`then`的写法，嵌套会越来越深。如：\n\n```js\np.then(promise1 => {\n  promise1.then(promise2 => {\n    promise2.then(promise3 => {\n      promise3.then(...)\n    })\n  })\n})\n```\n\n看看原生是怎么处理的。\n\n```js\nvar time = [];\nvar p = new Promise((resolve) => {\n  time.push(Date.now());\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np.then(\n  () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(2);\n      }, 2000);\n    })\n).then((v) => {\n  time.push(Date.now());\n  console.log(v, time[1] - time[0]); // 2 3000\n});\n```\n\n原生的 `promise.then`返回的如果是新的`promise`，则后续的链都是以这个新的`promise`的`resolved`后的终值来传递了，跟最开始的旧`promise`无关了。\n所以我们要对`then`返回的是`promise`做个判断处理，如果`then`返回的是一个`promise`，等待其`resolved`后，传递它的终值。\n\n因为无论有没有上一个`promise`注册的`onResolved`方法，最终都会走`resolve`来确定新`promise`的状态和终值，我们就在`resolve`做判断处理就好了。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  // resolve的工作是将状态切换为resolved\n  function resolve(newV) {\n    // 改造5：如果接收到的终值是一个promise，则调用其then方法，终止旧的promise，开启基于返回的新的promise进行传递\n    if (newV && typeof newV.then === 'function') {\n      newV.then(resolve);\n      return;\n    }\n\n    state = 'resolved';\n    value = newV;\n    // 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  // 统一调度调用onResolved\n  // 改造3：接收的是个对象了，所以要改\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n    var handledValue = value;\n    // 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值\n    if (handler.onResolved) {\n      handledValue = handler.onResolved(handledValue);\n    }\n    // 将处理过或默认的终值传递给能够确定终值和状态的resolve\n    handler.resolve(handledValue);\n  }\n\n  // then 注册一个onResolved方法，接收终值\n  this.then = function (onResolved) {\n    // 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。\n    return new MyPromise((resolve) => {\n      // 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！\n      // 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。\n      handle({\n        onResolved,\n        resolve,\n      });\n    });\n  };\n\n  fn(resolve);\n}\n```\n\n测试看看\n\n```js\nvar time = [];\nvar p = new MyPromise((resolve) => {\n  time.push(Date.now());\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n});\n\np.then(\n  () =>\n    new MyPromise((resolve) => {\n      setTimeout(() => {\n        resolve(2);\n      }, 2000);\n    })\n).then((v) => {\n  time.push(Date.now());\n  console.log(v, time[1] - time[0]); // 2 3009\n});\n```\n\n## 处理错误\n\n`promise`的异常处理`rejected`，我们来加上。\n\n先看原生的用法\n\n```js\nvar p = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error('is a error'));\n  });\n});\n\np.then(\n  (v) => {},\n  (err) => {\n    console.log(err); // 捕获异常打印\n  }\n);\n```\n\n我们看到，初始化时加入了`reject`函数，接收一个`Error`类型的值。在`then`中第二个参数，来接收该错误，处理。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var deferred = null;\n\n  function resolve(newV) {\n    if (newV && typeof newV.then === 'function') {\n      newV.then(resolve);\n      return;\n    }\n\n    state = 'resolved';\n    value = newV;\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  // 改造1：增加reject函数，将状态变为 rejected。\n  function reject(err) {\n    state = 'rejected';\n    value = err;\n\n    if (deferred) {\n      handle(deferred);\n    }\n  }\n\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n\n    var handledValue = value;\n\n    // 改造6：handler比之前多了onRejected和reject，根据state状态调用对应的then处理函数\n    var handleCallback;\n\n    if (state === 'resolved') {\n      handleCallback = handler.onResolved;\n    } else if (state === 'rejected') {\n      handleCallback = handler.onRejected;\n    }\n\n    if (handleCallback) {\n      handledValue = handleCallback(handledValue);\n    }\n\n    handler.resolve(handledValue);\n  }\n\n  // 改造4：then方法接收第二个参数处理error\n  this.then = function (onResolved, onRejected) {\n    return new MyPromise((resolve) => {\n      handle({\n        onResolved,\n        resolve,\n        // 改造5：将上一个处理异常的onRejected和当前reject交给handle来统一调度\n        onRejected,\n        reject,\n      });\n    });\n  };\n  //改造3：接收第二个参数reject\n  fn(resolve, reject);\n}\n```\n\n测试下\n\n```js\nvar p = new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error('hello'));\n  }, 1000);\n});\n\np.then(\n  (v) => {\n    console.log('succ', v);\n  },\n  (err) => {\n    console.log('fail', err); // fail Error: hello\n  }\n);\n```\n\n## promise.catch\n\n平时捕获异常用的最多的应该还是`promise.catch`。\n\n我们来看下原生的用法\n\n```js\n// 已知错误\nvar p = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('123');\n  }, 1000);\n});\n\np.then().catch((err) => {\n  console.log(err); // 123\n});\n\n// 未知错误，通常在resolve执行中，或then的onResolved出错，我们也应该捕获。\n\nvar p2 = new Promise((resolve) => {\n  resolve(a);\n});\n```\n\n尝试实现下\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  // 改造5：标志符，用来控制实例化promise时有无注册catch来控制抛错还是用catch(实际上就是then中的onResovled)处理\n  var catcher = null;\n  var deferred = null;\n\n  function resolve(newV) {\n    // 改造1：捕获resolve可能出现的问题\n    try {\n      if (newV && typeof newV.then === 'function') {\n        newV.then(resolve);\n        return;\n      }\n\n      state = 'resolved';\n      value = newV;\n      if (deferred) {\n        handle(deferred);\n      }\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  function reject(err) {\n    state = 'rejected';\n    value = err;\n\n    if (deferred) {\n      handle(deferred);\n    } else {\n      setTimeout(() => {\n        if (!catcher) {\n          throw value;\n        }\n      }, 0);\n    }\n  }\n\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n\n    // 改造3：因为promise是异步的，所有操作需要异步处理\n    var handledValue = value;\n\n    var handleCallback;\n    // 改造2：捕获handle传入的处理函数时可能出现的问题\n    try {\n      if (state === 'resolved') {\n        handleCallback = handler.onResolved;\n      } else if (state === 'rejected') {\n        handleCallback = handler.onRejected;\n      }\n      if (handleCallback) {\n        handledValue = handleCallback(handledValue);\n      }\n    } catch (err) {\n      handler.reject(err);\n    }\n\n    handler.resolve(handledValue);\n  }\n\n  this.then = function (onResolved, onRejected) {\n    return new MyPromise((resolve) => {\n      handle({\n        onResolved,\n        resolve,\n        onRejected,\n        reject,\n      });\n    });\n  };\n\n  // catch方法也会返回一个promise，实际上就等于then方法第一个参数不传，第二个参数处理err\n  this.catch = function (fn) {\n    // 如果注册了catch，则异常交给catch来做\n    catcher = true;\n    // 注册catch\n    this.then(null, fn);\n  };\n\n  // 改造4：初始化promise时也可能出错，若出错，直接调用reject\n  try {\n    fn(resolve, reject);\n  } catch (err) {\n    reject(err);\n  }\n}\n```\n\n## promise 需要异步\n\nPromiseA+规范要求解决程序，也就是 resolve 和 reject 的执行都是异步的。\n\n所以我们需要对`handle`函数做异步调用，我们使用`setTimeout`模拟。\n\n```js\nfunction MyPromise(fn) {\n  var state = 'pedding';\n  var value;\n  var catcher = null;\n  var deferred = null;\n\n  function resolve(newV) {\n    try {\n      if (newV && typeof newV.then === 'function') {\n        newV.then(resolve);\n        return;\n      }\n\n      state = 'resolved';\n      value = newV;\n      if (deferred) {\n        handle(deferred);\n      }\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  function reject(err) {\n    state = 'rejected';\n    value = err;\n\n    if (deferred) {\n      handle(deferred);\n    } else {\n      setTimeout(() => {\n        if (!catcher) {\n          throw value;\n        }\n      }, 0);\n    }\n  }\n\n  function handle(handler) {\n    if (state === 'pedding') {\n      deferred = handler;\n      return;\n    }\n\n    // 改造：因为promise是异步的，所有操作需要异步处理\n    setTimeout(() => {\n      var handledValue = value;\n\n      var handleCallback;\n      try {\n        if (state === 'resolved') {\n          handleCallback = handler.onResolved;\n        } else if (state === 'rejected') {\n          handleCallback = handler.onRejected;\n        }\n        if (handleCallback) {\n          handledValue = handleCallback(handledValue);\n        }\n      } catch (err) {\n        handler.reject(err);\n      }\n      handler.resolve(handledValue);\n    }, 0);\n  }\n\n  this.then = function (onResolved, onRejected) {\n    return new MyPromise((resolve) => {\n      handle({\n        onResolved,\n        resolve,\n        onRejected,\n        reject,\n      });\n    });\n  };\n\n  this.catch = function (fn) {\n    catcher = true;\n    this.then(null, fn);\n  };\n\n  try {\n    fn(resolve, reject);\n  } catch (err) {\n    reject(err);\n  }\n}\n```\n\n## Promise.all 方法\n\n- 接收一个数组，数组成员都是`promise`。\n- 数组中所有的`promise`都`resolved`，整体才能`resolve`，否则`reject`掉第一个出错的数组成员`promise`。\n- 该函数返回一个新的`promise`，终值是所有数组成员的终值构成的数组。\n\n```js\nMyPromise.all = function (arr) {\n  var resArr = [];\n  return new MyPromise((resolve, reject) => {\n    for (let i = 0; i < arr.length; i++) {\n      arr[i]\n        .then((r) => {\n          resArr.push(r);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    }\n    resolve(resArr);\n  });\n};\n```\n\n# 总结\n\n这个版本的实现虽然可以达到`promise`基本的功能，但是思路有点绕。\n\n而且有个`bug`，未实现`catch`和`onRejected`函数的话，不会抛错，内部逻辑里`handle`函数判断已经`reject`了，不在会设置`deferred`，导致静默报错了。\n","slug":"2020/实现promise_v1","published":1,"updated":"2021-11-06T07:35:17.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz3000j6huf1cajetge","content":"<p>实现一个<code>Promise</code>。</p>\n<p>原生的语法如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>看起来很简单，就是函数有个<code>then</code>方法呗。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">miniPromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">then</span>: <span class=\"function\">(<span class=\"params\">callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\">      callback(value);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">miniPromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实现了一个完全只是语法糖的<code>promise</code> 😁，并没有什么用。</p>\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><ol>\n<li>promise 接收一个函数 fn，创建 promise 时，fn 自动执行，且 fn 接收<code>resolve</code>。</li>\n<li>函数有个<code>then</code>方法，接收一个回调函数，回调函数接收终值。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">    callback = cb;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    callback(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码执行会报错，<code>callback</code>不是一个函数。分析看出<code>MyPromise</code>执行时调用了<code>resolve</code>方法，里面通过<code>callback</code>得到值，但是此时<code>then</code>还未调用呢，<code>callback</code>是 <code>null</code></p>\n<p>所以 我们需要等到<code>then</code>注册完<code>callback</code>后在调用，可以将<code>callback</code>异步执行（下一个事件循环），保证同步注册的<code>then</code>函数先触发去注册<code>callback</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">    callback = cb;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      callback(value);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>看起来可以正常跑，只是当<code>then</code>异步调用时，发现又不管用了。</p>\n<h2 id=\"加入状态机制\"><a href=\"#加入状态机制\" class=\"headerlink\" title=\"加入状态机制\"></a>加入状态机制</h2><p>我们来引入<code>promise</code>的状态机来解决异步注册的问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 如果resolve时，已经有注册过函数，则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      deferred(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = onResolved;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      onResolved(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>deferred</code>和<code>onResolved</code>其实是同一个东西，只不过如果<code>state</code>还是<code>pedding</code>状态，则<code>onResolved</code>需要延迟到<code>resolve</code>调用后执行。所以我们可以统一调度调用<code>deferred</code>（或者说是<code>onResolved</code>）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 如果resolve时，已经有注册过函数，则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      deferred(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 统一调度调用onResolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = onResolved;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onResolved(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    handle(onResolved);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码已经实现了<code>promise</code>的基本功能。即便是异步<code>resolve</code>也可以获取到终值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"then-返回新的-promise\"><a href=\"#then-返回新的-promise\" class=\"headerlink\" title=\"then 返回新的 promise\"></a>then 返回新的 promise</h2><ul>\n<li><code>then</code>方法返回一个<code>promise</code>，并接受前一个上一个的<code>then</code>返回值作为入参。</li>\n<li>如果上一个<code>then</code>没有注册<code>resolved</code>方法，则透传之前的终值。</li>\n<li>如果上一个<code>then</code>有注册<code>resolved</code>方法，执行，并将执行结果传递给下一个<code>then</code></li>\n</ul>\n<p>我们先看下原生的效果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then 返回新的promise。因为可以链式调用then。</span></span><br><span class=\"line\"><span class=\"comment\">// 链式的then并非之前的promise，而是新的promise</span></span><br><span class=\"line\">p.then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 前2个then没有获取到终值，透传终值1</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：上面 2 个调用有个很有意思的地方，透传的有 3 个 then，非直接透传的有 2 个 then，打印结果，先 2，后 1。因为透传的多了一层 then</p>\n</blockquote>\n<p>现在我们来改造<code>MyPromise</code></p>\n<ol>\n<li><code>then</code>可能注册了<code>onResolved</code>，也可能没有，没有则需要透传终值，要改状态</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 统一调度调用onResolved</span></span><br><span class=\"line\">  <span class=\"comment\">// 改造3：接收的是个对象了，所以要改</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler.onResolved) &#123;</span><br><span class=\"line\">      handledValue = handler.onResolved(handledValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将处理过或默认的终值传递给能够确定终值和状态的resolve</span></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！</span></span><br><span class=\"line\">      <span class=\"comment\">// 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。</span></span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来调用试试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>打印顺序是 1，2，并非原生的 2，1。因为我们模拟的函数里并没有让 then 异步处理，而是同步的。</p>\n</blockquote>\n<h2 id=\"如果-then-返回的是-promise\"><a href=\"#如果-then-返回的是-promise\" class=\"headerlink\" title=\"如果 then 返回的是 promise\"></a>如果 then 返回的是 promise</h2><p>上面的链式调用，只处理了普通的终值，如果终值本身就是<code>promise</code>的话，我们就需要在<code>then</code>中对终值在进行<code>then</code>的写法，嵌套会越来越深。如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.then(<span class=\"function\"><span class=\"params\">promise1</span> =&gt;</span> &#123;</span><br><span class=\"line\">  promise1.then(<span class=\"function\"><span class=\"params\">promise2</span> =&gt;</span> &#123;</span><br><span class=\"line\">    promise2.then(<span class=\"function\"><span class=\"params\">promise3</span> =&gt;</span> &#123;</span><br><span class=\"line\">      promise3.then(...)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>看看原生是怎么处理的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">2</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v, time[<span class=\"number\">1</span>] - time[<span class=\"number\">0</span>]); <span class=\"comment\">// 2 3000</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>原生的 <code>promise.then</code>返回的如果是新的<code>promise</code>，则后续的链都是以这个新的<code>promise</code>的<code>resolved</code>后的终值来传递了，跟最开始的旧<code>promise</code>无关了。<br>所以我们要对<code>then</code>返回的是<code>promise</code>做个判断处理，如果<code>then</code>返回的是一个<code>promise</code>，等待其<code>resolved</code>后，传递它的终值。</p>\n<p>因为无论有没有上一个<code>promise</code>注册的<code>onResolved</code>方法，最终都会走<code>resolve</code>来确定新<code>promise</code>的状态和终值，我们就在<code>resolve</code>做判断处理就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造5：如果接收到的终值是一个promise，则调用其then方法，终止旧的promise，开启基于返回的新的promise进行传递</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      newV.then(resolve);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 统一调度调用onResolved</span></span><br><span class=\"line\">  <span class=\"comment\">// 改造3：接收的是个对象了，所以要改</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler.onResolved) &#123;</span><br><span class=\"line\">      handledValue = handler.onResolved(handledValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将处理过或默认的终值传递给能够确定终值和状态的resolve</span></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！</span></span><br><span class=\"line\">      <span class=\"comment\">// 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。</span></span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试看看</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">2</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v, time[<span class=\"number\">1</span>] - time[<span class=\"number\">0</span>]); <span class=\"comment\">// 2 3009</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h2><p><code>promise</code>的异常处理<code>rejected</code>，我们来加上。</p>\n<p>先看原生的用法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;is a error&#x27;</span>));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// 捕获异常打印</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，初始化时加入了<code>reject</code>函数，接收一个<code>Error</code>类型的值。在<code>then</code>中第二个参数，来接收该错误，处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      newV.then(resolve);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 改造1：增加reject函数，将状态变为 rejected。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">    value = err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 改造6：handler比之前多了onRejected和reject，根据state状态调用对应的then处理函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handleCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">      handleCallback = handler.onResolved;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">      handleCallback = handler.onRejected;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handleCallback) &#123;</span><br><span class=\"line\">      handledValue = handleCallback(handledValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 改造4：then方法接收第二个参数处理error</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">        <span class=\"comment\">// 改造5：将上一个处理异常的onRejected和当前reject交给handle来统一调度</span></span><br><span class=\"line\">        onRejected,</span><br><span class=\"line\">        reject,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">//改造3：接收第二个参数reject</span></span><br><span class=\"line\">  fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;hello&#x27;</span>));</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;succ&#x27;</span>, v);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;fail&#x27;</span>, err); <span class=\"comment\">// fail Error: hello</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"promise-catch\"><a href=\"#promise-catch\" class=\"headerlink\" title=\"promise.catch\"></a>promise.catch</h2><p>平时捕获异常用的最多的应该还是<code>promise.catch</code>。</p>\n<p>我们来看下原生的用法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 已知错误</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">&#x27;123&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then().catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 未知错误，通常在resolve执行中，或then的onResolved出错，我们也应该捕获。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>尝试实现下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"comment\">// 改造5：标志符，用来控制实例化promise时有无注册catch来控制抛错还是用catch(实际上就是then中的onResovled)处理</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> catcher = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造1：捕获resolve可能出现的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        newV.then(resolve);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      value = newV;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">        handle(deferred);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">    value = err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!catcher) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 改造3：因为promise是异步的，所有操作需要异步处理</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handleCallback;</span><br><span class=\"line\">    <span class=\"comment\">// 改造2：捕获handle传入的处理函数时可能出现的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">        handleCallback = handler.onResolved;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">        handleCallback = handler.onRejected;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handleCallback) &#123;</span><br><span class=\"line\">        handledValue = handleCallback(handledValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      handler.reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">        onRejected,</span><br><span class=\"line\">        reject,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// catch方法也会返回一个promise，实际上就等于then方法第一个参数不传，第二个参数处理err</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果注册了catch，则异常交给catch来做</span></span><br><span class=\"line\">    catcher = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 注册catch</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, fn);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 改造4：初始化promise时也可能出错，若出错，直接调用reject</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    reject(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"promise-需要异步\"><a href=\"#promise-需要异步\" class=\"headerlink\" title=\"promise 需要异步\"></a>promise 需要异步</h2><p>PromiseA+规范要求解决程序，也就是 resolve 和 reject 的执行都是异步的。</p>\n<p>所以我们需要对<code>handle</code>函数做异步调用，我们使用<code>setTimeout</code>模拟。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> catcher = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        newV.then(resolve);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      value = newV;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">        handle(deferred);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">    value = err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!catcher) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 改造：因为promise是异步的，所有操作需要异步处理</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> handleCallback;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">          handleCallback = handler.onResolved;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">          handleCallback = handler.onRejected;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handleCallback) &#123;</span><br><span class=\"line\">          handledValue = handleCallback(handledValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        handler.reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      handler.resolve(handledValue);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">        onRejected,</span><br><span class=\"line\">        reject,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    catcher = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, fn);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    reject(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-all-方法\"><a href=\"#Promise-all-方法\" class=\"headerlink\" title=\"Promise.all 方法\"></a>Promise.all 方法</h2><ul>\n<li>接收一个数组，数组成员都是<code>promise</code>。</li>\n<li>数组中所有的<code>promise</code>都<code>resolved</code>，整体才能<code>resolve</code>，否则<code>reject</code>掉第一个出错的数组成员<code>promise</code>。</li>\n<li>该函数返回一个新的<code>promise</code>，终值是所有数组成员的终值构成的数组。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">      arr[i]</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          resArr.push(r);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resolve(resArr);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这个版本的实现虽然可以达到<code>promise</code>基本的功能，但是思路有点绕。</p>\n<p>而且有个<code>bug</code>，未实现<code>catch</code>和<code>onRejected</code>函数的话，不会抛错，内部逻辑里<code>handle</code>函数判断已经<code>reject</code>了，不在会设置<code>deferred</code>，导致静默报错了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>实现一个<code>Promise</code>。</p>\n<p>原生的语法如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>看起来很简单，就是函数有个<code>then</code>方法呗。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">miniPromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">then</span>: <span class=\"function\">(<span class=\"params\">callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\">      callback(value);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">miniPromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实现了一个完全只是语法糖的<code>promise</code> 😁，并没有什么用。</p>\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><ol>\n<li>promise 接收一个函数 fn，创建 promise 时，fn 自动执行，且 fn 接收<code>resolve</code>。</li>\n<li>函数有个<code>then</code>方法，接收一个回调函数，回调函数接收终值。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">    callback = cb;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    callback(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码执行会报错，<code>callback</code>不是一个函数。分析看出<code>MyPromise</code>执行时调用了<code>resolve</code>方法，里面通过<code>callback</code>得到值，但是此时<code>then</code>还未调用呢，<code>callback</code>是 <code>null</code></p>\n<p>所以 我们需要等到<code>then</code>注册完<code>callback</code>后在调用，可以将<code>callback</code>异步执行（下一个事件循环），保证同步注册的<code>then</code>函数先触发去注册<code>callback</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">    callback = cb;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      callback(value);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyPromise(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>看起来可以正常跑，只是当<code>then</code>异步调用时，发现又不管用了。</p>\n<h2 id=\"加入状态机制\"><a href=\"#加入状态机制\" class=\"headerlink\" title=\"加入状态机制\"></a>加入状态机制</h2><p>我们来引入<code>promise</code>的状态机来解决异步注册的问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 如果resolve时，已经有注册过函数，则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      deferred(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = onResolved;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      onResolved(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>deferred</code>和<code>onResolved</code>其实是同一个东西，只不过如果<code>state</code>还是<code>pedding</code>状态，则<code>onResolved</code>需要延迟到<code>resolve</code>调用后执行。所以我们可以统一调度调用<code>deferred</code>（或者说是<code>onResolved</code>）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 如果resolve时，已经有注册过函数，则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      deferred(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 统一调度调用onResolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = onResolved;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onResolved(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    handle(onResolved);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码已经实现了<code>promise</code>的基本功能。即便是异步<code>resolve</code>也可以获取到终值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"then-返回新的-promise\"><a href=\"#then-返回新的-promise\" class=\"headerlink\" title=\"then 返回新的 promise\"></a>then 返回新的 promise</h2><ul>\n<li><code>then</code>方法返回一个<code>promise</code>，并接受前一个上一个的<code>then</code>返回值作为入参。</li>\n<li>如果上一个<code>then</code>没有注册<code>resolved</code>方法，则透传之前的终值。</li>\n<li>如果上一个<code>then</code>有注册<code>resolved</code>方法，执行，并将执行结果传递给下一个<code>then</code></li>\n</ul>\n<p>我们先看下原生的效果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then 返回新的promise。因为可以链式调用then。</span></span><br><span class=\"line\"><span class=\"comment\">// 链式的then并非之前的promise，而是新的promise</span></span><br><span class=\"line\">p.then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 前2个then没有获取到终值，透传终值1</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：上面 2 个调用有个很有意思的地方，透传的有 3 个 then，非直接透传的有 2 个 then，打印结果，先 2，后 1。因为透传的多了一层 then</p>\n</blockquote>\n<p>现在我们来改造<code>MyPromise</code></p>\n<ol>\n<li><code>then</code>可能注册了<code>onResolved</code>，也可能没有，没有则需要透传终值，要改状态</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 统一调度调用onResolved</span></span><br><span class=\"line\">  <span class=\"comment\">// 改造3：接收的是个对象了，所以要改</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler.onResolved) &#123;</span><br><span class=\"line\">      handledValue = handler.onResolved(handledValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将处理过或默认的终值传递给能够确定终值和状态的resolve</span></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！</span></span><br><span class=\"line\">      <span class=\"comment\">// 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。</span></span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来调用试试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>打印顺序是 1，2，并非原生的 2，1。因为我们模拟的函数里并没有让 then 异步处理，而是同步的。</p>\n</blockquote>\n<h2 id=\"如果-then-返回的是-promise\"><a href=\"#如果-then-返回的是-promise\" class=\"headerlink\" title=\"如果 then 返回的是 promise\"></a>如果 then 返回的是 promise</h2><p>上面的链式调用，只处理了普通的终值，如果终值本身就是<code>promise</code>的话，我们就需要在<code>then</code>中对终值在进行<code>then</code>的写法，嵌套会越来越深。如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.then(<span class=\"function\"><span class=\"params\">promise1</span> =&gt;</span> &#123;</span><br><span class=\"line\">  promise1.then(<span class=\"function\"><span class=\"params\">promise2</span> =&gt;</span> &#123;</span><br><span class=\"line\">    promise2.then(<span class=\"function\"><span class=\"params\">promise3</span> =&gt;</span> &#123;</span><br><span class=\"line\">      promise3.then(...)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>看看原生是怎么处理的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">2</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v, time[<span class=\"number\">1</span>] - time[<span class=\"number\">0</span>]); <span class=\"comment\">// 2 3000</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>原生的 <code>promise.then</code>返回的如果是新的<code>promise</code>，则后续的链都是以这个新的<code>promise</code>的<code>resolved</code>后的终值来传递了，跟最开始的旧<code>promise</code>无关了。<br>所以我们要对<code>then</code>返回的是<code>promise</code>做个判断处理，如果<code>then</code>返回的是一个<code>promise</code>，等待其<code>resolved</code>后，传递它的终值。</p>\n<p>因为无论有没有上一个<code>promise</code>注册的<code>onResolved</code>方法，最终都会走<code>resolve</code>来确定新<code>promise</code>的状态和终值，我们就在<code>resolve</code>做判断处理就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// resolve的工作是将状态切换为resolved</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造5：如果接收到的终值是一个promise，则调用其then方法，终止旧的promise，开启基于返回的新的promise进行传递</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      newV.then(resolve);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"comment\">// 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 统一调度调用onResolved</span></span><br><span class=\"line\">  <span class=\"comment\">// 改造3：接收的是个对象了，所以要改</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler.onResolved) &#123;</span><br><span class=\"line\">      handledValue = handler.onResolved(handledValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将处理过或默认的终值传递给能够确定终值和状态的resolve</span></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// then 注册一个onResolved方法，接收终值</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！</span></span><br><span class=\"line\">      <span class=\"comment\">// 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。</span></span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试看看</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"number\">2</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">).then(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  time.push(<span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v, time[<span class=\"number\">1</span>] - time[<span class=\"number\">0</span>]); <span class=\"comment\">// 2 3009</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h2><p><code>promise</code>的异常处理<code>rejected</code>，我们来加上。</p>\n<p>先看原生的用法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;is a error&#x27;</span>));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// 捕获异常打印</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，初始化时加入了<code>reject</code>函数，接收一个<code>Error</code>类型的值。在<code>then</code>中第二个参数，来接收该错误，处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      newV.then(resolve);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">    value = newV;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 改造1：增加reject函数，将状态变为 rejected。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">    value = err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 改造6：handler比之前多了onRejected和reject，根据state状态调用对应的then处理函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handleCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">      handleCallback = handler.onResolved;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">      handleCallback = handler.onRejected;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handleCallback) &#123;</span><br><span class=\"line\">      handledValue = handleCallback(handledValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 改造4：then方法接收第二个参数处理error</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">        <span class=\"comment\">// 改造5：将上一个处理异常的onRejected和当前reject交给handle来统一调度</span></span><br><span class=\"line\">        onRejected,</span><br><span class=\"line\">        reject,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">//改造3：接收第二个参数reject</span></span><br><span class=\"line\">  fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;hello&#x27;</span>));</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;succ&#x27;</span>, v);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;fail&#x27;</span>, err); <span class=\"comment\">// fail Error: hello</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"promise-catch\"><a href=\"#promise-catch\" class=\"headerlink\" title=\"promise.catch\"></a>promise.catch</h2><p>平时捕获异常用的最多的应该还是<code>promise.catch</code>。</p>\n<p>我们来看下原生的用法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 已知错误</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">&#x27;123&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then().catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 未知错误，通常在resolve执行中，或then的onResolved出错，我们也应该捕获。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>尝试实现下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"comment\">// 改造5：标志符，用来控制实例化promise时有无注册catch来控制抛错还是用catch(实际上就是then中的onResovled)处理</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> catcher = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 改造1：捕获resolve可能出现的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        newV.then(resolve);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      value = newV;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">        handle(deferred);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">    value = err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!catcher) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 改造3：因为promise是异步的，所有操作需要异步处理</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handleCallback;</span><br><span class=\"line\">    <span class=\"comment\">// 改造2：捕获handle传入的处理函数时可能出现的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">        handleCallback = handler.onResolved;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">        handleCallback = handler.onRejected;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handleCallback) &#123;</span><br><span class=\"line\">        handledValue = handleCallback(handledValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      handler.reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handler.resolve(handledValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">        onRejected,</span><br><span class=\"line\">        reject,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// catch方法也会返回一个promise，实际上就等于then方法第一个参数不传，第二个参数处理err</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果注册了catch，则异常交给catch来做</span></span><br><span class=\"line\">    catcher = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 注册catch</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, fn);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 改造4：初始化promise时也可能出错，若出错，直接调用reject</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    reject(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"promise-需要异步\"><a href=\"#promise-需要异步\" class=\"headerlink\" title=\"promise 需要异步\"></a>promise 需要异步</h2><p>PromiseA+规范要求解决程序，也就是 resolve 和 reject 的执行都是异步的。</p>\n<p>所以我们需要对<code>handle</code>函数做异步调用，我们使用<code>setTimeout</code>模拟。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pedding&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> catcher = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">newV</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newV &amp;&amp; <span class=\"keyword\">typeof</span> newV.then === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        newV.then(resolve);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      state = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      value = newV;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">        handle(deferred);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    state = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">    value = err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</span><br><span class=\"line\">      handle(deferred);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!catcher) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;pedding&#x27;</span>) &#123;</span><br><span class=\"line\">      deferred = handler;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 改造：因为promise是异步的，所有操作需要异步处理</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> handledValue = value;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> handleCallback;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">          handleCallback = handler.onResolved;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">          handleCallback = handler.onRejected;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handleCallback) &#123;</span><br><span class=\"line\">          handledValue = handleCallback(handledValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        handler.reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      handler.resolve(handledValue);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      handle(&#123;</span><br><span class=\"line\">        onResolved,</span><br><span class=\"line\">        resolve,</span><br><span class=\"line\">        onRejected,</span><br><span class=\"line\">        reject,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    catcher = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, fn);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    reject(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-all-方法\"><a href=\"#Promise-all-方法\" class=\"headerlink\" title=\"Promise.all 方法\"></a>Promise.all 方法</h2><ul>\n<li>接收一个数组，数组成员都是<code>promise</code>。</li>\n<li>数组中所有的<code>promise</code>都<code>resolved</code>，整体才能<code>resolve</code>，否则<code>reject</code>掉第一个出错的数组成员<code>promise</code>。</li>\n<li>该函数返回一个新的<code>promise</code>，终值是所有数组成员的终值构成的数组。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">      arr[i]</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          resArr.push(r);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resolve(resArr);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这个版本的实现虽然可以达到<code>promise</code>基本的功能，但是思路有点绕。</p>\n<p>而且有个<code>bug</code>，未实现<code>catch</code>和<code>onRejected</code>函数的话，不会抛错，内部逻辑里<code>handle</code>函数判断已经<code>reject</code>了，不在会设置<code>deferred</code>，导致静默报错了。</p>\n"},{"title":"探究JS继承","date":"2020-12-29T16:00:00.000Z","_content":"\nJS 世界的继承如何实现，原型在继承中的作用，以前的继承和现在的继承。\n\n## 原型查找机制\n\nJS 中继承依赖原型实现，访问一个实例不存在的属性时，会去实例的原型对象上查找。\n\n```js\nfunction Parent() {}\nParent.prototype.run = true;\nvar person = new Parent();\nperson.run; // true\n```\n\n如果实例原型上不存在，则会去实例原型的原型上查找，以此类推直到**原型顶端，也就是 null**。\n\n```js\nvar a = {};\na.__proto__; // Object.prototype\na.__proto__.__proto__; // 也就是 Object.prototype.__proto__  = null\n```\n\nJS 中一切皆对象，函数也是对象，我们看看函数的**原型链**（原型-原型-原型-...这种链式，被称为原型链）\n\n```js\nfunction b() {}\nb.__proto__ === Function.prototype; // true f () { [native code] } 也就是 Function.prototype\nb.__proto__.__proto__ === Object.prototype; // true 也就是Function.prototype.__proto__，别忘了Function.prototype也是对象，所以其原型是 Object.prototype。这也说明了，JS中一切皆对象！\nb.__proto__.__proto__.__proto__ === null; // true Object.prototype.__proto__ === null 到头了\n```\n\n配合 JS 原型链查找机制，因此出现了 JS 版本的继承。\n\n## new 实例化\n\nJS 中通过`构造函数`来模拟类，通过`prototype`来模拟继承。类的实例化则需要用`new`关键字，`new F()`。我们看看`new`做了些什么：\n\n```js\nfunction Person() {}\nvar a = new Person();\n```\n\n目前我们就看到`new`做了三件事：\n\n1. 创建了一个新的对象\n2. 返回了该对象\\*\\*赋值给了`a变量`。\n3. 并且 a 实例的`[[Prototype]]`关联到了`Person.prototype`，我们可以通过 a.xx 访问到`Person.prototype`的方法和属性，还记得吧！\n\n因为构造函数模拟了类，类是可以有属性和方法的，我们来给上面的`Person`类加点料\n\n```js\nfunction Person(name) {\n  this.name = name; // 类属性\n  this.sayHi = function () {\n    // 类方法\n    console.log(`Hi ${this.name}`);\n  };\n}\n\nvar a = new Person('Jack');\na.name; // Jack\na.sayHi(); // Hi Jack\n\nvar b = new Person('Loose');\nb.name; // Loose\nb.sayHi(); // Hi Loose\n```\n\n可以看到，通过`Person`类，我们声明了 2 个实例 `a 和 b`，分别访问 `name` 和 `sayHi` 方法，使用了实例自己的 `name` 值，所以`Person`类在实例化时，里面的 `this` 指向了实例对象。\n\n所以`new`一共做了四件事。\n\n4. 实例化时将 this 指向新的对象。\n\n模拟实现一个简单的`new`\n\n```js\n// function myNew(Constructor, Params) : object\nfunction myNew(fn) {\n  var obj = {};\n  obj.__proto__ = fn.prototype; // 或者 var obj = Object.create(fn.prototype)\n  var result = fn.apply(obj, [].slice.call(arguments, 1)); // 调用构造函数fn，并且注意绑定this到新对象，这里就是obj。给构造函数fn的其他参数要排除fn自身。\n  return typeof result === 'object' ? result : obj;\n}\n```\n\n## 谁继承谁\n\n只有一个类，谈不上继承，至少需要一个父类，一个子类继承父类。JS 继承依赖的是原型，请牢记！\n\n接着，先看一个错误的例子\n\n```js\nfunction Parent() {}\nfunction Son() {}\nSon.prototype = Parent.prototype; // 这不是继承，这是赤裸裸的让子类原型 和 父类原型 指向同一个对象。\nSon.prototype.constructor = Son; // 纠正上面一行导致constructor被改写的问题，让它指向正确值\n\nvar son = new Son();\nson.constructor === Son; // true 没问题，毕竟上面重写了constructor\nson.__proto__ === Son.prototype; // true\nson.__proto__ === Parent.prototype; // true\nson.__proto__.__proto__ === Object.prototype; // true\n\n// 而且\nvar parent = new Parent();\nparent.constructor === Parent; // false 因为父子类原型都相等了，且上Son.prototype.constructor = Son，导致父类实例现在出问题了。\n```\n\n上面的例子并没有体现`Son`继承了`Parent`，而是直接让父子类的原型相等了，还导致父类实例的`constructor`指向到了`Son`上，完全错误！\n\n原型继承要达到的是子类原型 继承自 父类的原型，也就是`son.__proto__.__proto__ === Parent.prototype`，且父类实例和子类实例的`constructor`都要指向正确的值才对。\n\n我们看看正确的写法\n\n```js\nfunction Parent() {}\nfunction Son() {}\nSon.prototype = new Parent(); // 这里实现继承！new Parent()返回了一个对象，这里是一个空的{}，但是其原型指向的时Parent.prototype对象哦，也就是{constructor: Parent}\nSon.prototype.constructor = Son;\n\nvar son = new Son();\nson.constructor === Son; // true\nson.__proto__ === Son.prototype; // true\nson.__proto__.__proto__ === Parent.prototype; // true\n\nvar parent = new Parent();\nparent.constructor === Parent; // true\n```\n\n这下没问题了，可以看到`son`实例的原型指向`Son类`，而`Son类`又继承自`Parent类`。各自类实例的`constructor`指向也正确。\n\n## 继承版本演进\n\n### 常见形式（原型继承）\n\n最常见的形式是将属性写在构造函数中，方法写在原型对象上。\n\n```js\nfunction Parent() {\n  this.arr = [];\n}\n\nParent.prototype.print = function () {\n  console.log(this.arr);\n};\n\nfunction Son() {}\n\nSon.prototype = new Parent(); // *\nSon.prototype.constructor = Son;\n\nvar son = new Son();\n\nson.arr.push(1);\n\nson.print(); // [1]\n\nvar son2 = new Son();\nson2.print(); // [1]\n```\n\nson2 不应该打印出`[1]`。原因是上面\\*所在的代码导致，`Son.prototype`等于`{arr: []}`，后面实例化的`son1 son2`访问的都是原型上的`arr`，引用类型，因此`son2.arr`也打印`[1]`。\n\n子类实例共享了原型对象上的属性，这种继承是有问题的。所以解决方案就是共享属性移到每个实例自己身上就可以了。\n\n### 组合继承模式（借用构造函数+原型继承）\n\n借用构造函数，意思是`Parent`在`Son`中调用，类似`class`继承中的`super`调用。注意处理`this`指向，毕竟是借用，`this`需要指向`Son`，不然借用无意义。另外，借用还让我们有机会往父类构造函数传参。\n\n```js\nfunction Parent(name) {\n  this.arr = [];\n  this.name = name;\n}\nParent.prototype.print = function () {\n  console.log(this.arr);\n};\nParent.prototype.say = function () {\n  console.log(`Hi ${this.name}`);\n};\nfunction Son(name) {\n  Parent.call(this, name); // *\n}\nSon.prototype = new Parent();\nSon.prototype.constructor = Son;\n\nvar son1 = new Son('1st son');\nson1.arr.push(1); // [1]\n\nvar son2 = new Son('2rd son');\nson2.print(); // []\n\nson1.arr === son2.arr; // false\n\nson1.say(); // 1st son\nson2.say(); // 2rd son\n```\n\n上面的\\*实现了借用构造功能，调用时，this 指向的是 son 实例本身，因此`Parent`构造函数中的代码会往实例本身添加`arr`和`name`属性。`Son`实例各自拥有自身属性，但方法依旧共享`Parent.prototype`上的。\n\n这种模式的缺点在于：\n\n- `Parent`被调用了 2 次，一次是`Son`内借用，一次是`Son.prototype`设置\n- `arr`和`name`属性也被创建了 2 次，因为`Parent`调用了 2 次。在`Son`的实例身上和`Son.prototype`原型身上分别创建了，然后 **遮蔽效应** 让我们在访问 `son1.arr`时，优先从自身找到`arr`属性，而不是原型上的。从下图我们可以看出。\n\n![组合继承](/images/Jietu20200529-212414.jpg)\n\n### 寄生组合式继承\n\n上面的组合继承的缺点就是调用了 2 次，那我们就想办法只调用一次`Parent`就可以了。\n\n分析下，`Son`在通过`new`实例化的时候，需要将属性挂载到实例身上，否则多个实例就共用了属性，所以`Son`内的借用构造函数不能省略，这是让`Son`实例有自身属性的唯一办法。那就只能从`Son.prototype = new Parent()`身上想办法，用别的方式来继承。\n\n#### Object.create(proto[, propertiesObject])\n\n这个是 ES 标准中的方法，创建一个新对象，使用传入的`proto`作为原型，并返回这个新对象。第二个参数是自定义新对象的一些属性，和`Object.defineProperties`方法的参数一样。\n\n```js\nvar parentProto = {\n  say: function () {\n    console.log('say hi');\n  },\n};\n\nvar obj = Object.create(parentProto);\nobj.say(); // say hi\nobj.__proto__ === parentProto; // true\n```\n\n但这个方法也有一个缺陷，就是引用类型值共享了。\n\n```js\nvar parentProto = {\n  arr: [],\n};\nvar o1 = Object.create(parentProto);\nvar o2 = Object.create(parentProto);\n\no1.arr.push(1);\nconsole.log(o2.arr); // [1] 因为访问的都是原型对象上的arr。\n```\n\n##### 模拟 Object.create\n\nIE9 以下是不支持这个方法的，所以考虑到浏览器兼容，我们可以模拟这个方法。\n\n模拟的关键就是理解`Object.create`干了什么事。\n\n1. 创建了一个新的对象\n2. 将参数设置为新对象的原型\n3. 返回这个新对象。\n\n```js\nfunction ObjectCreate(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n```\n\n功能如`Object.create`\n\n```js\nfunction ObjectCreate(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n\nvar parentProto = {\n  say: function () {\n    console.log('say hi');\n  },\n};\n\nvar obj = ObjectCreate(parentProto);\nobj.say(); // say hi\n```\n\n寄生组合式继承需要用到的**关联原型**我们已经说清楚，该功能就是用来解决寄生组合继承开篇说到的`Parent`被多`new`了一次来关联原型。\n\n我们来用寄生组合模式重写组合继承模式中 demo。\n\n```js\nfunction Parent(name) {\n  this.arr = [];\n  this.name = name;\n}\nParent.prototype.print = function () {\n  console.log(this.arr);\n};\nParent.prototype.say = function () {\n  console.log(`Hi ${this.name}`);\n};\nfunction Son(name) {\n  Parent.call(this, name);\n}\n// Son.prototype = new Parent();\nSon.prototype = Object.create(Parent.prototype); // 原型关联方法改造。兼容IE9以下可以使用上面的模拟Object.create函数ObjectCreate\nSon.prototype.constructor = Son;\n\nvar son1 = new Son('1st son');\nson1.arr.push(1); // [1]\n\nvar son2 = new Son('2rd son');\nson2.print(); // []\n\nson1.arr === son2.arr; // false\n\nson1.say(); // 1st son\nson2.say(); // 2rd son\n```\n\n从下图可以看出，属性没有重复声明了。\n![寄生组合式继承](/images/Jietu20200529-212609.jpg)\n\n### ES6+的继承\n\n自从 ES6 推出了`class`和`extends`语法后，JS 中继变得简单了，可以将新的语法看成是函数继承的语法糖，核心功能还是通过`prototpye`来实现继承，之外有些表现是不同于 ES5 的继承。\n\n使用新语法改写上面的父子类 demo\n\n```js\nclass Parent {\n  constructor(name) {\n    this.arr = [];\n    this.name = name;\n  }\n\n  print() {\n    console.log(this.arr);\n  }\n\n  say() {\n    console.log(`Hi ${this.name}`);\n  }\n}\n\nclass Son extends Parent {\n  constructor(name) {\n    super(name);\n  }\n}\n\nlet son1 = new Son('1st son');\nlet son2 = new Son('2rd son');\n```\n\n有哪些区别？\n\n- `class`必须通过`new`调用\n- `class`上所有的属性和方法，均不可枚举。\n- `class`存在声明提升（赋值没有）\n- `class`继承，子类`constructor`里**必须先调用`super()`调用父类构造函数**。因为子类期望父类的`constructor`来完成 `new F()`干的事，否则没有新对象，无法赋值`this`\n- 因为函数就是内置`Function`的实例，所以`Son.__proto__`指向的是`Function.prototype`，而类写法`Son.__proto__`指向的是`Parent`，因为`Son`继承自`Parent`么，利索当然原型应该指向`Parent`，在通过`babel`转换语法后，可以看到实现是：\n\n```js\nfunction Parent() {}\nvar Son = Object.create(Parent);\n```\n\n# 总结\n\n1. 继承的根本就是原型链的继承（委托），不管是 ES5 还是 ES6+时代。\n2. ES5 时代前的继承是通过函数来模拟实现的。其中最完美的方式是**寄生组合式继承**，也就是基于`prototype`来书写公共方法，基于`Object.create`（模拟函数）来让子类关联父类的原型对象。\n3. 我们在 ES5 继承模式中，顺带也清楚了解的`new`的工作以及模拟`new`的实现，还有`Object.create`的工作及其模拟实现。\n4. ES6 时代的`class`语法，继承实现，以及它和函数继承的一些差别。\n","source":"_posts/2020/探究继承.md","raw":"---\ntitle: 探究JS继承\ndate: 2020/12/30\n---\n\nJS 世界的继承如何实现，原型在继承中的作用，以前的继承和现在的继承。\n\n## 原型查找机制\n\nJS 中继承依赖原型实现，访问一个实例不存在的属性时，会去实例的原型对象上查找。\n\n```js\nfunction Parent() {}\nParent.prototype.run = true;\nvar person = new Parent();\nperson.run; // true\n```\n\n如果实例原型上不存在，则会去实例原型的原型上查找，以此类推直到**原型顶端，也就是 null**。\n\n```js\nvar a = {};\na.__proto__; // Object.prototype\na.__proto__.__proto__; // 也就是 Object.prototype.__proto__  = null\n```\n\nJS 中一切皆对象，函数也是对象，我们看看函数的**原型链**（原型-原型-原型-...这种链式，被称为原型链）\n\n```js\nfunction b() {}\nb.__proto__ === Function.prototype; // true f () { [native code] } 也就是 Function.prototype\nb.__proto__.__proto__ === Object.prototype; // true 也就是Function.prototype.__proto__，别忘了Function.prototype也是对象，所以其原型是 Object.prototype。这也说明了，JS中一切皆对象！\nb.__proto__.__proto__.__proto__ === null; // true Object.prototype.__proto__ === null 到头了\n```\n\n配合 JS 原型链查找机制，因此出现了 JS 版本的继承。\n\n## new 实例化\n\nJS 中通过`构造函数`来模拟类，通过`prototype`来模拟继承。类的实例化则需要用`new`关键字，`new F()`。我们看看`new`做了些什么：\n\n```js\nfunction Person() {}\nvar a = new Person();\n```\n\n目前我们就看到`new`做了三件事：\n\n1. 创建了一个新的对象\n2. 返回了该对象\\*\\*赋值给了`a变量`。\n3. 并且 a 实例的`[[Prototype]]`关联到了`Person.prototype`，我们可以通过 a.xx 访问到`Person.prototype`的方法和属性，还记得吧！\n\n因为构造函数模拟了类，类是可以有属性和方法的，我们来给上面的`Person`类加点料\n\n```js\nfunction Person(name) {\n  this.name = name; // 类属性\n  this.sayHi = function () {\n    // 类方法\n    console.log(`Hi ${this.name}`);\n  };\n}\n\nvar a = new Person('Jack');\na.name; // Jack\na.sayHi(); // Hi Jack\n\nvar b = new Person('Loose');\nb.name; // Loose\nb.sayHi(); // Hi Loose\n```\n\n可以看到，通过`Person`类，我们声明了 2 个实例 `a 和 b`，分别访问 `name` 和 `sayHi` 方法，使用了实例自己的 `name` 值，所以`Person`类在实例化时，里面的 `this` 指向了实例对象。\n\n所以`new`一共做了四件事。\n\n4. 实例化时将 this 指向新的对象。\n\n模拟实现一个简单的`new`\n\n```js\n// function myNew(Constructor, Params) : object\nfunction myNew(fn) {\n  var obj = {};\n  obj.__proto__ = fn.prototype; // 或者 var obj = Object.create(fn.prototype)\n  var result = fn.apply(obj, [].slice.call(arguments, 1)); // 调用构造函数fn，并且注意绑定this到新对象，这里就是obj。给构造函数fn的其他参数要排除fn自身。\n  return typeof result === 'object' ? result : obj;\n}\n```\n\n## 谁继承谁\n\n只有一个类，谈不上继承，至少需要一个父类，一个子类继承父类。JS 继承依赖的是原型，请牢记！\n\n接着，先看一个错误的例子\n\n```js\nfunction Parent() {}\nfunction Son() {}\nSon.prototype = Parent.prototype; // 这不是继承，这是赤裸裸的让子类原型 和 父类原型 指向同一个对象。\nSon.prototype.constructor = Son; // 纠正上面一行导致constructor被改写的问题，让它指向正确值\n\nvar son = new Son();\nson.constructor === Son; // true 没问题，毕竟上面重写了constructor\nson.__proto__ === Son.prototype; // true\nson.__proto__ === Parent.prototype; // true\nson.__proto__.__proto__ === Object.prototype; // true\n\n// 而且\nvar parent = new Parent();\nparent.constructor === Parent; // false 因为父子类原型都相等了，且上Son.prototype.constructor = Son，导致父类实例现在出问题了。\n```\n\n上面的例子并没有体现`Son`继承了`Parent`，而是直接让父子类的原型相等了，还导致父类实例的`constructor`指向到了`Son`上，完全错误！\n\n原型继承要达到的是子类原型 继承自 父类的原型，也就是`son.__proto__.__proto__ === Parent.prototype`，且父类实例和子类实例的`constructor`都要指向正确的值才对。\n\n我们看看正确的写法\n\n```js\nfunction Parent() {}\nfunction Son() {}\nSon.prototype = new Parent(); // 这里实现继承！new Parent()返回了一个对象，这里是一个空的{}，但是其原型指向的时Parent.prototype对象哦，也就是{constructor: Parent}\nSon.prototype.constructor = Son;\n\nvar son = new Son();\nson.constructor === Son; // true\nson.__proto__ === Son.prototype; // true\nson.__proto__.__proto__ === Parent.prototype; // true\n\nvar parent = new Parent();\nparent.constructor === Parent; // true\n```\n\n这下没问题了，可以看到`son`实例的原型指向`Son类`，而`Son类`又继承自`Parent类`。各自类实例的`constructor`指向也正确。\n\n## 继承版本演进\n\n### 常见形式（原型继承）\n\n最常见的形式是将属性写在构造函数中，方法写在原型对象上。\n\n```js\nfunction Parent() {\n  this.arr = [];\n}\n\nParent.prototype.print = function () {\n  console.log(this.arr);\n};\n\nfunction Son() {}\n\nSon.prototype = new Parent(); // *\nSon.prototype.constructor = Son;\n\nvar son = new Son();\n\nson.arr.push(1);\n\nson.print(); // [1]\n\nvar son2 = new Son();\nson2.print(); // [1]\n```\n\nson2 不应该打印出`[1]`。原因是上面\\*所在的代码导致，`Son.prototype`等于`{arr: []}`，后面实例化的`son1 son2`访问的都是原型上的`arr`，引用类型，因此`son2.arr`也打印`[1]`。\n\n子类实例共享了原型对象上的属性，这种继承是有问题的。所以解决方案就是共享属性移到每个实例自己身上就可以了。\n\n### 组合继承模式（借用构造函数+原型继承）\n\n借用构造函数，意思是`Parent`在`Son`中调用，类似`class`继承中的`super`调用。注意处理`this`指向，毕竟是借用，`this`需要指向`Son`，不然借用无意义。另外，借用还让我们有机会往父类构造函数传参。\n\n```js\nfunction Parent(name) {\n  this.arr = [];\n  this.name = name;\n}\nParent.prototype.print = function () {\n  console.log(this.arr);\n};\nParent.prototype.say = function () {\n  console.log(`Hi ${this.name}`);\n};\nfunction Son(name) {\n  Parent.call(this, name); // *\n}\nSon.prototype = new Parent();\nSon.prototype.constructor = Son;\n\nvar son1 = new Son('1st son');\nson1.arr.push(1); // [1]\n\nvar son2 = new Son('2rd son');\nson2.print(); // []\n\nson1.arr === son2.arr; // false\n\nson1.say(); // 1st son\nson2.say(); // 2rd son\n```\n\n上面的\\*实现了借用构造功能，调用时，this 指向的是 son 实例本身，因此`Parent`构造函数中的代码会往实例本身添加`arr`和`name`属性。`Son`实例各自拥有自身属性，但方法依旧共享`Parent.prototype`上的。\n\n这种模式的缺点在于：\n\n- `Parent`被调用了 2 次，一次是`Son`内借用，一次是`Son.prototype`设置\n- `arr`和`name`属性也被创建了 2 次，因为`Parent`调用了 2 次。在`Son`的实例身上和`Son.prototype`原型身上分别创建了，然后 **遮蔽效应** 让我们在访问 `son1.arr`时，优先从自身找到`arr`属性，而不是原型上的。从下图我们可以看出。\n\n![组合继承](/images/Jietu20200529-212414.jpg)\n\n### 寄生组合式继承\n\n上面的组合继承的缺点就是调用了 2 次，那我们就想办法只调用一次`Parent`就可以了。\n\n分析下，`Son`在通过`new`实例化的时候，需要将属性挂载到实例身上，否则多个实例就共用了属性，所以`Son`内的借用构造函数不能省略，这是让`Son`实例有自身属性的唯一办法。那就只能从`Son.prototype = new Parent()`身上想办法，用别的方式来继承。\n\n#### Object.create(proto[, propertiesObject])\n\n这个是 ES 标准中的方法，创建一个新对象，使用传入的`proto`作为原型，并返回这个新对象。第二个参数是自定义新对象的一些属性，和`Object.defineProperties`方法的参数一样。\n\n```js\nvar parentProto = {\n  say: function () {\n    console.log('say hi');\n  },\n};\n\nvar obj = Object.create(parentProto);\nobj.say(); // say hi\nobj.__proto__ === parentProto; // true\n```\n\n但这个方法也有一个缺陷，就是引用类型值共享了。\n\n```js\nvar parentProto = {\n  arr: [],\n};\nvar o1 = Object.create(parentProto);\nvar o2 = Object.create(parentProto);\n\no1.arr.push(1);\nconsole.log(o2.arr); // [1] 因为访问的都是原型对象上的arr。\n```\n\n##### 模拟 Object.create\n\nIE9 以下是不支持这个方法的，所以考虑到浏览器兼容，我们可以模拟这个方法。\n\n模拟的关键就是理解`Object.create`干了什么事。\n\n1. 创建了一个新的对象\n2. 将参数设置为新对象的原型\n3. 返回这个新对象。\n\n```js\nfunction ObjectCreate(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n```\n\n功能如`Object.create`\n\n```js\nfunction ObjectCreate(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n\nvar parentProto = {\n  say: function () {\n    console.log('say hi');\n  },\n};\n\nvar obj = ObjectCreate(parentProto);\nobj.say(); // say hi\n```\n\n寄生组合式继承需要用到的**关联原型**我们已经说清楚，该功能就是用来解决寄生组合继承开篇说到的`Parent`被多`new`了一次来关联原型。\n\n我们来用寄生组合模式重写组合继承模式中 demo。\n\n```js\nfunction Parent(name) {\n  this.arr = [];\n  this.name = name;\n}\nParent.prototype.print = function () {\n  console.log(this.arr);\n};\nParent.prototype.say = function () {\n  console.log(`Hi ${this.name}`);\n};\nfunction Son(name) {\n  Parent.call(this, name);\n}\n// Son.prototype = new Parent();\nSon.prototype = Object.create(Parent.prototype); // 原型关联方法改造。兼容IE9以下可以使用上面的模拟Object.create函数ObjectCreate\nSon.prototype.constructor = Son;\n\nvar son1 = new Son('1st son');\nson1.arr.push(1); // [1]\n\nvar son2 = new Son('2rd son');\nson2.print(); // []\n\nson1.arr === son2.arr; // false\n\nson1.say(); // 1st son\nson2.say(); // 2rd son\n```\n\n从下图可以看出，属性没有重复声明了。\n![寄生组合式继承](/images/Jietu20200529-212609.jpg)\n\n### ES6+的继承\n\n自从 ES6 推出了`class`和`extends`语法后，JS 中继变得简单了，可以将新的语法看成是函数继承的语法糖，核心功能还是通过`prototpye`来实现继承，之外有些表现是不同于 ES5 的继承。\n\n使用新语法改写上面的父子类 demo\n\n```js\nclass Parent {\n  constructor(name) {\n    this.arr = [];\n    this.name = name;\n  }\n\n  print() {\n    console.log(this.arr);\n  }\n\n  say() {\n    console.log(`Hi ${this.name}`);\n  }\n}\n\nclass Son extends Parent {\n  constructor(name) {\n    super(name);\n  }\n}\n\nlet son1 = new Son('1st son');\nlet son2 = new Son('2rd son');\n```\n\n有哪些区别？\n\n- `class`必须通过`new`调用\n- `class`上所有的属性和方法，均不可枚举。\n- `class`存在声明提升（赋值没有）\n- `class`继承，子类`constructor`里**必须先调用`super()`调用父类构造函数**。因为子类期望父类的`constructor`来完成 `new F()`干的事，否则没有新对象，无法赋值`this`\n- 因为函数就是内置`Function`的实例，所以`Son.__proto__`指向的是`Function.prototype`，而类写法`Son.__proto__`指向的是`Parent`，因为`Son`继承自`Parent`么，利索当然原型应该指向`Parent`，在通过`babel`转换语法后，可以看到实现是：\n\n```js\nfunction Parent() {}\nvar Son = Object.create(Parent);\n```\n\n# 总结\n\n1. 继承的根本就是原型链的继承（委托），不管是 ES5 还是 ES6+时代。\n2. ES5 时代前的继承是通过函数来模拟实现的。其中最完美的方式是**寄生组合式继承**，也就是基于`prototype`来书写公共方法，基于`Object.create`（模拟函数）来让子类关联父类的原型对象。\n3. 我们在 ES5 继承模式中，顺带也清楚了解的`new`的工作以及模拟`new`的实现，还有`Object.create`的工作及其模拟实现。\n4. ES6 时代的`class`语法，继承实现，以及它和函数继承的一些差别。\n","slug":"2020/探究继承","published":1,"updated":"2021-11-06T07:35:44.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz4000k6huf5cno5zoq","content":"<p>JS 世界的继承如何实现，原型在继承中的作用，以前的继承和现在的继承。</p>\n<h2 id=\"原型查找机制\"><a href=\"#原型查找机制\" class=\"headerlink\" title=\"原型查找机制\"></a>原型查找机制</h2><p>JS 中继承依赖原型实现，访问一个实例不存在的属性时，会去实例的原型对象上查找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype.run = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person.run; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果实例原型上不存在，则会去实例原型的原型上查找，以此类推直到<strong>原型顶端，也就是 null</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\">a.__proto__; <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\">a.__proto__.__proto__; <span class=\"comment\">// 也就是 Object.prototype.__proto__  = null</span></span><br></pre></td></tr></table></figure>\n\n<p>JS 中一切皆对象，函数也是对象，我们看看函数的<strong>原型链</strong>（原型-原型-原型-…这种链式，被称为原型链）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true f () &#123; [native code] &#125; 也就是 Function.prototype</span></span><br><span class=\"line\">b.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true 也就是Function.prototype.__proto__，别忘了Function.prototype也是对象，所以其原型是 Object.prototype。这也说明了，JS中一切皆对象！</span></span><br><span class=\"line\">b.__proto__.__proto__.__proto__ === <span class=\"literal\">null</span>; <span class=\"comment\">// true Object.prototype.__proto__ === null 到头了</span></span><br></pre></td></tr></table></figure>\n\n<p>配合 JS 原型链查找机制，因此出现了 JS 版本的继承。</p>\n<h2 id=\"new-实例化\"><a href=\"#new-实例化\" class=\"headerlink\" title=\"new 实例化\"></a>new 实例化</h2><p>JS 中通过<code>构造函数</code>来模拟类，通过<code>prototype</code>来模拟继承。类的实例化则需要用<code>new</code>关键字，<code>new F()</code>。我们看看<code>new</code>做了些什么：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p>目前我们就看到<code>new</code>做了三件事：</p>\n<ol>\n<li>创建了一个新的对象</li>\n<li>返回了该对象**赋值给了<code>a变量</code>。</li>\n<li>并且 a 实例的<code>[[Prototype]]</code>关联到了<code>Person.prototype</code>，我们可以通过 a.xx 访问到<code>Person.prototype</code>的方法和属性，还记得吧！</li>\n</ol>\n<p>因为构造函数模拟了类，类是可以有属性和方法的，我们来给上面的<code>Person</code>类加点料</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name; <span class=\"comment\">// 类属性</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类方法</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Jack&#x27;</span>);</span><br><span class=\"line\">a.name; <span class=\"comment\">// Jack</span></span><br><span class=\"line\">a.sayHi(); <span class=\"comment\">// Hi Jack</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Loose&#x27;</span>);</span><br><span class=\"line\">b.name; <span class=\"comment\">// Loose</span></span><br><span class=\"line\">b.sayHi(); <span class=\"comment\">// Hi Loose</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，通过<code>Person</code>类，我们声明了 2 个实例 <code>a 和 b</code>，分别访问 <code>name</code> 和 <code>sayHi</code> 方法，使用了实例自己的 <code>name</code> 值，所以<code>Person</code>类在实例化时，里面的 <code>this</code> 指向了实例对象。</p>\n<p>所以<code>new</code>一共做了四件事。</p>\n<ol start=\"4\">\n<li>实例化时将 this 指向新的对象。</li>\n</ol>\n<p>模拟实现一个简单的<code>new</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function myNew(Constructor, Params) : object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myNew</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">  obj.__proto__ = fn.prototype; <span class=\"comment\">// 或者 var obj = Object.create(fn.prototype)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = fn.apply(obj, [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)); <span class=\"comment\">// 调用构造函数fn，并且注意绑定this到新对象，这里就是obj。给构造函数fn的其他参数要排除fn自身。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> ? result : obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"谁继承谁\"><a href=\"#谁继承谁\" class=\"headerlink\" title=\"谁继承谁\"></a>谁继承谁</h2><p>只有一个类，谈不上继承，至少需要一个父类，一个子类继承父类。JS 继承依赖的是原型，请牢记！</p>\n<p>接着，先看一个错误的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Son.prototype = Parent.prototype; <span class=\"comment\">// 这不是继承，这是赤裸裸的让子类原型 和 父类原型 指向同一个对象。</span></span><br><span class=\"line\">Son.prototype.constructor = Son; <span class=\"comment\">// 纠正上面一行导致constructor被改写的问题，让它指向正确值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.constructor === Son; <span class=\"comment\">// true 没问题，毕竟上面重写了constructor</span></span><br><span class=\"line\">son.__proto__ === Son.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而且</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.constructor === Parent; <span class=\"comment\">// false 因为父子类原型都相等了，且上Son.prototype.constructor = Son，导致父类实例现在出问题了。</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子并没有体现<code>Son</code>继承了<code>Parent</code>，而是直接让父子类的原型相等了，还导致父类实例的<code>constructor</code>指向到了<code>Son</code>上，完全错误！</p>\n<p>原型继承要达到的是子类原型 继承自 父类的原型，也就是<code>son.__proto__.__proto__ === Parent.prototype</code>，且父类实例和子类实例的<code>constructor</code>都要指向正确的值才对。</p>\n<p>我们看看正确的写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 这里实现继承！new Parent()返回了一个对象，这里是一个空的&#123;&#125;，但是其原型指向的时Parent.prototype对象哦，也就是&#123;constructor: Parent&#125;</span></span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.constructor === Son; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__ === Son.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.constructor === Parent; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>这下没问题了，可以看到<code>son</code>实例的原型指向<code>Son类</code>，而<code>Son类</code>又继承自<code>Parent类</code>。各自类实例的<code>constructor</code>指向也正确。</p>\n<h2 id=\"继承版本演进\"><a href=\"#继承版本演进\" class=\"headerlink\" title=\"继承版本演进\"></a>继承版本演进</h2><h3 id=\"常见形式（原型继承）\"><a href=\"#常见形式（原型继承）\" class=\"headerlink\" title=\"常见形式（原型继承）\"></a>常见形式（原型继承）</h3><p>最常见的形式是将属性写在构造函数中，方法写在原型对象上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// *</span></span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\"></span><br><span class=\"line\">son.arr.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">son.print(); <span class=\"comment\">// [1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son2.print(); <span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<p>son2 不应该打印出<code>[1]</code>。原因是上面*所在的代码导致，<code>Son.prototype</code>等于<code>&#123;arr: []&#125;</code>，后面实例化的<code>son1 son2</code>访问的都是原型上的<code>arr</code>，引用类型，因此<code>son2.arr</code>也打印<code>[1]</code>。</p>\n<p>子类实例共享了原型对象上的属性，这种继承是有问题的。所以解决方案就是共享属性移到每个实例自己身上就可以了。</p>\n<h3 id=\"组合继承模式（借用构造函数-原型继承）\"><a href=\"#组合继承模式（借用构造函数-原型继承）\" class=\"headerlink\" title=\"组合继承模式（借用构造函数+原型继承）\"></a>组合继承模式（借用构造函数+原型继承）</h3><p>借用构造函数，意思是<code>Parent</code>在<code>Son</code>中调用，类似<code>class</code>继承中的<code>super</code>调用。注意处理<code>this</code>指向，毕竟是借用，<code>this</code>需要指向<code>Son</code>，不然借用无意义。另外，借用还让我们有机会往父类构造函数传参。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"built_in\">this</span>, name); <span class=\"comment\">// *</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;1st son&#x27;</span>);</span><br><span class=\"line\">son1.arr.push(<span class=\"number\">1</span>); <span class=\"comment\">// [1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;2rd son&#x27;</span>);</span><br><span class=\"line\">son2.print(); <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.arr === son2.arr; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.say(); <span class=\"comment\">// 1st son</span></span><br><span class=\"line\">son2.say(); <span class=\"comment\">// 2rd son</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的*实现了借用构造功能，调用时，this 指向的是 son 实例本身，因此<code>Parent</code>构造函数中的代码会往实例本身添加<code>arr</code>和<code>name</code>属性。<code>Son</code>实例各自拥有自身属性，但方法依旧共享<code>Parent.prototype</code>上的。</p>\n<p>这种模式的缺点在于：</p>\n<ul>\n<li><code>Parent</code>被调用了 2 次，一次是<code>Son</code>内借用，一次是<code>Son.prototype</code>设置</li>\n<li><code>arr</code>和<code>name</code>属性也被创建了 2 次，因为<code>Parent</code>调用了 2 次。在<code>Son</code>的实例身上和<code>Son.prototype</code>原型身上分别创建了，然后 <strong>遮蔽效应</strong> 让我们在访问 <code>son1.arr</code>时，优先从自身找到<code>arr</code>属性，而不是原型上的。从下图我们可以看出。</li>\n</ul>\n<p><img src=\"/images/Jietu20200529-212414.jpg\" alt=\"组合继承\"></p>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><p>上面的组合继承的缺点就是调用了 2 次，那我们就想办法只调用一次<code>Parent</code>就可以了。</p>\n<p>分析下，<code>Son</code>在通过<code>new</code>实例化的时候，需要将属性挂载到实例身上，否则多个实例就共用了属性，所以<code>Son</code>内的借用构造函数不能省略，这是让<code>Son</code>实例有自身属性的唯一办法。那就只能从<code>Son.prototype = new Parent()</code>身上想办法，用别的方式来继承。</p>\n<h4 id=\"Object-create-proto-propertiesObject\"><a href=\"#Object-create-proto-propertiesObject\" class=\"headerlink\" title=\"Object.create(proto[, propertiesObject])\"></a>Object.create(proto[, propertiesObject])</h4><p>这个是 ES 标准中的方法，创建一个新对象，使用传入的<code>proto</code>作为原型，并返回这个新对象。第二个参数是自定义新对象的一些属性，和<code>Object.defineProperties</code>方法的参数一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parentProto = &#123;</span><br><span class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;say hi&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(parentProto);</span><br><span class=\"line\">obj.say(); <span class=\"comment\">// say hi</span></span><br><span class=\"line\">obj.__proto__ === parentProto; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但这个方法也有一个缺陷，就是引用类型值共享了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parentProto = &#123;</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: [],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = <span class=\"built_in\">Object</span>.create(parentProto);</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = <span class=\"built_in\">Object</span>.create(parentProto);</span><br><span class=\"line\"></span><br><span class=\"line\">o1.arr.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o2.arr); <span class=\"comment\">// [1] 因为访问的都是原型对象上的arr。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模拟-Object-create\"><a href=\"#模拟-Object-create\" class=\"headerlink\" title=\"模拟 Object.create\"></a>模拟 Object.create</h5><p>IE9 以下是不支持这个方法的，所以考虑到浏览器兼容，我们可以模拟这个方法。</p>\n<p>模拟的关键就是理解<code>Object.create</code>干了什么事。</p>\n<ol>\n<li>创建了一个新的对象</li>\n<li>将参数设置为新对象的原型</li>\n<li>返回这个新对象。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ObjectCreate</span>(<span class=\"params\">proto</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>功能如<code>Object.create</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ObjectCreate</span>(<span class=\"params\">proto</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parentProto = &#123;</span><br><span class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;say hi&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = ObjectCreate(parentProto);</span><br><span class=\"line\">obj.say(); <span class=\"comment\">// say hi</span></span><br></pre></td></tr></table></figure>\n\n<p>寄生组合式继承需要用到的<strong>关联原型</strong>我们已经说清楚，该功能就是用来解决寄生组合继承开篇说到的<code>Parent</code>被多<code>new</code>了一次来关联原型。</p>\n<p>我们来用寄生组合模式重写组合继承模式中 demo。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Son.prototype = new Parent();</span></span><br><span class=\"line\">Son.prototype = <span class=\"built_in\">Object</span>.create(Parent.prototype); <span class=\"comment\">// 原型关联方法改造。兼容IE9以下可以使用上面的模拟Object.create函数ObjectCreate</span></span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;1st son&#x27;</span>);</span><br><span class=\"line\">son1.arr.push(<span class=\"number\">1</span>); <span class=\"comment\">// [1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;2rd son&#x27;</span>);</span><br><span class=\"line\">son2.print(); <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.arr === son2.arr; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.say(); <span class=\"comment\">// 1st son</span></span><br><span class=\"line\">son2.say(); <span class=\"comment\">// 2rd son</span></span><br></pre></td></tr></table></figure>\n\n<p>从下图可以看出，属性没有重复声明了。<br><img src=\"/images/Jietu20200529-212609.jpg\" alt=\"寄生组合式继承\"></p>\n<h3 id=\"ES6-的继承\"><a href=\"#ES6-的继承\" class=\"headerlink\" title=\"ES6+的继承\"></a>ES6+的继承</h3><p>自从 ES6 推出了<code>class</code>和<code>extends</code>语法后，JS 中继变得简单了，可以将新的语法看成是函数继承的语法糖，核心功能还是通过<code>prototpye</code>来实现继承，之外有些表现是不同于 ES5 的继承。</p>\n<p>使用新语法改写上面的父子类 demo</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">print</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">say</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;1st son&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> son2 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;2rd son&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有哪些区别？</p>\n<ul>\n<li><code>class</code>必须通过<code>new</code>调用</li>\n<li><code>class</code>上所有的属性和方法，均不可枚举。</li>\n<li><code>class</code>存在声明提升（赋值没有）</li>\n<li><code>class</code>继承，子类<code>constructor</code>里<strong>必须先调用<code>super()</code>调用父类构造函数</strong>。因为子类期望父类的<code>constructor</code>来完成 <code>new F()</code>干的事，否则没有新对象，无法赋值<code>this</code></li>\n<li>因为函数就是内置<code>Function</code>的实例，所以<code>Son.__proto__</code>指向的是<code>Function.prototype</code>，而类写法<code>Son.__proto__</code>指向的是<code>Parent</code>，因为<code>Son</code>继承自<code>Parent</code>么，利索当然原型应该指向<code>Parent</code>，在通过<code>babel</code>转换语法后，可以看到实现是：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Son = <span class=\"built_in\">Object</span>.create(Parent);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>继承的根本就是原型链的继承（委托），不管是 ES5 还是 ES6+时代。</li>\n<li>ES5 时代前的继承是通过函数来模拟实现的。其中最完美的方式是<strong>寄生组合式继承</strong>，也就是基于<code>prototype</code>来书写公共方法，基于<code>Object.create</code>（模拟函数）来让子类关联父类的原型对象。</li>\n<li>我们在 ES5 继承模式中，顺带也清楚了解的<code>new</code>的工作以及模拟<code>new</code>的实现，还有<code>Object.create</code>的工作及其模拟实现。</li>\n<li>ES6 时代的<code>class</code>语法，继承实现，以及它和函数继承的一些差别。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>JS 世界的继承如何实现，原型在继承中的作用，以前的继承和现在的继承。</p>\n<h2 id=\"原型查找机制\"><a href=\"#原型查找机制\" class=\"headerlink\" title=\"原型查找机制\"></a>原型查找机制</h2><p>JS 中继承依赖原型实现，访问一个实例不存在的属性时，会去实例的原型对象上查找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype.run = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person.run; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果实例原型上不存在，则会去实例原型的原型上查找，以此类推直到<strong>原型顶端，也就是 null</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\">a.__proto__; <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\">a.__proto__.__proto__; <span class=\"comment\">// 也就是 Object.prototype.__proto__  = null</span></span><br></pre></td></tr></table></figure>\n\n<p>JS 中一切皆对象，函数也是对象，我们看看函数的<strong>原型链</strong>（原型-原型-原型-…这种链式，被称为原型链）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true f () &#123; [native code] &#125; 也就是 Function.prototype</span></span><br><span class=\"line\">b.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true 也就是Function.prototype.__proto__，别忘了Function.prototype也是对象，所以其原型是 Object.prototype。这也说明了，JS中一切皆对象！</span></span><br><span class=\"line\">b.__proto__.__proto__.__proto__ === <span class=\"literal\">null</span>; <span class=\"comment\">// true Object.prototype.__proto__ === null 到头了</span></span><br></pre></td></tr></table></figure>\n\n<p>配合 JS 原型链查找机制，因此出现了 JS 版本的继承。</p>\n<h2 id=\"new-实例化\"><a href=\"#new-实例化\" class=\"headerlink\" title=\"new 实例化\"></a>new 实例化</h2><p>JS 中通过<code>构造函数</code>来模拟类，通过<code>prototype</code>来模拟继承。类的实例化则需要用<code>new</code>关键字，<code>new F()</code>。我们看看<code>new</code>做了些什么：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p>目前我们就看到<code>new</code>做了三件事：</p>\n<ol>\n<li>创建了一个新的对象</li>\n<li>返回了该对象**赋值给了<code>a变量</code>。</li>\n<li>并且 a 实例的<code>[[Prototype]]</code>关联到了<code>Person.prototype</code>，我们可以通过 a.xx 访问到<code>Person.prototype</code>的方法和属性，还记得吧！</li>\n</ol>\n<p>因为构造函数模拟了类，类是可以有属性和方法的，我们来给上面的<code>Person</code>类加点料</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name; <span class=\"comment\">// 类属性</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类方法</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Jack&#x27;</span>);</span><br><span class=\"line\">a.name; <span class=\"comment\">// Jack</span></span><br><span class=\"line\">a.sayHi(); <span class=\"comment\">// Hi Jack</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Loose&#x27;</span>);</span><br><span class=\"line\">b.name; <span class=\"comment\">// Loose</span></span><br><span class=\"line\">b.sayHi(); <span class=\"comment\">// Hi Loose</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，通过<code>Person</code>类，我们声明了 2 个实例 <code>a 和 b</code>，分别访问 <code>name</code> 和 <code>sayHi</code> 方法，使用了实例自己的 <code>name</code> 值，所以<code>Person</code>类在实例化时，里面的 <code>this</code> 指向了实例对象。</p>\n<p>所以<code>new</code>一共做了四件事。</p>\n<ol start=\"4\">\n<li>实例化时将 this 指向新的对象。</li>\n</ol>\n<p>模拟实现一个简单的<code>new</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function myNew(Constructor, Params) : object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myNew</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">  obj.__proto__ = fn.prototype; <span class=\"comment\">// 或者 var obj = Object.create(fn.prototype)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = fn.apply(obj, [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)); <span class=\"comment\">// 调用构造函数fn，并且注意绑定this到新对象，这里就是obj。给构造函数fn的其他参数要排除fn自身。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> ? result : obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"谁继承谁\"><a href=\"#谁继承谁\" class=\"headerlink\" title=\"谁继承谁\"></a>谁继承谁</h2><p>只有一个类，谈不上继承，至少需要一个父类，一个子类继承父类。JS 继承依赖的是原型，请牢记！</p>\n<p>接着，先看一个错误的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Son.prototype = Parent.prototype; <span class=\"comment\">// 这不是继承，这是赤裸裸的让子类原型 和 父类原型 指向同一个对象。</span></span><br><span class=\"line\">Son.prototype.constructor = Son; <span class=\"comment\">// 纠正上面一行导致constructor被改写的问题，让它指向正确值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.constructor === Son; <span class=\"comment\">// true 没问题，毕竟上面重写了constructor</span></span><br><span class=\"line\">son.__proto__ === Son.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而且</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.constructor === Parent; <span class=\"comment\">// false 因为父子类原型都相等了，且上Son.prototype.constructor = Son，导致父类实例现在出问题了。</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子并没有体现<code>Son</code>继承了<code>Parent</code>，而是直接让父子类的原型相等了，还导致父类实例的<code>constructor</code>指向到了<code>Son</code>上，完全错误！</p>\n<p>原型继承要达到的是子类原型 继承自 父类的原型，也就是<code>son.__proto__.__proto__ === Parent.prototype</code>，且父类实例和子类实例的<code>constructor</code>都要指向正确的值才对。</p>\n<p>我们看看正确的写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 这里实现继承！new Parent()返回了一个对象，这里是一个空的&#123;&#125;，但是其原型指向的时Parent.prototype对象哦，也就是&#123;constructor: Parent&#125;</span></span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.constructor === Son; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__ === Son.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\">son.__proto__.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.constructor === Parent; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>这下没问题了，可以看到<code>son</code>实例的原型指向<code>Son类</code>，而<code>Son类</code>又继承自<code>Parent类</code>。各自类实例的<code>constructor</code>指向也正确。</p>\n<h2 id=\"继承版本演进\"><a href=\"#继承版本演进\" class=\"headerlink\" title=\"继承版本演进\"></a>继承版本演进</h2><h3 id=\"常见形式（原型继承）\"><a href=\"#常见形式（原型继承）\" class=\"headerlink\" title=\"常见形式（原型继承）\"></a>常见形式（原型继承）</h3><p>最常见的形式是将属性写在构造函数中，方法写在原型对象上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// *</span></span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\"></span><br><span class=\"line\">son.arr.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">son.print(); <span class=\"comment\">// [1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son2.print(); <span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<p>son2 不应该打印出<code>[1]</code>。原因是上面*所在的代码导致，<code>Son.prototype</code>等于<code>&#123;arr: []&#125;</code>，后面实例化的<code>son1 son2</code>访问的都是原型上的<code>arr</code>，引用类型，因此<code>son2.arr</code>也打印<code>[1]</code>。</p>\n<p>子类实例共享了原型对象上的属性，这种继承是有问题的。所以解决方案就是共享属性移到每个实例自己身上就可以了。</p>\n<h3 id=\"组合继承模式（借用构造函数-原型继承）\"><a href=\"#组合继承模式（借用构造函数-原型继承）\" class=\"headerlink\" title=\"组合继承模式（借用构造函数+原型继承）\"></a>组合继承模式（借用构造函数+原型继承）</h3><p>借用构造函数，意思是<code>Parent</code>在<code>Son</code>中调用，类似<code>class</code>继承中的<code>super</code>调用。注意处理<code>this</code>指向，毕竟是借用，<code>this</code>需要指向<code>Son</code>，不然借用无意义。另外，借用还让我们有机会往父类构造函数传参。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"built_in\">this</span>, name); <span class=\"comment\">// *</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;1st son&#x27;</span>);</span><br><span class=\"line\">son1.arr.push(<span class=\"number\">1</span>); <span class=\"comment\">// [1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;2rd son&#x27;</span>);</span><br><span class=\"line\">son2.print(); <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.arr === son2.arr; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.say(); <span class=\"comment\">// 1st son</span></span><br><span class=\"line\">son2.say(); <span class=\"comment\">// 2rd son</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的*实现了借用构造功能，调用时，this 指向的是 son 实例本身，因此<code>Parent</code>构造函数中的代码会往实例本身添加<code>arr</code>和<code>name</code>属性。<code>Son</code>实例各自拥有自身属性，但方法依旧共享<code>Parent.prototype</code>上的。</p>\n<p>这种模式的缺点在于：</p>\n<ul>\n<li><code>Parent</code>被调用了 2 次，一次是<code>Son</code>内借用，一次是<code>Son.prototype</code>设置</li>\n<li><code>arr</code>和<code>name</code>属性也被创建了 2 次，因为<code>Parent</code>调用了 2 次。在<code>Son</code>的实例身上和<code>Son.prototype</code>原型身上分别创建了，然后 <strong>遮蔽效应</strong> 让我们在访问 <code>son1.arr</code>时，优先从自身找到<code>arr</code>属性，而不是原型上的。从下图我们可以看出。</li>\n</ul>\n<p><img src=\"/images/Jietu20200529-212414.jpg\" alt=\"组合继承\"></p>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><p>上面的组合继承的缺点就是调用了 2 次，那我们就想办法只调用一次<code>Parent</code>就可以了。</p>\n<p>分析下，<code>Son</code>在通过<code>new</code>实例化的时候，需要将属性挂载到实例身上，否则多个实例就共用了属性，所以<code>Son</code>内的借用构造函数不能省略，这是让<code>Son</code>实例有自身属性的唯一办法。那就只能从<code>Son.prototype = new Parent()</code>身上想办法，用别的方式来继承。</p>\n<h4 id=\"Object-create-proto-propertiesObject\"><a href=\"#Object-create-proto-propertiesObject\" class=\"headerlink\" title=\"Object.create(proto[, propertiesObject])\"></a>Object.create(proto[, propertiesObject])</h4><p>这个是 ES 标准中的方法，创建一个新对象，使用传入的<code>proto</code>作为原型，并返回这个新对象。第二个参数是自定义新对象的一些属性，和<code>Object.defineProperties</code>方法的参数一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parentProto = &#123;</span><br><span class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;say hi&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(parentProto);</span><br><span class=\"line\">obj.say(); <span class=\"comment\">// say hi</span></span><br><span class=\"line\">obj.__proto__ === parentProto; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但这个方法也有一个缺陷，就是引用类型值共享了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parentProto = &#123;</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: [],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = <span class=\"built_in\">Object</span>.create(parentProto);</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = <span class=\"built_in\">Object</span>.create(parentProto);</span><br><span class=\"line\"></span><br><span class=\"line\">o1.arr.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o2.arr); <span class=\"comment\">// [1] 因为访问的都是原型对象上的arr。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模拟-Object-create\"><a href=\"#模拟-Object-create\" class=\"headerlink\" title=\"模拟 Object.create\"></a>模拟 Object.create</h5><p>IE9 以下是不支持这个方法的，所以考虑到浏览器兼容，我们可以模拟这个方法。</p>\n<p>模拟的关键就是理解<code>Object.create</code>干了什么事。</p>\n<ol>\n<li>创建了一个新的对象</li>\n<li>将参数设置为新对象的原型</li>\n<li>返回这个新对象。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ObjectCreate</span>(<span class=\"params\">proto</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>功能如<code>Object.create</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ObjectCreate</span>(<span class=\"params\">proto</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parentProto = &#123;</span><br><span class=\"line\">  <span class=\"attr\">say</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;say hi&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = ObjectCreate(parentProto);</span><br><span class=\"line\">obj.say(); <span class=\"comment\">// say hi</span></span><br></pre></td></tr></table></figure>\n\n<p>寄生组合式继承需要用到的<strong>关联原型</strong>我们已经说清楚，该功能就是用来解决寄生组合继承开篇说到的<code>Parent</code>被多<code>new</code>了一次来关联原型。</p>\n<p>我们来用寄生组合模式重写组合继承模式中 demo。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Son.prototype = new Parent();</span></span><br><span class=\"line\">Son.prototype = <span class=\"built_in\">Object</span>.create(Parent.prototype); <span class=\"comment\">// 原型关联方法改造。兼容IE9以下可以使用上面的模拟Object.create函数ObjectCreate</span></span><br><span class=\"line\">Son.prototype.constructor = Son;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;1st son&#x27;</span>);</span><br><span class=\"line\">son1.arr.push(<span class=\"number\">1</span>); <span class=\"comment\">// [1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;2rd son&#x27;</span>);</span><br><span class=\"line\">son2.print(); <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.arr === son2.arr; <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">son1.say(); <span class=\"comment\">// 1st son</span></span><br><span class=\"line\">son2.say(); <span class=\"comment\">// 2rd son</span></span><br></pre></td></tr></table></figure>\n\n<p>从下图可以看出，属性没有重复声明了。<br><img src=\"/images/Jietu20200529-212609.jpg\" alt=\"寄生组合式继承\"></p>\n<h3 id=\"ES6-的继承\"><a href=\"#ES6-的继承\" class=\"headerlink\" title=\"ES6+的继承\"></a>ES6+的继承</h3><p>自从 ES6 推出了<code>class</code>和<code>extends</code>语法后，JS 中继变得简单了，可以将新的语法看成是函数继承的语法糖，核心功能还是通过<code>prototpye</code>来实现继承，之外有些表现是不同于 ES5 的继承。</p>\n<p>使用新语法改写上面的父子类 demo</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.arr = [];</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">print</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">say</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;1st son&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> son2 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;2rd son&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有哪些区别？</p>\n<ul>\n<li><code>class</code>必须通过<code>new</code>调用</li>\n<li><code>class</code>上所有的属性和方法，均不可枚举。</li>\n<li><code>class</code>存在声明提升（赋值没有）</li>\n<li><code>class</code>继承，子类<code>constructor</code>里<strong>必须先调用<code>super()</code>调用父类构造函数</strong>。因为子类期望父类的<code>constructor</code>来完成 <code>new F()</code>干的事，否则没有新对象，无法赋值<code>this</code></li>\n<li>因为函数就是内置<code>Function</code>的实例，所以<code>Son.__proto__</code>指向的是<code>Function.prototype</code>，而类写法<code>Son.__proto__</code>指向的是<code>Parent</code>，因为<code>Son</code>继承自<code>Parent</code>么，利索当然原型应该指向<code>Parent</code>，在通过<code>babel</code>转换语法后，可以看到实现是：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Son = <span class=\"built_in\">Object</span>.create(Parent);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>继承的根本就是原型链的继承（委托），不管是 ES5 还是 ES6+时代。</li>\n<li>ES5 时代前的继承是通过函数来模拟实现的。其中最完美的方式是<strong>寄生组合式继承</strong>，也就是基于<code>prototype</code>来书写公共方法，基于<code>Object.create</code>（模拟函数）来让子类关联父类的原型对象。</li>\n<li>我们在 ES5 继承模式中，顺带也清楚了解的<code>new</code>的工作以及模拟<code>new</code>的实现，还有<code>Object.create</code>的工作及其模拟实现。</li>\n<li>ES6 时代的<code>class</code>语法，继承实现，以及它和函数继承的一些差别。</li>\n</ol>\n"},{"title":"实现Promise（版本2自己实现）","date":"2020-12-29T16:00:00.000Z","_content":"\n上一次实现的`Promise`思路比较绕，不容易理解。参考市面上大部分的实现方式，自己实现了一把。\n\n## 原生\n\n```js\n// 接收一个函数，函数接受2个回调函数，resolve 和 reject\nvar p = new Promise((resolve, reject) => {\n  // ...\n  // promise初始状态为pending\n  // 两种结果只能选其一，修改状态，并传递值或错误\n  // resolve(value) 状态 -> resolved\n  // or\n  // reject(error) 状态 -> rejected\n});\n\n// 异步或同步注册then函数，函数接受2个回调，一个是resolved的value，一个是rejected的err\np.then(onResolved, onRejected);\n\n// then可以多次调用，也就是多次注册2个回调，一旦promise决议，状态不在改变\np.then();\n```\n\n## 先搭架子\n\n```js\n// 常量定义状态\nconst PENDING = 'pending';\nconst RESOLVED = 'resolved';\nconst REJECTED = 'rejected';\n\n// promise构造函数，接收一个函数fn，fn接收resolve 和 reject\nfunction MyPromise(fn) {\n  // 初始状态\n  var state = 'pending';\n  // 终值\n  var finalValue = null;\n  // 收集then中注册的第一个函数，fullfilled\n  var onFulfilledCallback = [];\n  // 收集then中注册的第二个函数，rejected\n  var onRejectedCallback = [];\n\n  // 内部实现的resolve\n  function resolve(value) {}\n\n  // 内部实现的reject\n  function reject(err) {}\n\n  // 实现then方法\n  // 因为调用方式是 obj.then，属于实例属性\n  // 接收2个参数onFulfilled, onRejected\n  this.then = function (onFulfilled, onRejected) {};\n\n  fn(resolve, reject);\n}\n```\n\n## 填充基本的 promise 功能\n\n实现`resolve`,`reject`,`then`方法。\n\n```js\n// 常量定义状态\nconst PENDING = 'pending';\nconst RESOLVED = 'resolved';\nconst REJECTED = 'rejected';\n\n// promise构造函数，接收一个函数fn，fn接收resolve 和 reject\nfunction MyPromise(fn) {\n  // 初始状态\n  var state = 'pending';\n  // 终值\n  var finalValue = null;\n  // 收集then中注册的第一个函数，fullfilled\n  var onFulfilledCallback = [];\n  // 收集then中注册的第二个函数，rejected\n  var onRejectedCallback = [];\n\n  // 内部实现的resolve\n  function resolve(value) {\n    // 只有状态为pending时，可以触发\n    if (state === PENDING) {\n      // 修改状态为 resolved\n      state = RESOLVED;\n      // 修改该promise终值为调用时传递的值\n      finalValue = value;\n      // 将收集到的then注册的方法，全部执行一遍\n      onFulfilledCallback.forEach((cb) => {\n        cb(value);\n      });\n    }\n  }\n\n  // 内部实现的reject\n  function reject(err) {\n    // 只有状态为pending时，可以触发\n    if (state === PENDING) {\n      // 修改状态为 rejected\n      state = RESOLVED;\n      // 修改该promise终值为调用时传递的值\n      finalValue = err;\n      // 将收集到的then注册的方法，全部执行一遍\n      onRejectedCallback.forEach((cb) => {\n        cb(err);\n      });\n    }\n  }\n\n  // 实现then方法\n  // 因为调用方式是 obj.then，属于实例属性\n  // 接收2个参数onFulfilled, onRejected\n  this.then = function (onFulfilled, onRejected) {\n    // 调用then的时候，如果该promise已经决议了，则执行其注册的回调\n    if (state === RESOLVED) {\n      onResolved(value);\n    }\n\n    if (state === REJECTED) {\n      onRejected(value);\n    }\n\n    // 继续注册then的参数到各自回调中\n    if (state === PENDING) {\n      onFulfilledCallback.push(onFulfilled);\n      onRejectedCallback.push(onRejected);\n    }\n  };\n\n  // 执行new promise(fn)中的fn，有可能出错，所以try catch包裹\n  try {\n    fn(resolve, reject);\n  } catch (err) {\n    // 出错就就决议这个promise为reject，调用其reject方法\n    reject(err);\n  }\n}\n```\n\n## 完善 then\n\n1. `then`方法返回一个新的`promise2`，而`promise2`的终值，取决于上一个`promise`的`then`的返回值，我们来改造`then`\n2. `then`方法接收 2 个回调函数，非必传，未传时需要有默认的，因为空`then`可以透传结果。如下\n\n```js\nvar p = new Promise((resolve) => resolve(1));\np.then()\n  .then()\n  .then((r) => console.log(r)); // 1\n```\n\n```js\nthis.then = function (onResolved, onRejected) {\n  // 判断then注册的是否是函数，否则要提供默认函数，透传结果\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (v) => v;\n  onRejected =\n    typeof onRejected === 'function'\n      ? onRejected\n      : (err) => {\n          throw err;\n        };\n\n  let promise2 = null;\n  if (state === RESOLVED) {\n    promise2 = new MyPromise((resolve, reject) => {\n      // 因为执行onResolved的函数可能会出错，所以try包裹\n      try {\n        // 拿到前一个promise的then中第一个参数（onResolved）执行后的结果，这里用x表示。\n        const x = onResolved(value);\n        // 如果x是一个x-promise，则我们需要用这个x-promise的终值作为promise2的终值\n        if (x instanceof MyPromise) {\n          // 这里传递给x.then的 onFulfilled函数，是 promise2的 resolve，如果x-promise决议了，就会去调用promise2的resolve，从而决定了promise2的终值。\n          x.then(resolve, reject);\n        } else {\n          // 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。\n          resolve(x);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    });\n    // 返回promise2\n    return promise2;\n  }\n\n  if (state === REJECTED) {\n    promise2 = new MyPromise((resolve, reject) => {\n      // 这里解析的道理与上面一样。\n      try {\n        const x = onRejected(value);\n        if (x instanceof MyPromise) {\n          x.then(resolve, reject);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return promise2;\n  }\n\n  // 继续注册then的参数到各自回调中\n  if (state === PENDING) {\n    // promise1还未决议，不清楚是执行resolve还是reject，所以，将回调函数插入对应数组\n    promise2 = new MyPromise((resolve, reject) => {\n      // 将promise1的then方法注册的函数插入\n      // then的第一个参数：(res) => {}\n      onFulfilledCallback.push(function (value) {\n        try {\n          var x = onResolved(value);\n          if (x instanceof Promise) {\n            x.then(resolve, reject);\n          } else {\n            // 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。\n            resolve(x);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      });\n      // then的第二个参数 (err) => {}\n      onRejectedCallback.push(function (reason) {\n        try {\n          var x = onRejected(reason);\n          if (x instanceof Promise) {\n            x.then(resolve, reject);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n    return promise2;\n  }\n};\n```\n\n## 实现 catch\n\n实现了`then`后，再实现`catch`会很简单，`catch`实际上就是`then(null, onRejected)`，第一个参数不处理。\n\n看看原生的实现方式\n\n```js\nvar p = new Promise((resolve, reject) => {\n  reject(new Error('this is error'));\n});\n\np.catch((err) => {\n  console.log(err); // 打印Error\n});\n```\n\n```js\n// 接收一个处理错误的方法，方法接收一个reason\nthis.catch = function (fn) {\n  this.then(null, fn);\n};\n```\n\n## 实现 Promise.all\n\n看看原生的实现\n\n```js\nvar p1 = new Promise((resolve) => resolve(1));\nvar p2 = new Promise((resolve) => resolve(2));\n\nPromise.all([p1, p2]).then((res) => {\n  console.log(res); // [1,2]\n});\n\n// 如果有rejected掉的，则整个promise rejected掉\nvar p3 = new Promise((resolve, reject) => {\n  reject(new Error('this is error'));\n});\n\nPromise.all([p1, p2, p3])\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err); // Error: this is error\n  });\n```\n\n从原生的实现我们得知，`Promise.all`做的事有这些：\n\n- 返回一个 `promise`\n- 接收一个数组，数组成员都是`promise`\n- 如果全部成员`resolved`，则返回一个数组，数组中每一项是每个成员的`resolved`的终值\n- 如果有一个成员`rejected`，则整个`promise`被`rejected`掉。\n\n```js\nMyPromise.all = function (promises) {\n  // 返回一个promise\n  return new MyPromise((resolve, reject) => {\n    // 存放每个成员的终值\n    const res = [];\n    // 循环执行每个成员\n    for (let i = 0; i < promises.length; i++) {\n      promises[i].then(\n        (r) => {\n          // 如果成功resolved了，就往终值数组里塞入终值\n          res.push(r);\n          // 当终值数组长度和传入的promise长度相等，则可以resolved整个大promise，终值就是终值数组\n          if (res.length === promises.length) {\n            resolve(res);\n          }\n        },\n        (err) => {\n          reject(err);\n        }\n      );\n      // 原本尝试用catch来捕获错误，不行\n      // 原因：catch通过then模拟的，比then中的第二个参数执行，慢。因为setTimeout插入macro的时机关系。\n    }\n    // 原本将resolve放到这里执行，不行。\n    // 原因：因为所有异步通过setTimeout来实现，for循环结束了，立马就执行resolve了，在reject之前执行，导致整个promise是resolved的状态\n    // resolve(res)\n  });\n};\n```\n\n# 总结\n\n该版本的 promise 整体较为容易理解，真正的模拟实现，还应该根据`PromiseA+`规范约定的，处理各个`promise`实现的兼容，这里就不做分析了，网上有很多。\n\n至于`race`等方法，其实跟`all`差不多了，只要有一个`resolved`或`rejected`了，整体就决议了，感兴趣的读者，自己尝试下。\n\n上一下`codesandbox`的测试链接，[手撕 promise](https://codesandbox.io/s/shousipromise-02109)。\n","source":"_posts/2020/实现promise_v2.md","raw":"---\ntitle: 实现Promise（版本2自己实现）\ndate: 2020/12/30\n---\n\n上一次实现的`Promise`思路比较绕，不容易理解。参考市面上大部分的实现方式，自己实现了一把。\n\n## 原生\n\n```js\n// 接收一个函数，函数接受2个回调函数，resolve 和 reject\nvar p = new Promise((resolve, reject) => {\n  // ...\n  // promise初始状态为pending\n  // 两种结果只能选其一，修改状态，并传递值或错误\n  // resolve(value) 状态 -> resolved\n  // or\n  // reject(error) 状态 -> rejected\n});\n\n// 异步或同步注册then函数，函数接受2个回调，一个是resolved的value，一个是rejected的err\np.then(onResolved, onRejected);\n\n// then可以多次调用，也就是多次注册2个回调，一旦promise决议，状态不在改变\np.then();\n```\n\n## 先搭架子\n\n```js\n// 常量定义状态\nconst PENDING = 'pending';\nconst RESOLVED = 'resolved';\nconst REJECTED = 'rejected';\n\n// promise构造函数，接收一个函数fn，fn接收resolve 和 reject\nfunction MyPromise(fn) {\n  // 初始状态\n  var state = 'pending';\n  // 终值\n  var finalValue = null;\n  // 收集then中注册的第一个函数，fullfilled\n  var onFulfilledCallback = [];\n  // 收集then中注册的第二个函数，rejected\n  var onRejectedCallback = [];\n\n  // 内部实现的resolve\n  function resolve(value) {}\n\n  // 内部实现的reject\n  function reject(err) {}\n\n  // 实现then方法\n  // 因为调用方式是 obj.then，属于实例属性\n  // 接收2个参数onFulfilled, onRejected\n  this.then = function (onFulfilled, onRejected) {};\n\n  fn(resolve, reject);\n}\n```\n\n## 填充基本的 promise 功能\n\n实现`resolve`,`reject`,`then`方法。\n\n```js\n// 常量定义状态\nconst PENDING = 'pending';\nconst RESOLVED = 'resolved';\nconst REJECTED = 'rejected';\n\n// promise构造函数，接收一个函数fn，fn接收resolve 和 reject\nfunction MyPromise(fn) {\n  // 初始状态\n  var state = 'pending';\n  // 终值\n  var finalValue = null;\n  // 收集then中注册的第一个函数，fullfilled\n  var onFulfilledCallback = [];\n  // 收集then中注册的第二个函数，rejected\n  var onRejectedCallback = [];\n\n  // 内部实现的resolve\n  function resolve(value) {\n    // 只有状态为pending时，可以触发\n    if (state === PENDING) {\n      // 修改状态为 resolved\n      state = RESOLVED;\n      // 修改该promise终值为调用时传递的值\n      finalValue = value;\n      // 将收集到的then注册的方法，全部执行一遍\n      onFulfilledCallback.forEach((cb) => {\n        cb(value);\n      });\n    }\n  }\n\n  // 内部实现的reject\n  function reject(err) {\n    // 只有状态为pending时，可以触发\n    if (state === PENDING) {\n      // 修改状态为 rejected\n      state = RESOLVED;\n      // 修改该promise终值为调用时传递的值\n      finalValue = err;\n      // 将收集到的then注册的方法，全部执行一遍\n      onRejectedCallback.forEach((cb) => {\n        cb(err);\n      });\n    }\n  }\n\n  // 实现then方法\n  // 因为调用方式是 obj.then，属于实例属性\n  // 接收2个参数onFulfilled, onRejected\n  this.then = function (onFulfilled, onRejected) {\n    // 调用then的时候，如果该promise已经决议了，则执行其注册的回调\n    if (state === RESOLVED) {\n      onResolved(value);\n    }\n\n    if (state === REJECTED) {\n      onRejected(value);\n    }\n\n    // 继续注册then的参数到各自回调中\n    if (state === PENDING) {\n      onFulfilledCallback.push(onFulfilled);\n      onRejectedCallback.push(onRejected);\n    }\n  };\n\n  // 执行new promise(fn)中的fn，有可能出错，所以try catch包裹\n  try {\n    fn(resolve, reject);\n  } catch (err) {\n    // 出错就就决议这个promise为reject，调用其reject方法\n    reject(err);\n  }\n}\n```\n\n## 完善 then\n\n1. `then`方法返回一个新的`promise2`，而`promise2`的终值，取决于上一个`promise`的`then`的返回值，我们来改造`then`\n2. `then`方法接收 2 个回调函数，非必传，未传时需要有默认的，因为空`then`可以透传结果。如下\n\n```js\nvar p = new Promise((resolve) => resolve(1));\np.then()\n  .then()\n  .then((r) => console.log(r)); // 1\n```\n\n```js\nthis.then = function (onResolved, onRejected) {\n  // 判断then注册的是否是函数，否则要提供默认函数，透传结果\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (v) => v;\n  onRejected =\n    typeof onRejected === 'function'\n      ? onRejected\n      : (err) => {\n          throw err;\n        };\n\n  let promise2 = null;\n  if (state === RESOLVED) {\n    promise2 = new MyPromise((resolve, reject) => {\n      // 因为执行onResolved的函数可能会出错，所以try包裹\n      try {\n        // 拿到前一个promise的then中第一个参数（onResolved）执行后的结果，这里用x表示。\n        const x = onResolved(value);\n        // 如果x是一个x-promise，则我们需要用这个x-promise的终值作为promise2的终值\n        if (x instanceof MyPromise) {\n          // 这里传递给x.then的 onFulfilled函数，是 promise2的 resolve，如果x-promise决议了，就会去调用promise2的resolve，从而决定了promise2的终值。\n          x.then(resolve, reject);\n        } else {\n          // 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。\n          resolve(x);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    });\n    // 返回promise2\n    return promise2;\n  }\n\n  if (state === REJECTED) {\n    promise2 = new MyPromise((resolve, reject) => {\n      // 这里解析的道理与上面一样。\n      try {\n        const x = onRejected(value);\n        if (x instanceof MyPromise) {\n          x.then(resolve, reject);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    });\n    return promise2;\n  }\n\n  // 继续注册then的参数到各自回调中\n  if (state === PENDING) {\n    // promise1还未决议，不清楚是执行resolve还是reject，所以，将回调函数插入对应数组\n    promise2 = new MyPromise((resolve, reject) => {\n      // 将promise1的then方法注册的函数插入\n      // then的第一个参数：(res) => {}\n      onFulfilledCallback.push(function (value) {\n        try {\n          var x = onResolved(value);\n          if (x instanceof Promise) {\n            x.then(resolve, reject);\n          } else {\n            // 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。\n            resolve(x);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      });\n      // then的第二个参数 (err) => {}\n      onRejectedCallback.push(function (reason) {\n        try {\n          var x = onRejected(reason);\n          if (x instanceof Promise) {\n            x.then(resolve, reject);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n    return promise2;\n  }\n};\n```\n\n## 实现 catch\n\n实现了`then`后，再实现`catch`会很简单，`catch`实际上就是`then(null, onRejected)`，第一个参数不处理。\n\n看看原生的实现方式\n\n```js\nvar p = new Promise((resolve, reject) => {\n  reject(new Error('this is error'));\n});\n\np.catch((err) => {\n  console.log(err); // 打印Error\n});\n```\n\n```js\n// 接收一个处理错误的方法，方法接收一个reason\nthis.catch = function (fn) {\n  this.then(null, fn);\n};\n```\n\n## 实现 Promise.all\n\n看看原生的实现\n\n```js\nvar p1 = new Promise((resolve) => resolve(1));\nvar p2 = new Promise((resolve) => resolve(2));\n\nPromise.all([p1, p2]).then((res) => {\n  console.log(res); // [1,2]\n});\n\n// 如果有rejected掉的，则整个promise rejected掉\nvar p3 = new Promise((resolve, reject) => {\n  reject(new Error('this is error'));\n});\n\nPromise.all([p1, p2, p3])\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err); // Error: this is error\n  });\n```\n\n从原生的实现我们得知，`Promise.all`做的事有这些：\n\n- 返回一个 `promise`\n- 接收一个数组，数组成员都是`promise`\n- 如果全部成员`resolved`，则返回一个数组，数组中每一项是每个成员的`resolved`的终值\n- 如果有一个成员`rejected`，则整个`promise`被`rejected`掉。\n\n```js\nMyPromise.all = function (promises) {\n  // 返回一个promise\n  return new MyPromise((resolve, reject) => {\n    // 存放每个成员的终值\n    const res = [];\n    // 循环执行每个成员\n    for (let i = 0; i < promises.length; i++) {\n      promises[i].then(\n        (r) => {\n          // 如果成功resolved了，就往终值数组里塞入终值\n          res.push(r);\n          // 当终值数组长度和传入的promise长度相等，则可以resolved整个大promise，终值就是终值数组\n          if (res.length === promises.length) {\n            resolve(res);\n          }\n        },\n        (err) => {\n          reject(err);\n        }\n      );\n      // 原本尝试用catch来捕获错误，不行\n      // 原因：catch通过then模拟的，比then中的第二个参数执行，慢。因为setTimeout插入macro的时机关系。\n    }\n    // 原本将resolve放到这里执行，不行。\n    // 原因：因为所有异步通过setTimeout来实现，for循环结束了，立马就执行resolve了，在reject之前执行，导致整个promise是resolved的状态\n    // resolve(res)\n  });\n};\n```\n\n# 总结\n\n该版本的 promise 整体较为容易理解，真正的模拟实现，还应该根据`PromiseA+`规范约定的，处理各个`promise`实现的兼容，这里就不做分析了，网上有很多。\n\n至于`race`等方法，其实跟`all`差不多了，只要有一个`resolved`或`rejected`了，整体就决议了，感兴趣的读者，自己尝试下。\n\n上一下`codesandbox`的测试链接，[手撕 promise](https://codesandbox.io/s/shousipromise-02109)。\n","slug":"2020/实现promise_v2","published":1,"updated":"2021-11-06T07:35:35.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz4000l6hufhcwd2tl3","content":"<p>上一次实现的<code>Promise</code>思路比较绕，不容易理解。参考市面上大部分的实现方式，自己实现了一把。</p>\n<h2 id=\"原生\"><a href=\"#原生\" class=\"headerlink\" title=\"原生\"></a>原生</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接收一个函数，函数接受2个回调函数，resolve 和 reject</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// promise初始状态为pending</span></span><br><span class=\"line\">  <span class=\"comment\">// 两种结果只能选其一，修改状态，并传递值或错误</span></span><br><span class=\"line\">  <span class=\"comment\">// resolve(value) 状态 -&gt; resolved</span></span><br><span class=\"line\">  <span class=\"comment\">// or</span></span><br><span class=\"line\">  <span class=\"comment\">// reject(error) 状态 -&gt; rejected</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步或同步注册then函数，函数接受2个回调，一个是resolved的value，一个是rejected的err</span></span><br><span class=\"line\">p.then(onResolved, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then可以多次调用，也就是多次注册2个回调，一旦promise决议，状态不在改变</span></span><br><span class=\"line\">p.then();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"先搭架子\"><a href=\"#先搭架子\" class=\"headerlink\" title=\"先搭架子\"></a>先搭架子</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常量定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// promise构造函数，接收一个函数fn，fn接收resolve 和 reject</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始状态</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 终值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第一个函数，fullfilled</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onFulfilledCallback = [];</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第二个函数，rejected</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onRejectedCallback = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的resolve</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的reject</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实现then方法</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为调用方式是 obj.then，属于实例属性</span></span><br><span class=\"line\">  <span class=\"comment\">// 接收2个参数onFulfilled, onRejected</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"填充基本的-promise-功能\"><a href=\"#填充基本的-promise-功能\" class=\"headerlink\" title=\"填充基本的 promise 功能\"></a>填充基本的 promise 功能</h2><p>实现<code>resolve</code>,<code>reject</code>,<code>then</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常量定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// promise构造函数，接收一个函数fn，fn接收resolve 和 reject</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始状态</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 终值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第一个函数，fullfilled</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onFulfilledCallback = [];</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第二个函数，rejected</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onRejectedCallback = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的resolve</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只有状态为pending时，可以触发</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 修改状态为 resolved</span></span><br><span class=\"line\">      state = RESOLVED;</span><br><span class=\"line\">      <span class=\"comment\">// 修改该promise终值为调用时传递的值</span></span><br><span class=\"line\">      finalValue = value;</span><br><span class=\"line\">      <span class=\"comment\">// 将收集到的then注册的方法，全部执行一遍</span></span><br><span class=\"line\">      onFulfilledCallback.forEach(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        cb(value);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的reject</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只有状态为pending时，可以触发</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 修改状态为 rejected</span></span><br><span class=\"line\">      state = RESOLVED;</span><br><span class=\"line\">      <span class=\"comment\">// 修改该promise终值为调用时传递的值</span></span><br><span class=\"line\">      finalValue = err;</span><br><span class=\"line\">      <span class=\"comment\">// 将收集到的then注册的方法，全部执行一遍</span></span><br><span class=\"line\">      onRejectedCallback.forEach(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        cb(err);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实现then方法</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为调用方式是 obj.then，属于实例属性</span></span><br><span class=\"line\">  <span class=\"comment\">// 接收2个参数onFulfilled, onRejected</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用then的时候，如果该promise已经决议了，则执行其注册的回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === RESOLVED) &#123;</span><br><span class=\"line\">      onResolved(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === REJECTED) &#123;</span><br><span class=\"line\">      onRejected(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 继续注册then的参数到各自回调中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">      onFulfilledCallback.push(onFulfilled);</span><br><span class=\"line\">      onRejectedCallback.push(onRejected);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行new promise(fn)中的fn，有可能出错，所以try catch包裹</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 出错就就决议这个promise为reject，调用其reject方法</span></span><br><span class=\"line\">    reject(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"完善-then\"><a href=\"#完善-then\" class=\"headerlink\" title=\"完善 then\"></a>完善 then</h2><ol>\n<li><code>then</code>方法返回一个新的<code>promise2</code>，而<code>promise2</code>的终值，取决于上一个<code>promise</code>的<code>then</code>的返回值，我们来改造<code>then</code></li>\n<li><code>then</code>方法接收 2 个回调函数，非必传，未传时需要有默认的，因为空<code>then</code>可以透传结果。如下</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">1</span>));</span><br><span class=\"line\">p.then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(r)); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断then注册的是否是函数，否则要提供默认函数，透传结果</span></span><br><span class=\"line\">  onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">&#x27;function&#x27;</span> ? onFulfilled : <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> v;</span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">      ? onRejected</span><br><span class=\"line\">      : <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2 = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state === RESOLVED) &#123;</span><br><span class=\"line\">    promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 因为执行onResolved的函数可能会出错，所以try包裹</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到前一个promise的then中第一个参数（onResolved）执行后的结果，这里用x表示。</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onResolved(value);</span><br><span class=\"line\">        <span class=\"comment\">// 如果x是一个x-promise，则我们需要用这个x-promise的终值作为promise2的终值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 这里传递给x.then的 onFulfilled函数，是 promise2的 resolve，如果x-promise决议了，就会去调用promise2的resolve，从而决定了promise2的终值。</span></span><br><span class=\"line\">          x.then(resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。</span></span><br><span class=\"line\">          resolve(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 返回promise2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state === REJECTED) &#123;</span><br><span class=\"line\">    promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这里解析的道理与上面一样。</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onRejected(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">          x.then(resolve, reject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 继续注册then的参数到各自回调中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// promise1还未决议，不清楚是执行resolve还是reject，所以，将回调函数插入对应数组</span></span><br><span class=\"line\">    promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 将promise1的then方法注册的函数插入</span></span><br><span class=\"line\">      <span class=\"comment\">// then的第一个参数：(res) =&gt; &#123;&#125;</span></span><br><span class=\"line\">      onFulfilledCallback.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onResolved(value);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。</span></span><br><span class=\"line\">            resolve(x);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"comment\">// then的第二个参数 (err) =&gt; &#123;&#125;</span></span><br><span class=\"line\">      onRejectedCallback.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onRejected(reason);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch\"></a>实现 catch</h2><p>实现了<code>then</code>后，再实现<code>catch</code>会很简单，<code>catch</code>实际上就是<code>then(null, onRejected)</code>，第一个参数不处理。</p>\n<p>看看原生的实现方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;this is error&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// 打印Error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接收一个处理错误的方法，方法接收一个reason</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, fn);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h2><p>看看原生的实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2]).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res); <span class=\"comment\">// [1,2]</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果有rejected掉的，则整个promise rejected掉</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;this is error&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2, p3])</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// Error: this is error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>从原生的实现我们得知，<code>Promise.all</code>做的事有这些：</p>\n<ul>\n<li>返回一个 <code>promise</code></li>\n<li>接收一个数组，数组成员都是<code>promise</code></li>\n<li>如果全部成员<code>resolved</code>，则返回一个数组，数组中每一项是每个成员的<code>resolved</code>的终值</li>\n<li>如果有一个成员<code>rejected</code>，则整个<code>promise</code>被<code>rejected</code>掉。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个promise</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放每个成员的终值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = [];</span><br><span class=\"line\">    <span class=\"comment\">// 循环执行每个成员</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class=\"line\">      promises[i].then(</span><br><span class=\"line\">        <span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果成功resolved了，就往终值数组里塞入终值</span></span><br><span class=\"line\">          res.push(r);</span><br><span class=\"line\">          <span class=\"comment\">// 当终值数组长度和传入的promise长度相等，则可以resolved整个大promise，终值就是终值数组</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (res.length === promises.length) &#123;</span><br><span class=\"line\">            resolve(res);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// 原本尝试用catch来捕获错误，不行</span></span><br><span class=\"line\">      <span class=\"comment\">// 原因：catch通过then模拟的，比then中的第二个参数执行，慢。因为setTimeout插入macro的时机关系。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 原本将resolve放到这里执行，不行。</span></span><br><span class=\"line\">    <span class=\"comment\">// 原因：因为所有异步通过setTimeout来实现，for循环结束了，立马就执行resolve了，在reject之前执行，导致整个promise是resolved的状态</span></span><br><span class=\"line\">    <span class=\"comment\">// resolve(res)</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>该版本的 promise 整体较为容易理解，真正的模拟实现，还应该根据<code>PromiseA+</code>规范约定的，处理各个<code>promise</code>实现的兼容，这里就不做分析了，网上有很多。</p>\n<p>至于<code>race</code>等方法，其实跟<code>all</code>差不多了，只要有一个<code>resolved</code>或<code>rejected</code>了，整体就决议了，感兴趣的读者，自己尝试下。</p>\n<p>上一下<code>codesandbox</code>的测试链接，<a href=\"https://codesandbox.io/s/shousipromise-02109\">手撕 promise</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一次实现的<code>Promise</code>思路比较绕，不容易理解。参考市面上大部分的实现方式，自己实现了一把。</p>\n<h2 id=\"原生\"><a href=\"#原生\" class=\"headerlink\" title=\"原生\"></a>原生</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接收一个函数，函数接受2个回调函数，resolve 和 reject</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// promise初始状态为pending</span></span><br><span class=\"line\">  <span class=\"comment\">// 两种结果只能选其一，修改状态，并传递值或错误</span></span><br><span class=\"line\">  <span class=\"comment\">// resolve(value) 状态 -&gt; resolved</span></span><br><span class=\"line\">  <span class=\"comment\">// or</span></span><br><span class=\"line\">  <span class=\"comment\">// reject(error) 状态 -&gt; rejected</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步或同步注册then函数，函数接受2个回调，一个是resolved的value，一个是rejected的err</span></span><br><span class=\"line\">p.then(onResolved, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then可以多次调用，也就是多次注册2个回调，一旦promise决议，状态不在改变</span></span><br><span class=\"line\">p.then();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"先搭架子\"><a href=\"#先搭架子\" class=\"headerlink\" title=\"先搭架子\"></a>先搭架子</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常量定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// promise构造函数，接收一个函数fn，fn接收resolve 和 reject</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始状态</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 终值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第一个函数，fullfilled</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onFulfilledCallback = [];</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第二个函数，rejected</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onRejectedCallback = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的resolve</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的reject</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实现then方法</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为调用方式是 obj.then，属于实例属性</span></span><br><span class=\"line\">  <span class=\"comment\">// 接收2个参数onFulfilled, onRejected</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn(resolve, reject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"填充基本的-promise-功能\"><a href=\"#填充基本的-promise-功能\" class=\"headerlink\" title=\"填充基本的 promise 功能\"></a>填充基本的 promise 功能</h2><p>实现<code>resolve</code>,<code>reject</code>,<code>then</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常量定义状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// promise构造函数，接收一个函数fn，fn接收resolve 和 reject</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始状态</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> state = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 终值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第一个函数，fullfilled</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onFulfilledCallback = [];</span><br><span class=\"line\">  <span class=\"comment\">// 收集then中注册的第二个函数，rejected</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> onRejectedCallback = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的resolve</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只有状态为pending时，可以触发</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 修改状态为 resolved</span></span><br><span class=\"line\">      state = RESOLVED;</span><br><span class=\"line\">      <span class=\"comment\">// 修改该promise终值为调用时传递的值</span></span><br><span class=\"line\">      finalValue = value;</span><br><span class=\"line\">      <span class=\"comment\">// 将收集到的then注册的方法，全部执行一遍</span></span><br><span class=\"line\">      onFulfilledCallback.forEach(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        cb(value);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部实现的reject</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只有状态为pending时，可以触发</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 修改状态为 rejected</span></span><br><span class=\"line\">      state = RESOLVED;</span><br><span class=\"line\">      <span class=\"comment\">// 修改该promise终值为调用时传递的值</span></span><br><span class=\"line\">      finalValue = err;</span><br><span class=\"line\">      <span class=\"comment\">// 将收集到的then注册的方法，全部执行一遍</span></span><br><span class=\"line\">      onRejectedCallback.forEach(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        cb(err);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实现then方法</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为调用方式是 obj.then，属于实例属性</span></span><br><span class=\"line\">  <span class=\"comment\">// 接收2个参数onFulfilled, onRejected</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用then的时候，如果该promise已经决议了，则执行其注册的回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === RESOLVED) &#123;</span><br><span class=\"line\">      onResolved(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === REJECTED) &#123;</span><br><span class=\"line\">      onRejected(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 继续注册then的参数到各自回调中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">      onFulfilledCallback.push(onFulfilled);</span><br><span class=\"line\">      onRejectedCallback.push(onRejected);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行new promise(fn)中的fn，有可能出错，所以try catch包裹</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    fn(resolve, reject);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 出错就就决议这个promise为reject，调用其reject方法</span></span><br><span class=\"line\">    reject(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"完善-then\"><a href=\"#完善-then\" class=\"headerlink\" title=\"完善 then\"></a>完善 then</h2><ol>\n<li><code>then</code>方法返回一个新的<code>promise2</code>，而<code>promise2</code>的终值，取决于上一个<code>promise</code>的<code>then</code>的返回值，我们来改造<code>then</code></li>\n<li><code>then</code>方法接收 2 个回调函数，非必传，未传时需要有默认的，因为空<code>then</code>可以透传结果。如下</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">1</span>));</span><br><span class=\"line\">p.then()</span><br><span class=\"line\">  .then()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(r)); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断then注册的是否是函数，否则要提供默认函数，透传结果</span></span><br><span class=\"line\">  onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">&#x27;function&#x27;</span> ? onFulfilled : <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> v;</span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">      ? onRejected</span><br><span class=\"line\">      : <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2 = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state === RESOLVED) &#123;</span><br><span class=\"line\">    promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 因为执行onResolved的函数可能会出错，所以try包裹</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到前一个promise的then中第一个参数（onResolved）执行后的结果，这里用x表示。</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onResolved(value);</span><br><span class=\"line\">        <span class=\"comment\">// 如果x是一个x-promise，则我们需要用这个x-promise的终值作为promise2的终值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 这里传递给x.then的 onFulfilled函数，是 promise2的 resolve，如果x-promise决议了，就会去调用promise2的resolve，从而决定了promise2的终值。</span></span><br><span class=\"line\">          x.then(resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。</span></span><br><span class=\"line\">          resolve(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 返回promise2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state === REJECTED) &#123;</span><br><span class=\"line\">    promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这里解析的道理与上面一样。</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onRejected(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">          x.then(resolve, reject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 继续注册then的参数到各自回调中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// promise1还未决议，不清楚是执行resolve还是reject，所以，将回调函数插入对应数组</span></span><br><span class=\"line\">    promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 将promise1的then方法注册的函数插入</span></span><br><span class=\"line\">      <span class=\"comment\">// then的第一个参数：(res) =&gt; &#123;&#125;</span></span><br><span class=\"line\">      onFulfilledCallback.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onResolved(value);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。</span></span><br><span class=\"line\">            resolve(x);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"comment\">// then的第二个参数 (err) =&gt; &#123;&#125;</span></span><br><span class=\"line\">      onRejectedCallback.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onRejected(reason);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch\"></a>实现 catch</h2><p>实现了<code>then</code>后，再实现<code>catch</code>会很简单，<code>catch</code>实际上就是<code>then(null, onRejected)</code>，第一个参数不处理。</p>\n<p>看看原生的实现方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;this is error&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// 打印Error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接收一个处理错误的方法，方法接收一个reason</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, fn);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h2><p>看看原生的实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2]).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res); <span class=\"comment\">// [1,2]</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果有rejected掉的，则整个promise rejected掉</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;this is error&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2, p3])</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err); <span class=\"comment\">// Error: this is error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>从原生的实现我们得知，<code>Promise.all</code>做的事有这些：</p>\n<ul>\n<li>返回一个 <code>promise</code></li>\n<li>接收一个数组，数组成员都是<code>promise</code></li>\n<li>如果全部成员<code>resolved</code>，则返回一个数组，数组中每一项是每个成员的<code>resolved</code>的终值</li>\n<li>如果有一个成员<code>rejected</code>，则整个<code>promise</code>被<code>rejected</code>掉。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个promise</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放每个成员的终值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = [];</span><br><span class=\"line\">    <span class=\"comment\">// 循环执行每个成员</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class=\"line\">      promises[i].then(</span><br><span class=\"line\">        <span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果成功resolved了，就往终值数组里塞入终值</span></span><br><span class=\"line\">          res.push(r);</span><br><span class=\"line\">          <span class=\"comment\">// 当终值数组长度和传入的promise长度相等，则可以resolved整个大promise，终值就是终值数组</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (res.length === promises.length) &#123;</span><br><span class=\"line\">            resolve(res);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// 原本尝试用catch来捕获错误，不行</span></span><br><span class=\"line\">      <span class=\"comment\">// 原因：catch通过then模拟的，比then中的第二个参数执行，慢。因为setTimeout插入macro的时机关系。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 原本将resolve放到这里执行，不行。</span></span><br><span class=\"line\">    <span class=\"comment\">// 原因：因为所有异步通过setTimeout来实现，for循环结束了，立马就执行resolve了，在reject之前执行，导致整个promise是resolved的状态</span></span><br><span class=\"line\">    <span class=\"comment\">// resolve(res)</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>该版本的 promise 整体较为容易理解，真正的模拟实现，还应该根据<code>PromiseA+</code>规范约定的，处理各个<code>promise</code>实现的兼容，这里就不做分析了，网上有很多。</p>\n<p>至于<code>race</code>等方法，其实跟<code>all</code>差不多了，只要有一个<code>resolved</code>或<code>rejected</code>了，整体就决议了，感兴趣的读者，自己尝试下。</p>\n<p>上一下<code>codesandbox</code>的测试链接，<a href=\"https://codesandbox.io/s/shousipromise-02109\">手撕 promise</a>。</p>\n"},{"title":"探究JS原型","date":"2020-12-29T16:00:00.000Z","_content":"\n详细分析原型对象的构成和作用，理清`prototype`，`__proto__`相关的关系。\n\n# prototype\n\n原型是 JS 诞生就有的， 但是原型的访问方式，在“远古”时代，唯一可靠的方法就是通过构造函数的`prototype`属性来获取和设置原型对象。\n\n## 不是原型，只是普通属性\n\n函数创建时，默认会有一个名为`prototype`的**常规普通属性**，这个属性只有在 函数当做构造函数，且通过`new`创建实例对象时才有用。\n\n`new F()`调用时，如果有`F.prototype`，则会将`F.prototype`作为实例对象的`[[Prototype]]`。\n\n```js\nfunction Parent() {}\n\nvar person = new Parent();\n\nperson.__proto__ === Parent.prototype; // true\n```\n\n但如果之后修改了`F.prototype = other Object`，则后续`new F()`所创建的实例对象则会使用新的对象来作为`[[Prototype]]`，原本已生成的实例对象的原型还会保留旧值。\n\n```js\nfunction Parent() {}\nvar person1 = new Parent();\nParent.prototype = {};\nvar person2 = new Parent();\nperson1.__proto__ === person2.__proto__; // false\n```\n\n至于为什么说`prototype`不是原型，而只是普通属性，那是因为不作为`new F()`使用的话，它真的与普通属性无差异，没有任何魔法。\n\n```js\nvar parent = {\n  prototype: '普通属性',\n};\nparent.prototype; // 普通属性\n```\n\n## F.prototype 的构成\n\n所有函数创建时具有一个默认的`prototype`属性，该属性指向的对象里只有一个构造器属性`constructor`。\n\n### constructor\n\n该属性指向构造函数本身。\n\n```js\nfunction Parent() {}\nParent.prototype.constructor === Parent; // true\n```\n\n如果不去改变`prototype`，通过构造函数生成的实例对象，也可以使用`constructor`，我们就可以知道该实例属于哪个类（由哪个构造器生成）\n\n```js\nfunction Parent() {}\nvar person = new Parent();\nperson.constructor === Parent; // true\n```\n\n但`constructor`本身并不可靠，因为`prototype`可以随意更改，导致无法判断实例对象到底是由谁实现。\n\n```js\nfunction Parent() {}\nParent.prototype = {};\nvar person = new Parent();\nperson.constructor === Parent(); // false\n```\n\n### 自定义属性、方法\n\n如上所说，默认的`prototype`属性所指的对象，只有一个`constructor`。因此我们会对`prototpye`进行扩展，当通过`new F()`创建实例时，实例将会获得（原型继承）我们扩展的方法，属性等等，这是`prototype`最重要的作用。\n\n```js\nfunction Parent() {}\nParent.prototype.run = function () {\n  console.log('run');\n};\nvar parent = new Parent();\nparent.run(); // run\n```\n\n# \\_\\_proto\\_\\_ 、setPrototypeOf、getPrototypeOf\n\n前一篇文章介绍过，`__proto__`是浏览器自己实现的访问和修改原型的**访问器属性**，而`setPrototypeOf`和`getPrototypeOf`是标准中制定的方法，他们的效果一样。\n\n```js\nvar a = {};\na.__proto__;\n\nfunction b() {}\nb.__proto__;\n```\n\n> 可以看到 a 对象和 b 函数的原型不太一样。\n\n## 普通字面量对象的原型\n\n字面量对象实际上是由 JS 引擎调用原生构造函数`Object`来生成的。\n\n```js\nvar a = {}; // 相当于 var a = new Object();\n\n// 通过new Object，因此Object.prototype 分配给了实例 a 的[[Prototype]]\na.__proto__ === Object.prototype; // true\n\n// a实例由Object函数构造生成，所以其constructor 就是 Object\na.constructor === Object; // true\n\n// Object.prototype除了constructor外还有许多方法，比如toString，因此a可以使用这些方法（a上不存在，顺着原型查找）\na.toString(); // [object Object]\n```\n\n## 函数的原型\n\n当打印函数的原型，发是一个原生的函数方法--!。\n\n```js\nfunction b() {}\nb.__proto__; // f() { [native code] }\n```\n\n不要慌，我们可以按照普通字面量的方式猜想，b 函数这种写法，实际上也是调用了内建`Function`来创建的。比如`new Function()`，所以 b 函数是内建`Function`的实例。我们可以推断出 b 函数的原型继承了`Function.prototype`\n\n```js\nfunction b() {}\nb.__proto__ === Function.prototype; // true 结果证明是对的\n\n// 因此我们的b函数可以使用 Function.prototype上的方法，常见的如函数的apply,call,bind等等。\nFunction.prototype.apply; //  f() { [native code] }\n```\n\n这也佐证了上面所提到的，`prototype`并不是原型对象本身。\n\n```js\nfunction b() {}\nb.prototype === b.__proto__; // false\n```\n\n是的，`b.prototype`真的就只是一个普普通通，简简单单的常规属性而已，它跟`__proto__`没有任何关系，只不过`protoype`有默认的对象值`{constructor: f b() {}}`\n\n那为什么我们要去拓展`b.prototype`呢？它根本不是原型，扩展的意义是什么呢？\n\n没错，**`protototype`不是原型，但是它所引用的对象，可以作为实例的原型**。当你通过`new b()`形式创建出一个实例对象时，`b.prototype`被作为实例对象的`[[Prototype]]`啦！这就是为什么我们要往`prototype`上去扩展的原因，**从实例的角度来看，`prototype`又是原型**，如下证明：\n\n```js\nfunction Parent() {}\nvar parent = new Parent();\nparent.__proto__ === Parent.prototype; // true\n```\n\n# 总结\n\n1. 早期，访问原型对象的方法，是通过`F.prototype`，只有函数才有这个属性。后期浏览器厂商实现了`__proto__`访问器，以及 ES 标准`setPrototypeOf`和`getPrototypeOf`。\n2. 函数创建时，会自动带有`prototype`属性，属性值是个对象，里面包含`construnctor`，`constructor`指向了函数本身，可以用来判断实例由谁构造生成，但并不准确，因为`prototype`可以被更改。稳妥的做法是，不要重写`prototype`对象，而只是在其上增加属性和方法。\n3. `F.prototype`只是一个常规属性，并无魔法。只有在通过`new F()`来创建实例时才有用，`F.prototype`会被用作创建实例的`[[Prototype]]`。\n4. 字面量对象的原型是一个对象，而函数的原型是一个内建函数。而且函数的原型并不等于`F.prototype`，侧面证明了`prototype`只是一个普通属性。\n5. 从生成的实例的角度去看构造函数的`prototype`，它又是原型对象。\n","source":"_posts/2020/探究原型.md","raw":"---\ntitle: 探究JS原型\ndate: 2020/12/30\n---\n\n详细分析原型对象的构成和作用，理清`prototype`，`__proto__`相关的关系。\n\n# prototype\n\n原型是 JS 诞生就有的， 但是原型的访问方式，在“远古”时代，唯一可靠的方法就是通过构造函数的`prototype`属性来获取和设置原型对象。\n\n## 不是原型，只是普通属性\n\n函数创建时，默认会有一个名为`prototype`的**常规普通属性**，这个属性只有在 函数当做构造函数，且通过`new`创建实例对象时才有用。\n\n`new F()`调用时，如果有`F.prototype`，则会将`F.prototype`作为实例对象的`[[Prototype]]`。\n\n```js\nfunction Parent() {}\n\nvar person = new Parent();\n\nperson.__proto__ === Parent.prototype; // true\n```\n\n但如果之后修改了`F.prototype = other Object`，则后续`new F()`所创建的实例对象则会使用新的对象来作为`[[Prototype]]`，原本已生成的实例对象的原型还会保留旧值。\n\n```js\nfunction Parent() {}\nvar person1 = new Parent();\nParent.prototype = {};\nvar person2 = new Parent();\nperson1.__proto__ === person2.__proto__; // false\n```\n\n至于为什么说`prototype`不是原型，而只是普通属性，那是因为不作为`new F()`使用的话，它真的与普通属性无差异，没有任何魔法。\n\n```js\nvar parent = {\n  prototype: '普通属性',\n};\nparent.prototype; // 普通属性\n```\n\n## F.prototype 的构成\n\n所有函数创建时具有一个默认的`prototype`属性，该属性指向的对象里只有一个构造器属性`constructor`。\n\n### constructor\n\n该属性指向构造函数本身。\n\n```js\nfunction Parent() {}\nParent.prototype.constructor === Parent; // true\n```\n\n如果不去改变`prototype`，通过构造函数生成的实例对象，也可以使用`constructor`，我们就可以知道该实例属于哪个类（由哪个构造器生成）\n\n```js\nfunction Parent() {}\nvar person = new Parent();\nperson.constructor === Parent; // true\n```\n\n但`constructor`本身并不可靠，因为`prototype`可以随意更改，导致无法判断实例对象到底是由谁实现。\n\n```js\nfunction Parent() {}\nParent.prototype = {};\nvar person = new Parent();\nperson.constructor === Parent(); // false\n```\n\n### 自定义属性、方法\n\n如上所说，默认的`prototype`属性所指的对象，只有一个`constructor`。因此我们会对`prototpye`进行扩展，当通过`new F()`创建实例时，实例将会获得（原型继承）我们扩展的方法，属性等等，这是`prototype`最重要的作用。\n\n```js\nfunction Parent() {}\nParent.prototype.run = function () {\n  console.log('run');\n};\nvar parent = new Parent();\nparent.run(); // run\n```\n\n# \\_\\_proto\\_\\_ 、setPrototypeOf、getPrototypeOf\n\n前一篇文章介绍过，`__proto__`是浏览器自己实现的访问和修改原型的**访问器属性**，而`setPrototypeOf`和`getPrototypeOf`是标准中制定的方法，他们的效果一样。\n\n```js\nvar a = {};\na.__proto__;\n\nfunction b() {}\nb.__proto__;\n```\n\n> 可以看到 a 对象和 b 函数的原型不太一样。\n\n## 普通字面量对象的原型\n\n字面量对象实际上是由 JS 引擎调用原生构造函数`Object`来生成的。\n\n```js\nvar a = {}; // 相当于 var a = new Object();\n\n// 通过new Object，因此Object.prototype 分配给了实例 a 的[[Prototype]]\na.__proto__ === Object.prototype; // true\n\n// a实例由Object函数构造生成，所以其constructor 就是 Object\na.constructor === Object; // true\n\n// Object.prototype除了constructor外还有许多方法，比如toString，因此a可以使用这些方法（a上不存在，顺着原型查找）\na.toString(); // [object Object]\n```\n\n## 函数的原型\n\n当打印函数的原型，发是一个原生的函数方法--!。\n\n```js\nfunction b() {}\nb.__proto__; // f() { [native code] }\n```\n\n不要慌，我们可以按照普通字面量的方式猜想，b 函数这种写法，实际上也是调用了内建`Function`来创建的。比如`new Function()`，所以 b 函数是内建`Function`的实例。我们可以推断出 b 函数的原型继承了`Function.prototype`\n\n```js\nfunction b() {}\nb.__proto__ === Function.prototype; // true 结果证明是对的\n\n// 因此我们的b函数可以使用 Function.prototype上的方法，常见的如函数的apply,call,bind等等。\nFunction.prototype.apply; //  f() { [native code] }\n```\n\n这也佐证了上面所提到的，`prototype`并不是原型对象本身。\n\n```js\nfunction b() {}\nb.prototype === b.__proto__; // false\n```\n\n是的，`b.prototype`真的就只是一个普普通通，简简单单的常规属性而已，它跟`__proto__`没有任何关系，只不过`protoype`有默认的对象值`{constructor: f b() {}}`\n\n那为什么我们要去拓展`b.prototype`呢？它根本不是原型，扩展的意义是什么呢？\n\n没错，**`protototype`不是原型，但是它所引用的对象，可以作为实例的原型**。当你通过`new b()`形式创建出一个实例对象时，`b.prototype`被作为实例对象的`[[Prototype]]`啦！这就是为什么我们要往`prototype`上去扩展的原因，**从实例的角度来看，`prototype`又是原型**，如下证明：\n\n```js\nfunction Parent() {}\nvar parent = new Parent();\nparent.__proto__ === Parent.prototype; // true\n```\n\n# 总结\n\n1. 早期，访问原型对象的方法，是通过`F.prototype`，只有函数才有这个属性。后期浏览器厂商实现了`__proto__`访问器，以及 ES 标准`setPrototypeOf`和`getPrototypeOf`。\n2. 函数创建时，会自动带有`prototype`属性，属性值是个对象，里面包含`construnctor`，`constructor`指向了函数本身，可以用来判断实例由谁构造生成，但并不准确，因为`prototype`可以被更改。稳妥的做法是，不要重写`prototype`对象，而只是在其上增加属性和方法。\n3. `F.prototype`只是一个常规属性，并无魔法。只有在通过`new F()`来创建实例时才有用，`F.prototype`会被用作创建实例的`[[Prototype]]`。\n4. 字面量对象的原型是一个对象，而函数的原型是一个内建函数。而且函数的原型并不等于`F.prototype`，侧面证明了`prototype`只是一个普通属性。\n5. 从生成的实例的角度去看构造函数的`prototype`，它又是原型对象。\n","slug":"2020/探究原型","published":1,"updated":"2021-11-06T07:35:54.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz5000m6hufeyog3l9m","content":"<p>详细分析原型对象的构成和作用，理清<code>prototype</code>，<code>__proto__</code>相关的关系。</p>\n<h1 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h1><p>原型是 JS 诞生就有的， 但是原型的访问方式，在“远古”时代，唯一可靠的方法就是通过构造函数的<code>prototype</code>属性来获取和设置原型对象。</p>\n<h2 id=\"不是原型，只是普通属性\"><a href=\"#不是原型，只是普通属性\" class=\"headerlink\" title=\"不是原型，只是普通属性\"></a>不是原型，只是普通属性</h2><p>函数创建时，默认会有一个名为<code>prototype</code>的<strong>常规普通属性</strong>，这个属性只有在 函数当做构造函数，且通过<code>new</code>创建实例对象时才有用。</p>\n<p><code>new F()</code>调用时，如果有<code>F.prototype</code>，则会将<code>F.prototype</code>作为实例对象的<code>[[Prototype]]</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\"></span><br><span class=\"line\">person.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果之后修改了<code>F.prototype = other Object</code>，则后续<code>new F()</code>所创建的实例对象则会使用新的对象来作为<code>[[Prototype]]</code>，原本已生成的实例对象的原型还会保留旧值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">Parent.prototype = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person1.__proto__ === person2.__proto__; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>至于为什么说<code>prototype</code>不是原型，而只是普通属性，那是因为不作为<code>new F()</code>使用的话，它真的与普通属性无差异，没有任何魔法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">prototype</span>: <span class=\"string\">&#x27;普通属性&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">parent.prototype; <span class=\"comment\">// 普通属性</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"F-prototype-的构成\"><a href=\"#F-prototype-的构成\" class=\"headerlink\" title=\"F.prototype 的构成\"></a>F.prototype 的构成</h2><p>所有函数创建时具有一个默认的<code>prototype</code>属性，该属性指向的对象里只有一个构造器属性<code>constructor</code>。</p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><p>该属性指向构造函数本身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype.constructor === Parent; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果不去改变<code>prototype</code>，通过构造函数生成的实例对象，也可以使用<code>constructor</code>，我们就可以知道该实例属于哪个类（由哪个构造器生成）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person.constructor === Parent; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但<code>constructor</code>本身并不可靠，因为<code>prototype</code>可以随意更改，导致无法判断实例对象到底是由谁实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person.constructor === Parent(); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义属性、方法\"><a href=\"#自定义属性、方法\" class=\"headerlink\" title=\"自定义属性、方法\"></a>自定义属性、方法</h3><p>如上所说，默认的<code>prototype</code>属性所指的对象，只有一个<code>constructor</code>。因此我们会对<code>prototpye</code>进行扩展，当通过<code>new F()</code>创建实例时，实例将会获得（原型继承）我们扩展的方法，属性等等，这是<code>prototype</code>最重要的作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype.run = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;run&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.run(); <span class=\"comment\">// run</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"proto-、setPrototypeOf、getPrototypeOf\"><a href=\"#proto-、setPrototypeOf、getPrototypeOf\" class=\"headerlink\" title=\"__proto__ 、setPrototypeOf、getPrototypeOf\"></a>__proto__ 、setPrototypeOf、getPrototypeOf</h1><p>前一篇文章介绍过，<code>__proto__</code>是浏览器自己实现的访问和修改原型的<strong>访问器属性</strong>，而<code>setPrototypeOf</code>和<code>getPrototypeOf</code>是标准中制定的方法，他们的效果一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\">a.__proto__;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以看到 a 对象和 b 函数的原型不太一样。</p>\n</blockquote>\n<h2 id=\"普通字面量对象的原型\"><a href=\"#普通字面量对象的原型\" class=\"headerlink\" title=\"普通字面量对象的原型\"></a>普通字面量对象的原型</h2><p>字面量对象实际上是由 JS 引擎调用原生构造函数<code>Object</code>来生成的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;; <span class=\"comment\">// 相当于 var a = new Object();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过new Object，因此Object.prototype 分配给了实例 a 的[[Prototype]]</span></span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a实例由Object函数构造生成，所以其constructor 就是 Object</span></span><br><span class=\"line\">a.constructor === <span class=\"built_in\">Object</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.prototype除了constructor外还有许多方法，比如toString，因此a可以使用这些方法（a上不存在，顺着原型查找）</span></span><br><span class=\"line\">a.toString(); <span class=\"comment\">// [object Object]</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数的原型\"><a href=\"#函数的原型\" class=\"headerlink\" title=\"函数的原型\"></a>函数的原型</h2><p>当打印函数的原型，发是一个原生的函数方法–!。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__; <span class=\"comment\">// f() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>不要慌，我们可以按照普通字面量的方式猜想，b 函数这种写法，实际上也是调用了内建<code>Function</code>来创建的。比如<code>new Function()</code>，所以 b 函数是内建<code>Function</code>的实例。我们可以推断出 b 函数的原型继承了<code>Function.prototype</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true 结果证明是对的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因此我们的b函数可以使用 Function.prototype上的方法，常见的如函数的apply,call,bind等等。</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply; <span class=\"comment\">//  f() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这也佐证了上面所提到的，<code>prototype</code>并不是原型对象本身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.prototype === b.__proto__; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>是的，<code>b.prototype</code>真的就只是一个普普通通，简简单单的常规属性而已，它跟<code>__proto__</code>没有任何关系，只不过<code>protoype</code>有默认的对象值<code>&#123;constructor: f b() &#123;&#125;&#125;</code></p>\n<p>那为什么我们要去拓展<code>b.prototype</code>呢？它根本不是原型，扩展的意义是什么呢？</p>\n<p>没错，**<code>protototype</code>不是原型，但是它所引用的对象，可以作为实例的原型<strong>。当你通过<code>new b()</code>形式创建出一个实例对象时，<code>b.prototype</code>被作为实例对象的<code>[[Prototype]]</code>啦！这就是为什么我们要往<code>prototype</code>上去扩展的原因，</strong>从实例的角度来看，<code>prototype</code>又是原型**，如下证明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>早期，访问原型对象的方法，是通过<code>F.prototype</code>，只有函数才有这个属性。后期浏览器厂商实现了<code>__proto__</code>访问器，以及 ES 标准<code>setPrototypeOf</code>和<code>getPrototypeOf</code>。</li>\n<li>函数创建时，会自动带有<code>prototype</code>属性，属性值是个对象，里面包含<code>construnctor</code>，<code>constructor</code>指向了函数本身，可以用来判断实例由谁构造生成，但并不准确，因为<code>prototype</code>可以被更改。稳妥的做法是，不要重写<code>prototype</code>对象，而只是在其上增加属性和方法。</li>\n<li><code>F.prototype</code>只是一个常规属性，并无魔法。只有在通过<code>new F()</code>来创建实例时才有用，<code>F.prototype</code>会被用作创建实例的<code>[[Prototype]]</code>。</li>\n<li>字面量对象的原型是一个对象，而函数的原型是一个内建函数。而且函数的原型并不等于<code>F.prototype</code>，侧面证明了<code>prototype</code>只是一个普通属性。</li>\n<li>从生成的实例的角度去看构造函数的<code>prototype</code>，它又是原型对象。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>详细分析原型对象的构成和作用，理清<code>prototype</code>，<code>__proto__</code>相关的关系。</p>\n<h1 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h1><p>原型是 JS 诞生就有的， 但是原型的访问方式，在“远古”时代，唯一可靠的方法就是通过构造函数的<code>prototype</code>属性来获取和设置原型对象。</p>\n<h2 id=\"不是原型，只是普通属性\"><a href=\"#不是原型，只是普通属性\" class=\"headerlink\" title=\"不是原型，只是普通属性\"></a>不是原型，只是普通属性</h2><p>函数创建时，默认会有一个名为<code>prototype</code>的<strong>常规普通属性</strong>，这个属性只有在 函数当做构造函数，且通过<code>new</code>创建实例对象时才有用。</p>\n<p><code>new F()</code>调用时，如果有<code>F.prototype</code>，则会将<code>F.prototype</code>作为实例对象的<code>[[Prototype]]</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\"></span><br><span class=\"line\">person.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果之后修改了<code>F.prototype = other Object</code>，则后续<code>new F()</code>所创建的实例对象则会使用新的对象来作为<code>[[Prototype]]</code>，原本已生成的实例对象的原型还会保留旧值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">Parent.prototype = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person1.__proto__ === person2.__proto__; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>至于为什么说<code>prototype</code>不是原型，而只是普通属性，那是因为不作为<code>new F()</code>使用的话，它真的与普通属性无差异，没有任何魔法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">prototype</span>: <span class=\"string\">&#x27;普通属性&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">parent.prototype; <span class=\"comment\">// 普通属性</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"F-prototype-的构成\"><a href=\"#F-prototype-的构成\" class=\"headerlink\" title=\"F.prototype 的构成\"></a>F.prototype 的构成</h2><p>所有函数创建时具有一个默认的<code>prototype</code>属性，该属性指向的对象里只有一个构造器属性<code>constructor</code>。</p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><p>该属性指向构造函数本身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype.constructor === Parent; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果不去改变<code>prototype</code>，通过构造函数生成的实例对象，也可以使用<code>constructor</code>，我们就可以知道该实例属于哪个类（由哪个构造器生成）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person.constructor === Parent; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但<code>constructor</code>本身并不可靠，因为<code>prototype</code>可以随意更改，导致无法判断实例对象到底是由谁实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">person.constructor === Parent(); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义属性、方法\"><a href=\"#自定义属性、方法\" class=\"headerlink\" title=\"自定义属性、方法\"></a>自定义属性、方法</h3><p>如上所说，默认的<code>prototype</code>属性所指的对象，只有一个<code>constructor</code>。因此我们会对<code>prototpye</code>进行扩展，当通过<code>new F()</code>创建实例时，实例将会获得（原型继承）我们扩展的方法，属性等等，这是<code>prototype</code>最重要的作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Parent.prototype.run = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;run&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.run(); <span class=\"comment\">// run</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"proto-、setPrototypeOf、getPrototypeOf\"><a href=\"#proto-、setPrototypeOf、getPrototypeOf\" class=\"headerlink\" title=\"__proto__ 、setPrototypeOf、getPrototypeOf\"></a>__proto__ 、setPrototypeOf、getPrototypeOf</h1><p>前一篇文章介绍过，<code>__proto__</code>是浏览器自己实现的访问和修改原型的<strong>访问器属性</strong>，而<code>setPrototypeOf</code>和<code>getPrototypeOf</code>是标准中制定的方法，他们的效果一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\">a.__proto__;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以看到 a 对象和 b 函数的原型不太一样。</p>\n</blockquote>\n<h2 id=\"普通字面量对象的原型\"><a href=\"#普通字面量对象的原型\" class=\"headerlink\" title=\"普通字面量对象的原型\"></a>普通字面量对象的原型</h2><p>字面量对象实际上是由 JS 引擎调用原生构造函数<code>Object</code>来生成的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;; <span class=\"comment\">// 相当于 var a = new Object();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过new Object，因此Object.prototype 分配给了实例 a 的[[Prototype]]</span></span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a实例由Object函数构造生成，所以其constructor 就是 Object</span></span><br><span class=\"line\">a.constructor === <span class=\"built_in\">Object</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.prototype除了constructor外还有许多方法，比如toString，因此a可以使用这些方法（a上不存在，顺着原型查找）</span></span><br><span class=\"line\">a.toString(); <span class=\"comment\">// [object Object]</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数的原型\"><a href=\"#函数的原型\" class=\"headerlink\" title=\"函数的原型\"></a>函数的原型</h2><p>当打印函数的原型，发是一个原生的函数方法–!。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__; <span class=\"comment\">// f() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>不要慌，我们可以按照普通字面量的方式猜想，b 函数这种写法，实际上也是调用了内建<code>Function</code>来创建的。比如<code>new Function()</code>，所以 b 函数是内建<code>Function</code>的实例。我们可以推断出 b 函数的原型继承了<code>Function.prototype</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true 结果证明是对的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因此我们的b函数可以使用 Function.prototype上的方法，常见的如函数的apply,call,bind等等。</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply; <span class=\"comment\">//  f() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这也佐证了上面所提到的，<code>prototype</code>并不是原型对象本身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">b.prototype === b.__proto__; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>是的，<code>b.prototype</code>真的就只是一个普普通通，简简单单的常规属性而已，它跟<code>__proto__</code>没有任何关系，只不过<code>protoype</code>有默认的对象值<code>&#123;constructor: f b() &#123;&#125;&#125;</code></p>\n<p>那为什么我们要去拓展<code>b.prototype</code>呢？它根本不是原型，扩展的意义是什么呢？</p>\n<p>没错，**<code>protototype</code>不是原型，但是它所引用的对象，可以作为实例的原型<strong>。当你通过<code>new b()</code>形式创建出一个实例对象时，<code>b.prototype</code>被作为实例对象的<code>[[Prototype]]</code>啦！这就是为什么我们要往<code>prototype</code>上去扩展的原因，</strong>从实例的角度来看，<code>prototype</code>又是原型**，如下证明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">parent.__proto__ === Parent.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>早期，访问原型对象的方法，是通过<code>F.prototype</code>，只有函数才有这个属性。后期浏览器厂商实现了<code>__proto__</code>访问器，以及 ES 标准<code>setPrototypeOf</code>和<code>getPrototypeOf</code>。</li>\n<li>函数创建时，会自动带有<code>prototype</code>属性，属性值是个对象，里面包含<code>construnctor</code>，<code>constructor</code>指向了函数本身，可以用来判断实例由谁构造生成，但并不准确，因为<code>prototype</code>可以被更改。稳妥的做法是，不要重写<code>prototype</code>对象，而只是在其上增加属性和方法。</li>\n<li><code>F.prototype</code>只是一个常规属性，并无魔法。只有在通过<code>new F()</code>来创建实例时才有用，<code>F.prototype</code>会被用作创建实例的<code>[[Prototype]]</code>。</li>\n<li>字面量对象的原型是一个对象，而函数的原型是一个内建函数。而且函数的原型并不等于<code>F.prototype</code>，侧面证明了<code>prototype</code>只是一个普通属性。</li>\n<li>从生成的实例的角度去看构造函数的<code>prototype</code>，它又是原型对象。</li>\n</ol>\n"},{"title":"学习Redux","date":"2020-12-29T16:00:00.000Z","_content":"\n> 为什么有这篇文章？\n> 因为使用 react 技术栈有一段时间了，相应的 redux 状态管理库也使用很久，偶尔一段时间不用，发现就会忘记某些 api，甚至是看过的主要是实现原理又忘的一干二净。\n> 所以总结一下，以便忘记后查阅，迅速让大脑有个印象。\n\n## 是什么？\n\n一个单向数据流的状态管理库。\n\n## 一些概念\n\nAPP 应用整个的状态都存放在单一的`Store`中心，修改`Store`的唯一途径就是发起`Action`，`Action`到达`Store`后，会根据`Action`提供的动作类型，新的数据，结合旧的状态合成一个新的状态，这个合成新状态的过程称为`Reducer`。\n\n- **Reducer** 实际上就是一个纯函数，相同输入，得到相同输出，输出 state。\n  ```js\n  function reducer() {\n    return {\n      count: 0\n    };\n  }\n  ```\n- **Action** 实际上是一个标注的 JS 对象，具有`type`属性，这是约定的，动作的类型，以便`reducer`针对不同动作，处理不同逻辑返回新的 state。\n\n  ```js\n  const addAction = {\n    type: 'add',\n    otherData: 'add num'\n  };\n  ```\n\n**注意**：不能直接修改旧`Store`，而是生成一份新的`Store`。目的是为了能够跟踪状态变化，一切有迹可循。\n\n## 基本使用\n\n搭配`React`数据驱动视图框架，食用更佳！\n\n1. 创建数据中心`Store`。接收一个 reducers 函数，该函数用于生成状态数据，无任何`action`时，`reducer`的计算将默认返回它所拥有的所有`state`。\n\n   ```js\n   import { createStore } from 'redux';\n\n   const Store = createStore(reducers);\n\n   export default Store;\n   ```\n\n2. 创建`createStore`所需的`reducers`。reducers 是一个函数，返回`store`。通常我们会有很多页面和组件，每个页面或组件有自己的`reducer`生成的`state`，将多个`reducer`合并为一个大的`reducers`就是整个 APP 应用需要的`store`。这种拆分方式方便我们对`state`业务数据模块化，每个模块只要负责维护部分数据即可。\n\n   ```js\n   // reducer只是一个函数，通过对之前的state和当前action的类型及参数的处理，返回新的的state\n   function reducerOne(preState, action) {\n     // 一般惯用switch case形式\n     // 你也可以用if else if\n     const { type } = action;\n     if (type === 'add') {\n       return {\n         count: preState + 1\n       };\n     } else {\n       return {\n         count: 0\n       };\n     }\n   }\n\n   function reducerTwo(preState, action) {\n     // ...\n     return {\n       name: 'hello'\n     };\n   }\n   ```\n\n   因为`createStore`只接受一个函数，所以我们可以利用`redux`提供的`combineReducers`，自动调用多个`reducer`，获取它们的`state`合并一下。\n","source":"_posts/2020/搞懂redux.md","raw":"---\ntitle: 学习Redux\ndate: 2020/12/30\n---\n\n> 为什么有这篇文章？\n> 因为使用 react 技术栈有一段时间了，相应的 redux 状态管理库也使用很久，偶尔一段时间不用，发现就会忘记某些 api，甚至是看过的主要是实现原理又忘的一干二净。\n> 所以总结一下，以便忘记后查阅，迅速让大脑有个印象。\n\n## 是什么？\n\n一个单向数据流的状态管理库。\n\n## 一些概念\n\nAPP 应用整个的状态都存放在单一的`Store`中心，修改`Store`的唯一途径就是发起`Action`，`Action`到达`Store`后，会根据`Action`提供的动作类型，新的数据，结合旧的状态合成一个新的状态，这个合成新状态的过程称为`Reducer`。\n\n- **Reducer** 实际上就是一个纯函数，相同输入，得到相同输出，输出 state。\n  ```js\n  function reducer() {\n    return {\n      count: 0\n    };\n  }\n  ```\n- **Action** 实际上是一个标注的 JS 对象，具有`type`属性，这是约定的，动作的类型，以便`reducer`针对不同动作，处理不同逻辑返回新的 state。\n\n  ```js\n  const addAction = {\n    type: 'add',\n    otherData: 'add num'\n  };\n  ```\n\n**注意**：不能直接修改旧`Store`，而是生成一份新的`Store`。目的是为了能够跟踪状态变化，一切有迹可循。\n\n## 基本使用\n\n搭配`React`数据驱动视图框架，食用更佳！\n\n1. 创建数据中心`Store`。接收一个 reducers 函数，该函数用于生成状态数据，无任何`action`时，`reducer`的计算将默认返回它所拥有的所有`state`。\n\n   ```js\n   import { createStore } from 'redux';\n\n   const Store = createStore(reducers);\n\n   export default Store;\n   ```\n\n2. 创建`createStore`所需的`reducers`。reducers 是一个函数，返回`store`。通常我们会有很多页面和组件，每个页面或组件有自己的`reducer`生成的`state`，将多个`reducer`合并为一个大的`reducers`就是整个 APP 应用需要的`store`。这种拆分方式方便我们对`state`业务数据模块化，每个模块只要负责维护部分数据即可。\n\n   ```js\n   // reducer只是一个函数，通过对之前的state和当前action的类型及参数的处理，返回新的的state\n   function reducerOne(preState, action) {\n     // 一般惯用switch case形式\n     // 你也可以用if else if\n     const { type } = action;\n     if (type === 'add') {\n       return {\n         count: preState + 1\n       };\n     } else {\n       return {\n         count: 0\n       };\n     }\n   }\n\n   function reducerTwo(preState, action) {\n     // ...\n     return {\n       name: 'hello'\n     };\n   }\n   ```\n\n   因为`createStore`只接受一个函数，所以我们可以利用`redux`提供的`combineReducers`，自动调用多个`reducer`，获取它们的`state`合并一下。\n","slug":"2020/搞懂redux","published":1,"updated":"2021-11-06T07:35:00.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvnjerz7000n6huf5vf3cwcl","content":"<blockquote>\n<p>为什么有这篇文章？<br>因为使用 react 技术栈有一段时间了，相应的 redux 状态管理库也使用很久，偶尔一段时间不用，发现就会忘记某些 api，甚至是看过的主要是实现原理又忘的一干二净。<br>所以总结一下，以便忘记后查阅，迅速让大脑有个印象。</p>\n</blockquote>\n<h2 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h2><p>一个单向数据流的状态管理库。</p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>APP 应用整个的状态都存放在单一的<code>Store</code>中心，修改<code>Store</code>的唯一途径就是发起<code>Action</code>，<code>Action</code>到达<code>Store</code>后，会根据<code>Action</code>提供的动作类型，新的数据，结合旧的状态合成一个新的状态，这个合成新状态的过程称为<code>Reducer</code>。</p>\n<ul>\n<li><p><strong>Reducer</strong> 实际上就是一个纯函数，相同输入，得到相同输出，输出 state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Action</strong> 实际上是一个标注的 JS 对象，具有<code>type</code>属性，这是约定的，动作的类型，以便<code>reducer</code>针对不同动作，处理不同逻辑返回新的 state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addAction = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;add&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">otherData</span>: <span class=\"string\">&#x27;add num&#x27;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>注意</strong>：不能直接修改旧<code>Store</code>，而是生成一份新的<code>Store</code>。目的是为了能够跟踪状态变化，一切有迹可循。</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>搭配<code>React</code>数据驱动视图框架，食用更佳！</p>\n<ol>\n<li><p>创建数据中心<code>Store</code>。接收一个 reducers 函数，该函数用于生成状态数据，无任何<code>action</code>时，<code>reducer</code>的计算将默认返回它所拥有的所有<code>state</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Store = createStore(reducers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Store;</span><br></pre></td></tr></table></figure></li>\n<li><p>创建<code>createStore</code>所需的<code>reducers</code>。reducers 是一个函数，返回<code>store</code>。通常我们会有很多页面和组件，每个页面或组件有自己的<code>reducer</code>生成的<code>state</code>，将多个<code>reducer</code>合并为一个大的<code>reducers</code>就是整个 APP 应用需要的<code>store</code>。这种拆分方式方便我们对<code>state</code>业务数据模块化，每个模块只要负责维护部分数据即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reducer只是一个函数，通过对之前的state和当前action的类型及参数的处理，返回新的的state</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducerOne</span>(<span class=\"params\">preState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 一般惯用switch case形式</span></span><br><span class=\"line\">  <span class=\"comment\">// 你也可以用if else if</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">&#x27;add&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">count</span>: preState + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducerTwo</span>(<span class=\"params\">preState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>createStore</code>只接受一个函数，所以我们可以利用<code>redux</code>提供的<code>combineReducers</code>，自动调用多个<code>reducer</code>，获取它们的<code>state</code>合并一下。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>为什么有这篇文章？<br>因为使用 react 技术栈有一段时间了，相应的 redux 状态管理库也使用很久，偶尔一段时间不用，发现就会忘记某些 api，甚至是看过的主要是实现原理又忘的一干二净。<br>所以总结一下，以便忘记后查阅，迅速让大脑有个印象。</p>\n</blockquote>\n<h2 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h2><p>一个单向数据流的状态管理库。</p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>APP 应用整个的状态都存放在单一的<code>Store</code>中心，修改<code>Store</code>的唯一途径就是发起<code>Action</code>，<code>Action</code>到达<code>Store</code>后，会根据<code>Action</code>提供的动作类型，新的数据，结合旧的状态合成一个新的状态，这个合成新状态的过程称为<code>Reducer</code>。</p>\n<ul>\n<li><p><strong>Reducer</strong> 实际上就是一个纯函数，相同输入，得到相同输出，输出 state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Action</strong> 实际上是一个标注的 JS 对象，具有<code>type</code>属性，这是约定的，动作的类型，以便<code>reducer</code>针对不同动作，处理不同逻辑返回新的 state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addAction = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;add&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">otherData</span>: <span class=\"string\">&#x27;add num&#x27;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>注意</strong>：不能直接修改旧<code>Store</code>，而是生成一份新的<code>Store</code>。目的是为了能够跟踪状态变化，一切有迹可循。</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>搭配<code>React</code>数据驱动视图框架，食用更佳！</p>\n<ol>\n<li><p>创建数据中心<code>Store</code>。接收一个 reducers 函数，该函数用于生成状态数据，无任何<code>action</code>时，<code>reducer</code>的计算将默认返回它所拥有的所有<code>state</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Store = createStore(reducers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Store;</span><br></pre></td></tr></table></figure></li>\n<li><p>创建<code>createStore</code>所需的<code>reducers</code>。reducers 是一个函数，返回<code>store</code>。通常我们会有很多页面和组件，每个页面或组件有自己的<code>reducer</code>生成的<code>state</code>，将多个<code>reducer</code>合并为一个大的<code>reducers</code>就是整个 APP 应用需要的<code>store</code>。这种拆分方式方便我们对<code>state</code>业务数据模块化，每个模块只要负责维护部分数据即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reducer只是一个函数，通过对之前的state和当前action的类型及参数的处理，返回新的的state</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducerOne</span>(<span class=\"params\">preState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 一般惯用switch case形式</span></span><br><span class=\"line\">  <span class=\"comment\">// 你也可以用if else if</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">&#x27;add&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">count</span>: preState + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducerTwo</span>(<span class=\"params\">preState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>createStore</code>只接受一个函数，所以我们可以利用<code>redux</code>提供的<code>combineReducers</code>，自动调用多个<code>reducer</code>，获取它们的<code>state</code>合并一下。</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}