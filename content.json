{"meta":{"title":"三角猫","subtitle":"","description":"个人博客，记录学习，思考，生活","author":"czm","url":"https://690554125.github.io","root":"/"},"pages":[{"title":"标签","date":"2021-11-04T14:52:59.668Z","updated":"2021-11-04T14:52:59.667Z","comments":false,"path":"tags/index.html","permalink":"https://690554125.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-06T07:27:06.381Z","updated":"2021-11-06T07:27:06.381Z","comments":false,"path":"about/index.html","permalink":"https://690554125.github.io/about/index.html","excerpt":"","text":"阿里巴巴打工中…"}],"posts":[{"title":"JS原型和继承","slug":"2020/原型和继承初识","date":"2020-12-29T16:00:00.000Z","updated":"2021-11-06T07:36:11.575Z","comments":true,"path":"2020/12/30/2020/原型和继承初识/","link":"","permalink":"https://690554125.github.io/2020/12/30/2020/%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%E5%88%9D%E8%AF%86/","excerpt":"","text":"初步介绍下原型和继承，以及相关的 API. 原型是什么所有的对象（包括函数）都有一个隐藏的内部属性[[Prototype]]，该属性引用的就是原型，原型本身也是一个对象，所以原型自己也有原型。 原型长什么样因为[[Prototype]]是内部属性，所以通过代码无法访问，但是我们有其他方式访问到原型。 构造函数才有的 prototype这是 JS 早期就有的属性，只有函数才有，字面量对象是没有的，可以在控制台尝试访问一个字面量对象的prototype，发现是undefined。所以这个功能有限。 12345function Person(name) &#123; this.name = name;&#125;console.log(Person.prototype); 结果如图： __proto__2012 年，Object.create()被写入标准，提供了使用给定原型创建对象的能力，然后还是没有提供set/get原型的能力，浏览器厂商们因此实现了非标准的__proto__访问器属性，允许用户随时修改和获取原型对象。 12345var a = &#123;&#125;;console.log(a.__proto__);function b() &#123;&#125;console.log(b.__proto__); 结果如图： 标准方法 Object.getPrototypeOf 和 Object.setPrototypeOf2015 年，这 2 个方法被加入到标准中。但是因为__proto__在很多浏览器都得到了实现，即便过时，但也被加入到标准的附件中了。 12var a = &#123;&#125;;Object.getPrototypeOf(a); 结果如图 总结：从上面的几个代码案例看出来，我们所打印的原型就是对象。 原型的作用当我们想要访问一个对象的属性时，先从对象自身查找，如果没有，会去对象的私有属性[[Prototype]] 所引用的原型对象上去找。 123456789var parent = &#123; run: true,&#125;;var son = &#123;&#125;;Object.setPrototypeOf(son, parent); // 等于 son.__proto__ = parentson.run; // true son对象本身没有run属性，所以会沿着[[Prototype]]指向的原型对象上去找 这个特性可以让我们复用逻辑，实现面向对象语言中的 继承 特性。 JS 中的继承JS 中的继承是通过[[Prototype]]来实现的，即便在 ES6 时代有了class关键字。 早期的函数方式继承： 12345678910function Person() &#123; this.run = true;&#125;function Son() &#123;&#125;Son.prototype = new Person();var son = new Son();son.run; // true 使用 es6 关键字class实现 1234567891011121314class Parent &#123; constructor() &#123; this.run = true; &#125;&#125;class Son extends Parent &#123; constructor() &#123; super(); &#125;&#125;const son = new Son();son.run; 总结原型是一个对象的内部属性[[Prototype]]所引用的一个对象。从 JS 诞生开始，就有F.prototype的方式可以访问到原型，和修改原型，但是只有函数才有prototype，后来浏览器厂商自己实现了__proto__访问器属性来实现对原型的set/get，直到 ES 标准规定了原型的访问和设置的方法Object.getPrototypeOf和Object.setPrototypeOf。 原型存在的最大作用是继承，JS 中的继承都是原型继承，从以前的函数继承到现在的class类语法糖来实现继承。","categories":[],"tags":[]},{"title":"导航流程","slug":"2020/URL输入到页面渲染流程","date":"2020-12-29T16:00:00.000Z","updated":"2021-11-06T07:36:21.906Z","comments":true,"path":"2020/12/30/2020/URL输入到页面渲染流程/","link":"","permalink":"https://690554125.github.io/2020/12/30/2020/URL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/","excerpt":"","text":"这里先配流程图，后面描述在丰富一下。 导航阶段 渲染阶段","categories":[],"tags":[]},{"title":"实现Promise（版本2自己实现）","slug":"2020/实现promise_v2","date":"2020-12-29T16:00:00.000Z","updated":"2021-11-06T07:35:35.757Z","comments":true,"path":"2020/12/30/2020/实现promise_v2/","link":"","permalink":"https://690554125.github.io/2020/12/30/2020/%E5%AE%9E%E7%8E%B0promise_v2/","excerpt":"","text":"上一次实现的Promise思路比较绕，不容易理解。参考市面上大部分的实现方式，自己实现了一把。 原生123456789101112131415// 接收一个函数，函数接受2个回调函数，resolve 和 rejectvar p = new Promise((resolve, reject) =&gt; &#123; // ... // promise初始状态为pending // 两种结果只能选其一，修改状态，并传递值或错误 // resolve(value) 状态 -&gt; resolved // or // reject(error) 状态 -&gt; rejected&#125;);// 异步或同步注册then函数，函数接受2个回调，一个是resolved的value，一个是rejected的errp.then(onResolved, onRejected);// then可以多次调用，也就是多次注册2个回调，一旦promise决议，状态不在改变p.then(); 先搭架子1234567891011121314151617181920212223242526272829// 常量定义状态const PENDING = &#x27;pending&#x27;;const RESOLVED = &#x27;resolved&#x27;;const REJECTED = &#x27;rejected&#x27;;// promise构造函数，接收一个函数fn，fn接收resolve 和 rejectfunction MyPromise(fn) &#123; // 初始状态 var state = &#x27;pending&#x27;; // 终值 var finalValue = null; // 收集then中注册的第一个函数，fullfilled var onFulfilledCallback = []; // 收集then中注册的第二个函数，rejected var onRejectedCallback = []; // 内部实现的resolve function resolve(value) &#123;&#125; // 内部实现的reject function reject(err) &#123;&#125; // 实现then方法 // 因为调用方式是 obj.then，属于实例属性 // 接收2个参数onFulfilled, onRejected this.then = function (onFulfilled, onRejected) &#123;&#125;; fn(resolve, reject);&#125; 填充基本的 promise 功能实现resolve,reject,then方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 常量定义状态const PENDING = &#x27;pending&#x27;;const RESOLVED = &#x27;resolved&#x27;;const REJECTED = &#x27;rejected&#x27;;// promise构造函数，接收一个函数fn，fn接收resolve 和 rejectfunction MyPromise(fn) &#123; // 初始状态 var state = &#x27;pending&#x27;; // 终值 var finalValue = null; // 收集then中注册的第一个函数，fullfilled var onFulfilledCallback = []; // 收集then中注册的第二个函数，rejected var onRejectedCallback = []; // 内部实现的resolve function resolve(value) &#123; // 只有状态为pending时，可以触发 if (state === PENDING) &#123; // 修改状态为 resolved state = RESOLVED; // 修改该promise终值为调用时传递的值 finalValue = value; // 将收集到的then注册的方法，全部执行一遍 onFulfilledCallback.forEach((cb) =&gt; &#123; cb(value); &#125;); &#125; &#125; // 内部实现的reject function reject(err) &#123; // 只有状态为pending时，可以触发 if (state === PENDING) &#123; // 修改状态为 rejected state = RESOLVED; // 修改该promise终值为调用时传递的值 finalValue = err; // 将收集到的then注册的方法，全部执行一遍 onRejectedCallback.forEach((cb) =&gt; &#123; cb(err); &#125;); &#125; &#125; // 实现then方法 // 因为调用方式是 obj.then，属于实例属性 // 接收2个参数onFulfilled, onRejected this.then = function (onFulfilled, onRejected) &#123; // 调用then的时候，如果该promise已经决议了，则执行其注册的回调 if (state === RESOLVED) &#123; onResolved(value); &#125; if (state === REJECTED) &#123; onRejected(value); &#125; // 继续注册then的参数到各自回调中 if (state === PENDING) &#123; onFulfilledCallback.push(onFulfilled); onRejectedCallback.push(onRejected); &#125; &#125;; // 执行new promise(fn)中的fn，有可能出错，所以try catch包裹 try &#123; fn(resolve, reject); &#125; catch (err) &#123; // 出错就就决议这个promise为reject，调用其reject方法 reject(err); &#125;&#125; 完善 then then方法返回一个新的promise2，而promise2的终值，取决于上一个promise的then的返回值，我们来改造then then方法接收 2 个回调函数，非必传，未传时需要有默认的，因为空then可以透传结果。如下 1234var p = new Promise((resolve) =&gt; resolve(1));p.then() .then() .then((r) =&gt; console.log(r)); // 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182this.then = function (onResolved, onRejected) &#123; // 判断then注册的是否是函数，否则要提供默认函数，透传结果 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : (v) =&gt; v; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err; &#125;; let promise2 = null; if (state === RESOLVED) &#123; promise2 = new MyPromise((resolve, reject) =&gt; &#123; // 因为执行onResolved的函数可能会出错，所以try包裹 try &#123; // 拿到前一个promise的then中第一个参数（onResolved）执行后的结果，这里用x表示。 const x = onResolved(value); // 如果x是一个x-promise，则我们需要用这个x-promise的终值作为promise2的终值 if (x instanceof MyPromise) &#123; // 这里传递给x.then的 onFulfilled函数，是 promise2的 resolve，如果x-promise决议了，就会去调用promise2的resolve，从而决定了promise2的终值。 x.then(resolve, reject); &#125; else &#123; // 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。 resolve(x); &#125; &#125; catch (err) &#123; reject(err); &#125; &#125;); // 返回promise2 return promise2; &#125; if (state === REJECTED) &#123; promise2 = new MyPromise((resolve, reject) =&gt; &#123; // 这里解析的道理与上面一样。 try &#123; const x = onRejected(value); if (x instanceof MyPromise) &#123; x.then(resolve, reject); &#125; &#125; catch (err) &#123; reject(err); &#125; &#125;); return promise2; &#125; // 继续注册then的参数到各自回调中 if (state === PENDING) &#123; // promise1还未决议，不清楚是执行resolve还是reject，所以，将回调函数插入对应数组 promise2 = new MyPromise((resolve, reject) =&gt; &#123; // 将promise1的then方法注册的函数插入 // then的第一个参数：(res) =&gt; &#123;&#125; onFulfilledCallback.push(function (value) &#123; try &#123; var x = onResolved(value); if (x instanceof Promise) &#123; x.then(resolve, reject); &#125; else &#123; // 如果x不是我们的MyPromise实例，则直接调用promise2的resolve，决议即可。 resolve(x); &#125; &#125; catch (err) &#123; reject(err); &#125; &#125;); // then的第二个参数 (err) =&gt; &#123;&#125; onRejectedCallback.push(function (reason) &#123; try &#123; var x = onRejected(reason); if (x instanceof Promise) &#123; x.then(resolve, reject); &#125; &#125; catch (err) &#123; reject(err); &#125; &#125;); &#125;); return promise2; &#125;&#125;; 实现 catch实现了then后，再实现catch会很简单，catch实际上就是then(null, onRejected)，第一个参数不处理。 看看原生的实现方式 1234567var p = new Promise((resolve, reject) =&gt; &#123; reject(new Error(&#x27;this is error&#x27;));&#125;);p.catch((err) =&gt; &#123; console.log(err); // 打印Error&#125;); 1234// 接收一个处理错误的方法，方法接收一个reasonthis.catch = function (fn) &#123; this.then(null, fn);&#125;; 实现 Promise.all看看原生的实现 12345678910111213141516171819var p1 = new Promise((resolve) =&gt; resolve(1));var p2 = new Promise((resolve) =&gt; resolve(2));Promise.all([p1, p2]).then((res) =&gt; &#123; console.log(res); // [1,2]&#125;);// 如果有rejected掉的，则整个promise rejected掉var p3 = new Promise((resolve, reject) =&gt; &#123; reject(new Error(&#x27;this is error&#x27;));&#125;);Promise.all([p1, p2, p3]) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); // Error: this is error &#125;); 从原生的实现我们得知，Promise.all做的事有这些： 返回一个 promise 接收一个数组，数组成员都是promise 如果全部成员resolved，则返回一个数组，数组中每一项是每个成员的resolved的终值 如果有一个成员rejected，则整个promise被rejected掉。 12345678910111213141516171819202122232425262728MyPromise.all = function (promises) &#123; // 返回一个promise return new MyPromise((resolve, reject) =&gt; &#123; // 存放每个成员的终值 const res = []; // 循环执行每个成员 for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then( (r) =&gt; &#123; // 如果成功resolved了，就往终值数组里塞入终值 res.push(r); // 当终值数组长度和传入的promise长度相等，则可以resolved整个大promise，终值就是终值数组 if (res.length === promises.length) &#123; resolve(res); &#125; &#125;, (err) =&gt; &#123; reject(err); &#125; ); // 原本尝试用catch来捕获错误，不行 // 原因：catch通过then模拟的，比then中的第二个参数执行，慢。因为setTimeout插入macro的时机关系。 &#125; // 原本将resolve放到这里执行，不行。 // 原因：因为所有异步通过setTimeout来实现，for循环结束了，立马就执行resolve了，在reject之前执行，导致整个promise是resolved的状态 // resolve(res) &#125;);&#125;; 总结该版本的 promise 整体较为容易理解，真正的模拟实现，还应该根据PromiseA+规范约定的，处理各个promise实现的兼容，这里就不做分析了，网上有很多。 至于race等方法，其实跟all差不多了，只要有一个resolved或rejected了，整体就决议了，感兴趣的读者，自己尝试下。 上一下codesandbox的测试链接，手撕 promise。","categories":[],"tags":[]},{"title":"实现Promise（版本1）","slug":"2020/实现promise_v1","date":"2020-12-29T16:00:00.000Z","updated":"2021-11-06T07:35:17.136Z","comments":true,"path":"2020/12/30/2020/实现promise_v1/","link":"","permalink":"https://690554125.github.io/2020/12/30/2020/%E5%AE%9E%E7%8E%B0promise_v1/","excerpt":"","text":"实现一个Promise。 原生的语法如下 123456var p = new Promise(function (resolve) &#123; resolve(1);&#125;);p.then(function (val) &#123; console.log(val);&#125;); 看起来很简单，就是函数有个then方法呗。 123456789101112function miniPromise() &#123; return &#123; then: (callback) =&gt; &#123; var value = 1; callback(value); &#125;, &#125;;&#125;miniPromise().then(function (v) &#123; console.log(v); // 1&#125;); 实现了一个完全只是语法糖的promise 😁，并没有什么用。 简单实现 promise 接收一个函数 fn，创建 promise 时，fn 自动执行，且 fn 接收resolve。 函数有个then方法，接收一个回调函数，回调函数接收终值。 123456789101112131415161718function MyPromise(fn) &#123; var callback = null; this.then = function (cb) &#123; callback = cb; &#125;; function resolve(value) &#123; callback(value); &#125; fn(resolve);&#125;MyPromise(function (resolve) &#123; resolve(1);&#125;).then((value) =&gt; &#123; console.log(1);&#125;); 上面代码执行会报错，callback不是一个函数。分析看出MyPromise执行时调用了resolve方法，里面通过callback得到值，但是此时then还未调用呢，callback是 null 所以 我们需要等到then注册完callback后在调用，可以将callback异步执行（下一个事件循环），保证同步注册的then函数先触发去注册callback。 1234567891011121314151617181920function MyPromise(fn) &#123; var callback = null; this.then = function (cb) &#123; callback = cb; &#125;; function resolve(value) &#123; setTimeout(() =&gt; &#123; callback(value); &#125;, 1); &#125; fn(resolve);&#125;MyPromise(function (resolve) &#123; resolve(1);&#125;).then((value) =&gt; &#123; console.log(1);&#125;); 看起来可以正常跑，只是当then异步调用时，发现又不管用了。 加入状态机制我们来引入promise的状态机来解决异步注册的问题。 1234567891011121314151617181920212223242526function MyPromise(fn) &#123; var state = &#x27;pedding&#x27;; var value; var deferred = null; // resolve的工作是将状态切换为resolved function resolve(newV) &#123; state = &#x27;resolved&#x27;; value = newV; // 如果resolve时，已经有注册过函数，则执行 if (deferred) &#123; deferred(value); &#125; &#125; // then 注册一个onResolved方法，接收终值 this.then = function (onResolved) &#123; if (state === &#x27;pedding&#x27;) &#123; deferred = onResolved; &#125; else &#123; onResolved(value); &#125; &#125;; fn(resolve);&#125; 上面代码的deferred和onResolved其实是同一个东西，只不过如果state还是pedding状态，则onResolved需要延迟到resolve调用后执行。所以我们可以统一调度调用deferred（或者说是onResolved） 12345678910111213141516171819202122232425262728293031function MyPromise(fn) &#123; var state = &#x27;pedding&#x27;; var value; var deferred = null; // resolve的工作是将状态切换为resolved function resolve(newV) &#123; state = &#x27;resolved&#x27;; value = newV; // 如果resolve时，已经有注册过函数，则执行 if (deferred) &#123; deferred(value); &#125; &#125; // 统一调度调用onResolved function handle(onResolved) &#123; if (state === &#x27;pedding&#x27;) &#123; deferred = onResolved; return; &#125; onResolved(value); &#125; // then 注册一个onResolved方法，接收终值 this.then = function (onResolved) &#123; handle(onResolved); &#125;; fn(resolve);&#125; 这段代码已经实现了promise的基本功能。即便是异步resolve也可以获取到终值。 123456789var promise = new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);promise.then((v) =&gt; &#123; console.log(v);&#125;); then 返回新的 promise then方法返回一个promise，并接受前一个上一个的then返回值作为入参。 如果上一个then没有注册resolved方法，则透传之前的终值。 如果上一个then有注册resolved方法，执行，并将执行结果传递给下一个then 我们先看下原生的效果 12345678910111213141516171819var p = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);// then 返回新的promise。因为可以链式调用then。// 链式的then并非之前的promise，而是新的promisep.then() .then() .then((v) =&gt; &#123; console.log(v); // 前2个then没有获取到终值，透传终值1 &#125;);p.then((v) =&gt; &#123; return v + 1;&#125;).then((v) =&gt; &#123; console.log(v); // 2&#125;); 注意：上面 2 个调用有个很有意思的地方，透传的有 3 个 then，非直接透传的有 2 个 then，打印结果，先 2，后 1。因为透传的多了一层 then 现在我们来改造MyPromise then可能注册了onResolved，也可能没有，没有则需要透传终值，要改状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function MyPromise(fn) &#123; var state = &#x27;pedding&#x27;; var value; var deferred = null; // resolve的工作是将状态切换为resolved function resolve(newV) &#123; state = &#x27;resolved&#x27;; value = newV; // 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了 if (deferred) &#123; handle(deferred); &#125; &#125; // 统一调度调用onResolved // 改造3：接收的是个对象了，所以要改 function handle(handler) &#123; if (state === &#x27;pedding&#x27;) &#123; deferred = handler; return; &#125; var handledValue = value; // 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值 if (handler.onResolved) &#123; handledValue = handler.onResolved(handledValue); &#125; // 将处理过或默认的终值传递给能够确定终值和状态的resolve handler.resolve(handledValue); &#125; // then 注册一个onResolved方法，接收终值 this.then = function (onResolved) &#123; // 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。 return new MyPromise((resolve) =&gt; &#123; // 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！ // 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。 handle(&#123; onResolved, resolve, &#125;); &#125;); &#125;; fn(resolve);&#125; 我们来调用试试。 123456789101112131415161718192021222324var p1 = new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p1.then() .then() .then() .then((v) =&gt; &#123; console.log(v); // 1 &#125;);var p2 = new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p2.then((v) =&gt; &#123; return v + 1;&#125;).then((v) =&gt; &#123; console.log(v); // 2&#125;); 注意打印顺序是 1，2，并非原生的 2，1。因为我们模拟的函数里并没有让 then 异步处理，而是同步的。 如果 then 返回的是 promise上面的链式调用，只处理了普通的终值，如果终值本身就是promise的话，我们就需要在then中对终值在进行then的写法，嵌套会越来越深。如： 1234567p.then(promise1 =&gt; &#123; promise1.then(promise2 =&gt; &#123; promise2.then(promise3 =&gt; &#123; promise3.then(...) &#125;) &#125;)&#125;) 看看原生是怎么处理的。 12345678910111213141516171819var time = [];var p = new Promise((resolve) =&gt; &#123; time.push(Date.now()); setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then( () =&gt; new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 2000); &#125;)).then((v) =&gt; &#123; time.push(Date.now()); console.log(v, time[1] - time[0]); // 2 3000&#125;); 原生的 promise.then返回的如果是新的promise，则后续的链都是以这个新的promise的resolved后的终值来传递了，跟最开始的旧promise无关了。所以我们要对then返回的是promise做个判断处理，如果then返回的是一个promise，等待其resolved后，传递它的终值。 因为无论有没有上一个promise注册的onResolved方法，最终都会走resolve来确定新promise的状态和终值，我们就在resolve做判断处理就好了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function MyPromise(fn) &#123; var state = &#x27;pedding&#x27;; var value; var deferred = null; // resolve的工作是将状态切换为resolved function resolve(newV) &#123; // 改造5：如果接收到的终值是一个promise，则调用其then方法，终止旧的promise，开启基于返回的新的promise进行传递 if (newV &amp;&amp; typeof newV.then === &#x27;function&#x27;) &#123; newV.then(resolve); return; &#125; state = &#x27;resolved&#x27;; value = newV; // 改造4：deferred在改造3中已经是个对象了，这个对象就交给handle来处理就行了 if (deferred) &#123; handle(deferred); &#125; &#125; // 统一调度调用onResolved // 改造3：接收的是个对象了，所以要改 function handle(handler) &#123; if (state === &#x27;pedding&#x27;) &#123; deferred = handler; return; &#125; var handledValue = value; // 如果有上个then注册的onResolved方法，则调用，获取到处理后的终值 if (handler.onResolved) &#123; handledValue = handler.onResolved(handledValue); &#125; // 将处理过或默认的终值传递给能够确定终值和状态的resolve handler.resolve(handledValue); &#125; // then 注册一个onResolved方法，接收终值 this.then = function (onResolved) &#123; // 改造1： 返回一个promise，promise接收resolve函数，用于改变这个返回的新promise的状态，并更改其终值。 return new MyPromise((resolve) =&gt; &#123; // 改造2：如果onResolved（前一个promise.then注册的处理终值的方法）存在，需要调用，获取到处理后的终值给到这个新的promise。如果onResolved没有，需要透传，透传则调用resolve这个方法（就是function resolve）方法啦！ // 因为我们有个handle方法统一调度onResolved或deferred。我们还是交给它来调度。要改造下handle了。 handle(&#123; onResolved, resolve, &#125;); &#125;); &#125;; fn(resolve);&#125; 测试看看 12345678910111213141516171819var time = [];var p = new MyPromise((resolve) =&gt; &#123; time.push(Date.now()); setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then( () =&gt; new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 2000); &#125;)).then((v) =&gt; &#123; time.push(Date.now()); console.log(v, time[1] - time[0]); // 2 3009&#125;); 处理错误promise的异常处理rejected，我们来加上。 先看原生的用法 123456789101112var p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(new Error(&#x27;is a error&#x27;)); &#125;);&#125;);p.then( (v) =&gt; &#123;&#125;, (err) =&gt; &#123; console.log(err); // 捕获异常打印 &#125;); 我们看到，初始化时加入了reject函数，接收一个Error类型的值。在then中第二个参数，来接收该错误，处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function MyPromise(fn) &#123; var state = &#x27;pedding&#x27;; var value; var deferred = null; function resolve(newV) &#123; if (newV &amp;&amp; typeof newV.then === &#x27;function&#x27;) &#123; newV.then(resolve); return; &#125; state = &#x27;resolved&#x27;; value = newV; if (deferred) &#123; handle(deferred); &#125; &#125; // 改造1：增加reject函数，将状态变为 rejected。 function reject(err) &#123; state = &#x27;rejected&#x27;; value = err; if (deferred) &#123; handle(deferred); &#125; &#125; function handle(handler) &#123; if (state === &#x27;pedding&#x27;) &#123; deferred = handler; return; &#125; var handledValue = value; // 改造6：handler比之前多了onRejected和reject，根据state状态调用对应的then处理函数 var handleCallback; if (state === &#x27;resolved&#x27;) &#123; handleCallback = handler.onResolved; &#125; else if (state === &#x27;rejected&#x27;) &#123; handleCallback = handler.onRejected; &#125; if (handleCallback) &#123; handledValue = handleCallback(handledValue); &#125; handler.resolve(handledValue); &#125; // 改造4：then方法接收第二个参数处理error this.then = function (onResolved, onRejected) &#123; return new MyPromise((resolve) =&gt; &#123; handle(&#123; onResolved, resolve, // 改造5：将上一个处理异常的onRejected和当前reject交给handle来统一调度 onRejected, reject, &#125;); &#125;); &#125;; //改造3：接收第二个参数reject fn(resolve, reject);&#125; 测试下 1234567891011121314var p = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(new Error(&#x27;hello&#x27;)); &#125;, 1000);&#125;);p.then( (v) =&gt; &#123; console.log(&#x27;succ&#x27;, v); &#125;, (err) =&gt; &#123; console.log(&#x27;fail&#x27;, err); // fail Error: hello &#125;); promise.catch平时捕获异常用的最多的应该还是promise.catch。 我们来看下原生的用法 12345678910111213141516// 已知错误var p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;123&#x27;); &#125;, 1000);&#125;);p.then().catch((err) =&gt; &#123; console.log(err); // 123&#125;);// 未知错误，通常在resolve执行中，或then的onResolved出错，我们也应该捕获。var p2 = new Promise((resolve) =&gt; &#123; resolve(a);&#125;); 尝试实现下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function MyPromise(fn) &#123; var state = &#x27;pedding&#x27;; var value; // 改造5：标志符，用来控制实例化promise时有无注册catch来控制抛错还是用catch(实际上就是then中的onResovled)处理 var catcher = null; var deferred = null; function resolve(newV) &#123; // 改造1：捕获resolve可能出现的问题 try &#123; if (newV &amp;&amp; typeof newV.then === &#x27;function&#x27;) &#123; newV.then(resolve); return; &#125; state = &#x27;resolved&#x27;; value = newV; if (deferred) &#123; handle(deferred); &#125; &#125; catch (err) &#123; reject(err); &#125; &#125; function reject(err) &#123; state = &#x27;rejected&#x27;; value = err; if (deferred) &#123; handle(deferred); &#125; else &#123; setTimeout(() =&gt; &#123; if (!catcher) &#123; throw value; &#125; &#125;, 0); &#125; &#125; function handle(handler) &#123; if (state === &#x27;pedding&#x27;) &#123; deferred = handler; return; &#125; // 改造3：因为promise是异步的，所有操作需要异步处理 var handledValue = value; var handleCallback; // 改造2：捕获handle传入的处理函数时可能出现的问题 try &#123; if (state === &#x27;resolved&#x27;) &#123; handleCallback = handler.onResolved; &#125; else if (state === &#x27;rejected&#x27;) &#123; handleCallback = handler.onRejected; &#125; if (handleCallback) &#123; handledValue = handleCallback(handledValue); &#125; &#125; catch (err) &#123; handler.reject(err); &#125; handler.resolve(handledValue); &#125; this.then = function (onResolved, onRejected) &#123; return new MyPromise((resolve) =&gt; &#123; handle(&#123; onResolved, resolve, onRejected, reject, &#125;); &#125;); &#125;; // catch方法也会返回一个promise，实际上就等于then方法第一个参数不传，第二个参数处理err this.catch = function (fn) &#123; // 如果注册了catch，则异常交给catch来做 catcher = true; // 注册catch this.then(null, fn); &#125;; // 改造4：初始化promise时也可能出错，若出错，直接调用reject try &#123; fn(resolve, reject); &#125; catch (err) &#123; reject(err); &#125;&#125; promise 需要异步PromiseA+规范要求解决程序，也就是 resolve 和 reject 的执行都是异步的。 所以我们需要对handle函数做异步调用，我们使用setTimeout模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function MyPromise(fn) &#123; var state = &#x27;pedding&#x27;; var value; var catcher = null; var deferred = null; function resolve(newV) &#123; try &#123; if (newV &amp;&amp; typeof newV.then === &#x27;function&#x27;) &#123; newV.then(resolve); return; &#125; state = &#x27;resolved&#x27;; value = newV; if (deferred) &#123; handle(deferred); &#125; &#125; catch (err) &#123; reject(err); &#125; &#125; function reject(err) &#123; state = &#x27;rejected&#x27;; value = err; if (deferred) &#123; handle(deferred); &#125; else &#123; setTimeout(() =&gt; &#123; if (!catcher) &#123; throw value; &#125; &#125;, 0); &#125; &#125; function handle(handler) &#123; if (state === &#x27;pedding&#x27;) &#123; deferred = handler; return; &#125; // 改造：因为promise是异步的，所有操作需要异步处理 setTimeout(() =&gt; &#123; var handledValue = value; var handleCallback; try &#123; if (state === &#x27;resolved&#x27;) &#123; handleCallback = handler.onResolved; &#125; else if (state === &#x27;rejected&#x27;) &#123; handleCallback = handler.onRejected; &#125; if (handleCallback) &#123; handledValue = handleCallback(handledValue); &#125; &#125; catch (err) &#123; handler.reject(err); &#125; handler.resolve(handledValue); &#125;, 0); &#125; this.then = function (onResolved, onRejected) &#123; return new MyPromise((resolve) =&gt; &#123; handle(&#123; onResolved, resolve, onRejected, reject, &#125;); &#125;); &#125;; this.catch = function (fn) &#123; catcher = true; this.then(null, fn); &#125;; try &#123; fn(resolve, reject); &#125; catch (err) &#123; reject(err); &#125;&#125; Promise.all 方法 接收一个数组，数组成员都是promise。 数组中所有的promise都resolved，整体才能resolve，否则reject掉第一个出错的数组成员promise。 该函数返回一个新的promise，终值是所有数组成员的终值构成的数组。 123456789101112131415MyPromise.all = function (arr) &#123; var resArr = []; return new MyPromise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] .then((r) =&gt; &#123; resArr.push(r); &#125;) .catch((err) =&gt; &#123; reject(err); &#125;); &#125; resolve(resArr); &#125;);&#125;; 总结这个版本的实现虽然可以达到promise基本的功能，但是思路有点绕。 而且有个bug，未实现catch和onRejected函数的话，不会抛错，内部逻辑里handle函数判断已经reject了，不在会设置deferred，导致静默报错了。","categories":[],"tags":[]},{"title":"探究JS原型","slug":"2020/探究原型","date":"2020-12-29T16:00:00.000Z","updated":"2021-11-06T07:35:54.647Z","comments":true,"path":"2020/12/30/2020/探究原型/","link":"","permalink":"https://690554125.github.io/2020/12/30/2020/%E6%8E%A2%E7%A9%B6%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"详细分析原型对象的构成和作用，理清prototype，__proto__相关的关系。 prototype原型是 JS 诞生就有的， 但是原型的访问方式，在“远古”时代，唯一可靠的方法就是通过构造函数的prototype属性来获取和设置原型对象。 不是原型，只是普通属性函数创建时，默认会有一个名为prototype的常规普通属性，这个属性只有在 函数当做构造函数，且通过new创建实例对象时才有用。 new F()调用时，如果有F.prototype，则会将F.prototype作为实例对象的[[Prototype]]。 12345function Parent() &#123;&#125;var person = new Parent();person.__proto__ === Parent.prototype; // true 但如果之后修改了F.prototype = other Object，则后续new F()所创建的实例对象则会使用新的对象来作为[[Prototype]]，原本已生成的实例对象的原型还会保留旧值。 12345function Parent() &#123;&#125;var person1 = new Parent();Parent.prototype = &#123;&#125;;var person2 = new Parent();person1.__proto__ === person2.__proto__; // false 至于为什么说prototype不是原型，而只是普通属性，那是因为不作为new F()使用的话，它真的与普通属性无差异，没有任何魔法。 1234var parent = &#123; prototype: &#x27;普通属性&#x27;,&#125;;parent.prototype; // 普通属性 F.prototype 的构成所有函数创建时具有一个默认的prototype属性，该属性指向的对象里只有一个构造器属性constructor。 constructor该属性指向构造函数本身。 12function Parent() &#123;&#125;Parent.prototype.constructor === Parent; // true 如果不去改变prototype，通过构造函数生成的实例对象，也可以使用constructor，我们就可以知道该实例属于哪个类（由哪个构造器生成） 123function Parent() &#123;&#125;var person = new Parent();person.constructor === Parent; // true 但constructor本身并不可靠，因为prototype可以随意更改，导致无法判断实例对象到底是由谁实现。 1234function Parent() &#123;&#125;Parent.prototype = &#123;&#125;;var person = new Parent();person.constructor === Parent(); // false 自定义属性、方法如上所说，默认的prototype属性所指的对象，只有一个constructor。因此我们会对prototpye进行扩展，当通过new F()创建实例时，实例将会获得（原型继承）我们扩展的方法，属性等等，这是prototype最重要的作用。 123456function Parent() &#123;&#125;Parent.prototype.run = function () &#123; console.log(&#x27;run&#x27;);&#125;;var parent = new Parent();parent.run(); // run __proto__ 、setPrototypeOf、getPrototypeOf前一篇文章介绍过，__proto__是浏览器自己实现的访问和修改原型的访问器属性，而setPrototypeOf和getPrototypeOf是标准中制定的方法，他们的效果一样。 12345var a = &#123;&#125;;a.__proto__;function b() &#123;&#125;b.__proto__; 可以看到 a 对象和 b 函数的原型不太一样。 普通字面量对象的原型字面量对象实际上是由 JS 引擎调用原生构造函数Object来生成的。 12345678910var a = &#123;&#125;; // 相当于 var a = new Object();// 通过new Object，因此Object.prototype 分配给了实例 a 的[[Prototype]]a.__proto__ === Object.prototype; // true// a实例由Object函数构造生成，所以其constructor 就是 Objecta.constructor === Object; // true// Object.prototype除了constructor外还有许多方法，比如toString，因此a可以使用这些方法（a上不存在，顺着原型查找）a.toString(); // [object Object] 函数的原型当打印函数的原型，发是一个原生的函数方法–!。 12function b() &#123;&#125;b.__proto__; // f() &#123; [native code] &#125; 不要慌，我们可以按照普通字面量的方式猜想，b 函数这种写法，实际上也是调用了内建Function来创建的。比如new Function()，所以 b 函数是内建Function的实例。我们可以推断出 b 函数的原型继承了Function.prototype 12345function b() &#123;&#125;b.__proto__ === Function.prototype; // true 结果证明是对的// 因此我们的b函数可以使用 Function.prototype上的方法，常见的如函数的apply,call,bind等等。Function.prototype.apply; // f() &#123; [native code] &#125; 这也佐证了上面所提到的，prototype并不是原型对象本身。 12function b() &#123;&#125;b.prototype === b.__proto__; // false 是的，b.prototype真的就只是一个普普通通，简简单单的常规属性而已，它跟__proto__没有任何关系，只不过protoype有默认的对象值&#123;constructor: f b() &#123;&#125;&#125; 那为什么我们要去拓展b.prototype呢？它根本不是原型，扩展的意义是什么呢？ 没错，**protototype不是原型，但是它所引用的对象，可以作为实例的原型。当你通过new b()形式创建出一个实例对象时，b.prototype被作为实例对象的[[Prototype]]啦！这就是为什么我们要往prototype上去扩展的原因，从实例的角度来看，prototype又是原型**，如下证明： 123function Parent() &#123;&#125;var parent = new Parent();parent.__proto__ === Parent.prototype; // true 总结 早期，访问原型对象的方法，是通过F.prototype，只有函数才有这个属性。后期浏览器厂商实现了__proto__访问器，以及 ES 标准setPrototypeOf和getPrototypeOf。 函数创建时，会自动带有prototype属性，属性值是个对象，里面包含construnctor，constructor指向了函数本身，可以用来判断实例由谁构造生成，但并不准确，因为prototype可以被更改。稳妥的做法是，不要重写prototype对象，而只是在其上增加属性和方法。 F.prototype只是一个常规属性，并无魔法。只有在通过new F()来创建实例时才有用，F.prototype会被用作创建实例的[[Prototype]]。 字面量对象的原型是一个对象，而函数的原型是一个内建函数。而且函数的原型并不等于F.prototype，侧面证明了prototype只是一个普通属性。 从生成的实例的角度去看构造函数的prototype，它又是原型对象。","categories":[],"tags":[]},{"title":"探究JS继承","slug":"2020/探究继承","date":"2020-12-29T16:00:00.000Z","updated":"2021-11-06T07:35:44.757Z","comments":true,"path":"2020/12/30/2020/探究继承/","link":"","permalink":"https://690554125.github.io/2020/12/30/2020/%E6%8E%A2%E7%A9%B6%E7%BB%A7%E6%89%BF/","excerpt":"","text":"JS 世界的继承如何实现，原型在继承中的作用，以前的继承和现在的继承。 原型查找机制JS 中继承依赖原型实现，访问一个实例不存在的属性时，会去实例的原型对象上查找。 1234function Parent() &#123;&#125;Parent.prototype.run = true;var person = new Parent();person.run; // true 如果实例原型上不存在，则会去实例原型的原型上查找，以此类推直到原型顶端，也就是 null。 123var a = &#123;&#125;;a.__proto__; // Object.prototypea.__proto__.__proto__; // 也就是 Object.prototype.__proto__ = null JS 中一切皆对象，函数也是对象，我们看看函数的原型链（原型-原型-原型-…这种链式，被称为原型链） 1234function b() &#123;&#125;b.__proto__ === Function.prototype; // true f () &#123; [native code] &#125; 也就是 Function.prototypeb.__proto__.__proto__ === Object.prototype; // true 也就是Function.prototype.__proto__，别忘了Function.prototype也是对象，所以其原型是 Object.prototype。这也说明了，JS中一切皆对象！b.__proto__.__proto__.__proto__ === null; // true Object.prototype.__proto__ === null 到头了 配合 JS 原型链查找机制，因此出现了 JS 版本的继承。 new 实例化JS 中通过构造函数来模拟类，通过prototype来模拟继承。类的实例化则需要用new关键字，new F()。我们看看new做了些什么： 12function Person() &#123;&#125;var a = new Person(); 目前我们就看到new做了三件事： 创建了一个新的对象 返回了该对象**赋值给了a变量。 并且 a 实例的[[Prototype]]关联到了Person.prototype，我们可以通过 a.xx 访问到Person.prototype的方法和属性，还记得吧！ 因为构造函数模拟了类，类是可以有属性和方法的，我们来给上面的Person类加点料 123456789101112131415function Person(name) &#123; this.name = name; // 类属性 this.sayHi = function () &#123; // 类方法 console.log(`Hi $&#123;this.name&#125;`); &#125;;&#125;var a = new Person(&#x27;Jack&#x27;);a.name; // Jacka.sayHi(); // Hi Jackvar b = new Person(&#x27;Loose&#x27;);b.name; // Looseb.sayHi(); // Hi Loose 可以看到，通过Person类，我们声明了 2 个实例 a 和 b，分别访问 name 和 sayHi 方法，使用了实例自己的 name 值，所以Person类在实例化时，里面的 this 指向了实例对象。 所以new一共做了四件事。 实例化时将 this 指向新的对象。 模拟实现一个简单的new 1234567// function myNew(Constructor, Params) : objectfunction myNew(fn) &#123; var obj = &#123;&#125;; obj.__proto__ = fn.prototype; // 或者 var obj = Object.create(fn.prototype) var result = fn.apply(obj, [].slice.call(arguments, 1)); // 调用构造函数fn，并且注意绑定this到新对象，这里就是obj。给构造函数fn的其他参数要排除fn自身。 return typeof result === &#x27;object&#x27; ? result : obj;&#125; 谁继承谁只有一个类，谈不上继承，至少需要一个父类，一个子类继承父类。JS 继承依赖的是原型，请牢记！ 接着，先看一个错误的例子 1234567891011121314function Parent() &#123;&#125;function Son() &#123;&#125;Son.prototype = Parent.prototype; // 这不是继承，这是赤裸裸的让子类原型 和 父类原型 指向同一个对象。Son.prototype.constructor = Son; // 纠正上面一行导致constructor被改写的问题，让它指向正确值var son = new Son();son.constructor === Son; // true 没问题，毕竟上面重写了constructorson.__proto__ === Son.prototype; // trueson.__proto__ === Parent.prototype; // trueson.__proto__.__proto__ === Object.prototype; // true// 而且var parent = new Parent();parent.constructor === Parent; // false 因为父子类原型都相等了，且上Son.prototype.constructor = Son，导致父类实例现在出问题了。 上面的例子并没有体现Son继承了Parent，而是直接让父子类的原型相等了，还导致父类实例的constructor指向到了Son上，完全错误！ 原型继承要达到的是子类原型 继承自 父类的原型，也就是son.__proto__.__proto__ === Parent.prototype，且父类实例和子类实例的constructor都要指向正确的值才对。 我们看看正确的写法 123456789101112function Parent() &#123;&#125;function Son() &#123;&#125;Son.prototype = new Parent(); // 这里实现继承！new Parent()返回了一个对象，这里是一个空的&#123;&#125;，但是其原型指向的时Parent.prototype对象哦，也就是&#123;constructor: Parent&#125;Son.prototype.constructor = Son;var son = new Son();son.constructor === Son; // trueson.__proto__ === Son.prototype; // trueson.__proto__.__proto__ === Parent.prototype; // truevar parent = new Parent();parent.constructor === Parent; // true 这下没问题了，可以看到son实例的原型指向Son类，而Son类又继承自Parent类。各自类实例的constructor指向也正确。 继承版本演进常见形式（原型继承）最常见的形式是将属性写在构造函数中，方法写在原型对象上。 123456789101112131415161718192021function Parent() &#123; this.arr = [];&#125;Parent.prototype.print = function () &#123; console.log(this.arr);&#125;;function Son() &#123;&#125;Son.prototype = new Parent(); // *Son.prototype.constructor = Son;var son = new Son();son.arr.push(1);son.print(); // [1]var son2 = new Son();son2.print(); // [1] son2 不应该打印出[1]。原因是上面*所在的代码导致，Son.prototype等于&#123;arr: []&#125;，后面实例化的son1 son2访问的都是原型上的arr，引用类型，因此son2.arr也打印[1]。 子类实例共享了原型对象上的属性，这种继承是有问题的。所以解决方案就是共享属性移到每个实例自己身上就可以了。 组合继承模式（借用构造函数+原型继承）借用构造函数，意思是Parent在Son中调用，类似class继承中的super调用。注意处理this指向，毕竟是借用，this需要指向Son，不然借用无意义。另外，借用还让我们有机会往父类构造函数传参。 1234567891011121314151617181920212223242526function Parent(name) &#123; this.arr = []; this.name = name;&#125;Parent.prototype.print = function () &#123; console.log(this.arr);&#125;;Parent.prototype.say = function () &#123; console.log(`Hi $&#123;this.name&#125;`);&#125;;function Son(name) &#123; Parent.call(this, name); // *&#125;Son.prototype = new Parent();Son.prototype.constructor = Son;var son1 = new Son(&#x27;1st son&#x27;);son1.arr.push(1); // [1]var son2 = new Son(&#x27;2rd son&#x27;);son2.print(); // []son1.arr === son2.arr; // falseson1.say(); // 1st sonson2.say(); // 2rd son 上面的*实现了借用构造功能，调用时，this 指向的是 son 实例本身，因此Parent构造函数中的代码会往实例本身添加arr和name属性。Son实例各自拥有自身属性，但方法依旧共享Parent.prototype上的。 这种模式的缺点在于： Parent被调用了 2 次，一次是Son内借用，一次是Son.prototype设置 arr和name属性也被创建了 2 次，因为Parent调用了 2 次。在Son的实例身上和Son.prototype原型身上分别创建了，然后 遮蔽效应 让我们在访问 son1.arr时，优先从自身找到arr属性，而不是原型上的。从下图我们可以看出。 寄生组合式继承上面的组合继承的缺点就是调用了 2 次，那我们就想办法只调用一次Parent就可以了。 分析下，Son在通过new实例化的时候，需要将属性挂载到实例身上，否则多个实例就共用了属性，所以Son内的借用构造函数不能省略，这是让Son实例有自身属性的唯一办法。那就只能从Son.prototype = new Parent()身上想办法，用别的方式来继承。 Object.create(proto[, propertiesObject])这个是 ES 标准中的方法，创建一个新对象，使用传入的proto作为原型，并返回这个新对象。第二个参数是自定义新对象的一些属性，和Object.defineProperties方法的参数一样。 123456789var parentProto = &#123; say: function () &#123; console.log(&#x27;say hi&#x27;); &#125;,&#125;;var obj = Object.create(parentProto);obj.say(); // say hiobj.__proto__ === parentProto; // true 但这个方法也有一个缺陷，就是引用类型值共享了。 12345678var parentProto = &#123; arr: [],&#125;;var o1 = Object.create(parentProto);var o2 = Object.create(parentProto);o1.arr.push(1);console.log(o2.arr); // [1] 因为访问的都是原型对象上的arr。 模拟 Object.createIE9 以下是不支持这个方法的，所以考虑到浏览器兼容，我们可以模拟这个方法。 模拟的关键就是理解Object.create干了什么事。 创建了一个新的对象 将参数设置为新对象的原型 返回这个新对象。 12345function ObjectCreate(proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F();&#125; 功能如Object.create 1234567891011121314function ObjectCreate(proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F();&#125;var parentProto = &#123; say: function () &#123; console.log(&#x27;say hi&#x27;); &#125;,&#125;;var obj = ObjectCreate(parentProto);obj.say(); // say hi 寄生组合式继承需要用到的关联原型我们已经说清楚，该功能就是用来解决寄生组合继承开篇说到的Parent被多new了一次来关联原型。 我们来用寄生组合模式重写组合继承模式中 demo。 123456789101112131415161718192021222324252627function Parent(name) &#123; this.arr = []; this.name = name;&#125;Parent.prototype.print = function () &#123; console.log(this.arr);&#125;;Parent.prototype.say = function () &#123; console.log(`Hi $&#123;this.name&#125;`);&#125;;function Son(name) &#123; Parent.call(this, name);&#125;// Son.prototype = new Parent();Son.prototype = Object.create(Parent.prototype); // 原型关联方法改造。兼容IE9以下可以使用上面的模拟Object.create函数ObjectCreateSon.prototype.constructor = Son;var son1 = new Son(&#x27;1st son&#x27;);son1.arr.push(1); // [1]var son2 = new Son(&#x27;2rd son&#x27;);son2.print(); // []son1.arr === son2.arr; // falseson1.say(); // 1st sonson2.say(); // 2rd son 从下图可以看出，属性没有重复声明了。 ES6+的继承自从 ES6 推出了class和extends语法后，JS 中继变得简单了，可以将新的语法看成是函数继承的语法糖，核心功能还是通过prototpye来实现继承，之外有些表现是不同于 ES5 的继承。 使用新语法改写上面的父子类 demo 1234567891011121314151617181920212223class Parent &#123; constructor(name) &#123; this.arr = []; this.name = name; &#125; print() &#123; console.log(this.arr); &#125; say() &#123; console.log(`Hi $&#123;this.name&#125;`); &#125;&#125;class Son extends Parent &#123; constructor(name) &#123; super(name); &#125;&#125;let son1 = new Son(&#x27;1st son&#x27;);let son2 = new Son(&#x27;2rd son&#x27;); 有哪些区别？ class必须通过new调用 class上所有的属性和方法，均不可枚举。 class存在声明提升（赋值没有） class继承，子类constructor里必须先调用super()调用父类构造函数。因为子类期望父类的constructor来完成 new F()干的事，否则没有新对象，无法赋值this 因为函数就是内置Function的实例，所以Son.__proto__指向的是Function.prototype，而类写法Son.__proto__指向的是Parent，因为Son继承自Parent么，利索当然原型应该指向Parent，在通过babel转换语法后，可以看到实现是： 12function Parent() &#123;&#125;var Son = Object.create(Parent); 总结 继承的根本就是原型链的继承（委托），不管是 ES5 还是 ES6+时代。 ES5 时代前的继承是通过函数来模拟实现的。其中最完美的方式是寄生组合式继承，也就是基于prototype来书写公共方法，基于Object.create（模拟函数）来让子类关联父类的原型对象。 我们在 ES5 继承模式中，顺带也清楚了解的new的工作以及模拟new的实现，还有Object.create的工作及其模拟实现。 ES6 时代的class语法，继承实现，以及它和函数继承的一些差别。","categories":[],"tags":[]},{"title":"学习Redux","slug":"2020/搞懂redux","date":"2020-12-29T16:00:00.000Z","updated":"2021-11-06T07:35:00.566Z","comments":true,"path":"2020/12/30/2020/搞懂redux/","link":"","permalink":"https://690554125.github.io/2020/12/30/2020/%E6%90%9E%E6%87%82redux/","excerpt":"","text":"为什么有这篇文章？因为使用 react 技术栈有一段时间了，相应的 redux 状态管理库也使用很久，偶尔一段时间不用，发现就会忘记某些 api，甚至是看过的主要是实现原理又忘的一干二净。所以总结一下，以便忘记后查阅，迅速让大脑有个印象。 是什么？一个单向数据流的状态管理库。 一些概念APP 应用整个的状态都存放在单一的Store中心，修改Store的唯一途径就是发起Action，Action到达Store后，会根据Action提供的动作类型，新的数据，结合旧的状态合成一个新的状态，这个合成新状态的过程称为Reducer。 Reducer 实际上就是一个纯函数，相同输入，得到相同输出，输出 state。 12345function reducer() &#123; return &#123; count: 0 &#125;;&#125; Action 实际上是一个标注的 JS 对象，具有type属性，这是约定的，动作的类型，以便reducer针对不同动作，处理不同逻辑返回新的 state。 1234const addAction = &#123; type: &#x27;add&#x27;, otherData: &#x27;add num&#x27;&#125;; 注意：不能直接修改旧Store，而是生成一份新的Store。目的是为了能够跟踪状态变化，一切有迹可循。 基本使用搭配React数据驱动视图框架，食用更佳！ 创建数据中心Store。接收一个 reducers 函数，该函数用于生成状态数据，无任何action时，reducer的计算将默认返回它所拥有的所有state。 12345import &#123; createStore &#125; from &#x27;redux&#x27;;const Store = createStore(reducers);export default Store; 创建createStore所需的reducers。reducers 是一个函数，返回store。通常我们会有很多页面和组件，每个页面或组件有自己的reducer生成的state，将多个reducer合并为一个大的reducers就是整个 APP 应用需要的store。这种拆分方式方便我们对state业务数据模块化，每个模块只要负责维护部分数据即可。 12345678910111213141516171819202122// reducer只是一个函数，通过对之前的state和当前action的类型及参数的处理，返回新的的statefunction reducerOne(preState, action) &#123; // 一般惯用switch case形式 // 你也可以用if else if const &#123; type &#125; = action; if (type === &#x27;add&#x27;) &#123; return &#123; count: preState + 1 &#125;; &#125; else &#123; return &#123; count: 0 &#125;; &#125;&#125;function reducerTwo(preState, action) &#123; // ... return &#123; name: &#x27;hello&#x27; &#125;;&#125; 因为createStore只接受一个函数，所以我们可以利用redux提供的combineReducers，自动调用多个reducer，获取它们的state合并一下。","categories":[],"tags":[]},{"title":"Babel7 常见配置和概念。","slug":"2019/babel7","date":"2019-12-29T16:00:00.000Z","updated":"2021-11-06T07:30:45.361Z","comments":true,"path":"2019/12/30/2019/babel7/","link":"","permalink":"https://690554125.github.io/2019/12/30/2019/babel7/","excerpt":"","text":"安装我这里就用yarn了，npm一样 12yarn add @babel/core @babel/cli @babel/preset-env -Dyarn add @babel/polyfill 大致先说下装了些啥，core核心，cli工具，可以让我们使用命令行来运行babel命令。 preset-env主角之一，env 是已经在浏览器标准中的意思，Babel 官方的一个新 API 插件集合，可以将一些 ES6+的新 API 转换成 ES5。搭配polyfill主角之一，模拟一个 ES6+的环境，让我们可以使用新的特性。如promise等。 怎么配置 Babel官方推荐用babel.config.js，我们可以在里面写 JS，比如对环境ENV不同，做一些不同的配置。也支持.babelrc文件，这是个独立的文件，通常跟放在项目的根目录。当然你也可以写在package.json中，以babel为key来写配置。 大抵最终导出的其实就两样东西，plugins和presets: 1234&#123; presets: [], plugins: []&#125; Plugins 配置数组格式，可以省略babel-plugin- 123456&#123; &quot;plugins&quot;: [ &quot;myPlugin&quot;, // 同等 &quot;babel-plugin-myPlugin&quot; ]&#125; 对域的写法同样适合 123456&#123; &quot;plugins&quot;: [ &quot;@babel/babel-plugin-name&quot;, // 同等 &quot;@babel/name&quot; ]&#125; 如果单独某个插件需要配置项，则在数组第二个位置写个配置对象。每个插件即一个数组： 1234567&#123; &quot;plugins&quot;: [ [&quot;transform-async-to-module-method&quot;, &#123; &quot;module&quot;: &quot;bluebired&quot; &#125;] ]&#125; 同理，presets也是这样对单独项写配置。 注意加载顺序 plugins是从第一个到最后一个。 presets是从最后一个到第一个。原因官方说是大部分用户会喜欢es2015写在前面， 插件在presets之前开始。 Presets顾名思义，预设。官方提供的@babel/preset-env等其实本质就是一个插件数组而已，无非是用了哪些插件。支持包含带选项的plugin或其他presets 123456789101112131415module.exports = function() &#123; return &#123; plugins: [ &#x27;pluginA&#x27;, &#x27;pluginB&#x27;, [ &#x27;pluginC&#x27;, &#123; opt: 1 &#125; ] ], presets: [require(&#x27;@babel/preset-env&#x27;)] &#125;;&#125;; 关于路径这块，可以绝对，相对路径，也可以全名（从node_modules上找）。 至于配置的写法，在Plugins中已经说过。这里再提醒下，presets是倒序的。 关于配置文件这里注意下有个Monorepo的目录模式。大致意思就是多个 repo，在同一个 package 中管理。 Polyfill之前提到过，模拟 ES5+的环境。也会少量的在原型链如 String 上添加一些方法，如includes。官方推荐使用@babel/preset-env，并且设置该presets选项的配置useBuildIns使用。这样可以达到的效果，我们只需要引入我们用到的polyfill代码。 如果你需要所有的ES5+的静态方法，实例方法已经新的API，那你就需要手动在入口文件顶部导入@babel-polyfill，缺点是，这样子是会污染全局环境的。 使用位置不管是CommonJS还是ES6 Modules，我们都需要在应用的入口文件的顶部，加载@babel/polyfill。 和webpack构建工具一起使用的话，我们有 3 种方式引入polyfill。在.babelrc中对presets里的env进行配置项设置，设置useBuildIns。 默认是false，相当于着在webpack.config.js的entry数组头部直接加入。 123module.exports = &#123; entry: [&#x27;@babel/polyfill&#x27;, &#x27;./app.js&#x27;]&#125;; 设为usage，不会在任何地方导入@babel/polyfill，而是用到哪些导哪些，但依旧需安装@babel/polyfill 设为entry，在入口文件的头部加载。 注意在Babel6.x中，useBuildIns只有true和false。 plugin-transform-runtime这个插件，可以重用Babel注入的辅助代码，目的是为了减少代码体积。 12345// 开发依赖`yarn add @babel/plugin-transform-runtime -D`// 生产依赖`yarn add @babel/runtime` 前者主要是将helper代码自动从babel-runtime/core-js中引入，不需要我们手动去写。后者相当于一个独立出来的模拟ES5+的环境包，是在打包的时候需要用到的，但为了不污染全局，一些实例属性不能使用。所以这两者是搭配使用的。 常用实践希望达到，复用代码，缩小代码体积，功能还能很全的目标。 复用代码，我们需要使用transform-runtime-plugin，在开发阶段，自动重写我们的导入代码，全部从babel/runtime中导入。 缩小代码体积，我们需要按需加载，transform-runtime-plugin和babel/runtime结合使用就可以达到按需加载，插件会分析我们用到了哪些新的API，如promise，则从import promise2 from &#39;@babel/runtime/core-js/promise，注意到这里使用的是promise2，所以避免了全局污染。 功能全，光有@babel/runtime，还不够，它只能帮我们模拟出大部分ES5+环境，但是如&#39;hello&#39;.includes(&#39;h&#39;)等实例方法，是没有的，原因就是不污染全局环境。所以我们还需要babel-polyfill，但是babel-polyfill包含了完整的ES5+环境，包很大，且数据全局环境引入，会导致污染。所以我们需要一个babel-preset-env，这个预置其实就是包含了很多plugins，需要哪个，我们用哪个，可以根据开发环境来选择，已达到最小使用babel-polyfill，需要设置useBuildIns为usage，意为不直接引入babel-polyfill，而只单独加载用到的。","categories":[],"tags":[]},{"title":"webpack 模块化原理（ES+CJS）","slug":"2019/es-cjs-module","date":"2019-12-29T16:00:00.000Z","updated":"2021-11-06T07:30:54.214Z","comments":true,"path":"2019/12/30/2019/es-cjs-module/","link":"","permalink":"https://690554125.github.io/2019/12/30/2019/es-cjs-module/","excerpt":"","text":"接着上一篇**webpack 模块化原理(es)**。这篇我们看下 es+cjs，2 种模块混合书写，webpack 是如何处理的。demo 和之前差不多。 1234567// src/index.jsimport print from &#x27;./print&#x27;;console.log(print); // 应该是&#123;res: 1&#125;// src/print.js cjs写法const res = 1;exports.res = res; 通过 webpack 编译后，代码如下（同样，做了一些处理，去除分隔符，将模块的内部函数格式化下）大部分跟上一篇中解释的一样，我们看下如下几个东西，在这个编译后的 bundle 中有使用到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149(function (modules) &#123; // webpackBootstrap // The module cache var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = (installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125;, &#125;); // Execute the module function modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); // Flag the module as loaded module.l = true; // Return the exports of the module return module.exports; &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // define getter function for harmony exports // 处理cjs模块的辅助函数。通过给具体实现exports对象新增一个getter属性。 __webpack_require__.d = function (exports, name, getter) &#123; if (!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports __webpack_require__.r = function (exports) &#123; if (typeof Symbol !== &#x27;undefined&#x27; &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &#x27;Module&#x27; &#125;); &#125; Object.defineProperty(exports, &#x27;__esModule&#x27;, &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require __webpack_require__.t = function (value, mode) &#123; if (mode &amp; 1) value = __webpack_require__(value); if (mode &amp; 8) return value; if (mode &amp; 4 &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, &#x27;default&#x27;, &#123; enumerable: true, value: value &#125;); if (mode &amp; 2 &amp;&amp; typeof value != &#x27;string&#x27;) for (var key in value) __webpack_require__.d( ns, key, function (key) &#123; return value[key]; &#125;.bind(null, key) ); return ns; &#125;; // getDefaultExport function for compatibility with non-harmony modules // 针对es和cjs的默认导出，做一些处理。让大家都统一。 // 比如如果模块源码是es的，那么模块的exports.__esModule就会为true，在上一篇有解释过。 // 该函数通过判断module.exports上有没有__esModule，来区分暴露默认导出应该怎么暴露。 // 如果是cjs，它是没有默认导出这个概念的实际上暴露的都是往module.exports = exports，也就是exports身上挂属性。这也就是模块本身，也就是我们这里函数接收的参数module，直接暴露就好了。 // 如果是es，它有默认导出，还有部分导出，默认导出挂在了module.exports.default属性上，其他的挂载modulex.exports[xx]上。所以暴露的时候要暴露defaults这个属性值（这个函数接的参数变量，实际上就是&#123;moduleId: xx, l: false, exports: &#123;&#125;&#125;中的exports，因为模块加载函数已经在底部返回了啊, return module.exports）。 // 这里稍后（先去看1，2两步骤，在下面）让我们我们结合print.js来讲解 // 3. module参数就是&#123;res: 1&#125;。因为print模块源码是cjs写的，所以它没有被打上__esModule=true的标记。 // 因此，getter就是第二个函数getModuleExports，这个函数实际上就直接返回了&#123;res: 1&#125; // 接着，调用了d方法，给getModuleExports这个函数，赋了一个a的getter属性，当你访问这个a时，就是调用getModuleExports这个函数，然后又拿到了&#123;res: 1&#125;。可以看出来就是这样a: &#123;res: 1&#125; // d方法返回的就是getModuleExports这个函数。 __webpack_require__.n = function (module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module[&#x27;default&#x27;]; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, &#x27;a&#x27;, getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call // 借用了hasOwnProperty方法而已。 __webpack_require__.o = function (object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // __webpack_public_path__ __webpack_require__.p = &#x27;&#x27;; // Load entry module and return exports // 开始加载入口函数 return __webpack_require__((__webpack_require__.s = &#x27;./src/index.js&#x27;));&#125;)(&#123; &#x27;./src/index.js&#x27;: /*! no exports provided */ function (module, __webpack_exports__, __webpack_require__) &#123; &#x27;use strict&#x27;; eval( &#x27;__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ &quot;./src/print.js&quot;);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_print__WEBPACK_IMPORTED_MODULE_0__);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n//# sourceURL=webpack:///./src/index.js?&#x27; ); // __webpack_require__.r(__webpack_exports__) // 1、这里先用webpack自己的模块加载函数来加载print.js，这里函数还是会返回module.exports，只不过我们看print.js模块函数实现可以看到exports.res = res。所以我们这里拿到的就是&#123;res: 1&#125;这个对象而已。 // var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( // &#x27;./src/print.js&#x27; // ) // 2. 所以这里__webpack_require__.n(&#123;res: 1&#125;)，让我们看看上面这个n函数干了些啥？ // var _print__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n( // _print__WEBPACK_IMPORTED_MODULE_0__ // ) // 4. 上面的n函数调用完了，返回的是getModuleExports这个函数，且这个函数还有个a属性的getter // 5. 赋值给_print__WEBPACK_IMPORTED_MODULE_0___default后，我们去调用这个函数的a属性，不言而喻，就是&#123;res: 1&#125;。至此大功告成！。 // console.log(_print__WEBPACK_IMPORTED_MODULE_0___default.a) &#125;, &#x27;./src/print.js&#x27;: /*! no static exports found */ function (module, exports) &#123; eval( &#x27;var res = 1;\\nexports.res = res;\\n\\n//# sourceURL=webpack:///./src/print.js?&#x27; ); // var res = 1 // 因为源码是cjs模块，非es模块，所以没有给exports配__esModule=true的属性（这个配置是通过__webpack_exports__.r函数实现的） // exports.res = res &#125;,&#125;);","categories":[],"tags":[]},{"title":"webpack 模块化原理（ES 的）","slug":"2019/es-module","date":"2019-12-29T16:00:00.000Z","updated":"2021-11-06T07:31:14.755Z","comments":true,"path":"2019/12/30/2019/es-module/","link":"","permalink":"https://690554125.github.io/2019/12/30/2019/es-module/","excerpt":"","text":"写了一个最简单的 demo，webpack 配置也是最简的，主要是弄清楚 webpack 如何实现模块的加载。 1234567// src/index.jsimport print from &#x27;./print&#x27;;console.log(print);// src/print.jsconst res = 1;export default res; 接下来通过 webpack 打包，贴上打包的代码（对打包的代码稍微处理了下，去掉了一些分隔符，并且将 2 个模块中的代码格式化了下，打包的是通过 eval 来执行的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175// 可以看到，一个IIFE函数，接收一个参数modules// 这里的modules就是最下面自执行传入的一个对象，对象中包含了index.js 和 print.js通过webpack加工后的的具体实现代码。(function (modules) &#123; // webpackBootstrap // The module cache // 官方注释：模块的缓存对象，主要是希望加载过的模块不在执行第二遍。 var installedModules = &#123;&#125;; // The require function // 模块的加载函数，核心部分，实现了模块的加载。 // 接收一个参数模块id，这里其实就是&#x27;./src/index.js&#x27;和&#x27;./print/index.js&#x27;。 function __webpack_require__(moduleId) &#123; // Check if module is in cache // 第一步，检查模块缓存对象是否已经有过了，如果有了，就是返回出去。 if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) // 如果没有，就把模块创建出来，并且也挂到缓存模块对象installedModules上。 // 这里利用了=的返回值的技巧。既将模块对象&#123;i: xx, l: xx, exports: xx&#125;赋值给了缓存模块上对应的模块key上，也赋值给了module变量 var module = (installedModules[moduleId] = &#123; // 就是标记模块的ID，这里也就是&#x27;./src/index.js&#x27;，&#x27;./src/main.js&#x27; i: moduleId, // 模块是否加载过，一个标志符。 l: false, // 模块的具体实现，会有defaults和其他未挂载到defaults上的方法，比如exports function hello() &#123;&#125; // 那么exports对象就会被填充为exports: &#123;defaults: xxx, hello: xxx&#125; // 至于这里exports对象的填充，是在最下面的自执行函数传参的参数中写的。 exports: &#123;&#125;, &#125;); // Execute the module function // 执行模块函数，可以注意到我们打包后的代码（每个模块）都被处理为了函数 // 正事开始了，执行我们写的代码。使用call方法，将this指向模块的exports，因为exports里才是真正的代码实现。 // 然后传递3个参数，模块整体，模块的exports，还有模块加载函数。 modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); // Flag the module as loaded // 函数执行完后，将上面最开始创建新模块所声明的l，也就是模块加载标志符设为true，因为是对象，引用关系，缓存模块对象中对应的那个模块的加载标志也已经是true了 module.l = true; // Return the exports of the module // 这步也很关键。 // 浏览器目前不认识es6和cjs的模块加载，所以想要实现模块的加载，肯定是通过函数来实现。 // 每个模块需要暴露出自己的值或API等，而上面一直在说模块代码的具体实现，是写在exports里的，所以，暴露它，让其他模块能使用被暴露模块的值。 // 在下面的&#x27;./src/index.js&#x27;中可以看到，使用webpack模块加载函数引入了&#x27;./src/print/js&#x27;，并且使用了print.js中的值，这个值就是这里return暴露出去的。 return module.exports; &#125; // expose the modules object (__webpack_modules__) // 模块都挂到模块加载函数的属性m上。具体作用没看出来。 __webpack_require__.m = modules; // expose the module cache // 缓存模块对象也挂到模块加载函数的c属性上。 __webpack_require__.c = installedModules; // define getter function for harmony exports // 实现了一个方法。看着像是定义对象的某个属性，并将该属性配置为可枚举，且给他了一个getter实现。 __webpack_require__.d = function (exports, name, getter) &#123; if (!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports // 比较重要的一个函数，实现了对模块的一个类型定义，是不是es模块。 __webpack_require__.r = function (exports) &#123; if (typeof Symbol !== &#x27;undefined&#x27; &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &#x27;Module&#x27; &#125;); &#125; Object.defineProperty(exports, &#x27;__esModule&#x27;, &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require // 这个函数没看出来有什么作用。 __webpack_require__.t = function (value, mode) &#123; if (mode &amp; 1) value = __webpack_require__(value); if (mode &amp; 8) return value; if (mode &amp; 4 &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, &#x27;default&#x27;, &#123; enumerable: true, value: value &#125;); if (mode &amp; 2 &amp;&amp; typeof value != &#x27;string&#x27;) for (var key in value) __webpack_require__.d( ns, key, function (key) &#123; return value[key]; &#125;.bind(null, key) ); return ns; &#125;; // getDefaultExport function for compatibility with non-harmony modules // 获取默认导出的函数，好像是针对于哪些不协调的模块。 __webpack_require__.n = function (module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module[&#x27;default&#x27;]; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, &#x27;a&#x27;, getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call // 对象原型上一个函数的复用而已。 __webpack_require__.o = function (object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // __webpack_public_path__ __webpack_require__.p = &#x27;&#x27;; // Load entry module and return exports // 加载入口函数，比较重要，前面的一些辅助函数等都已经声明完了。 // 这里开始从入口函数加载，开始执行我们的代码了。 // 模块加载函数，这里也用了=的返回的技巧。 // 我们将&#x27;./src/index.js&#x27;代入到上面的模块加载函数中去，逻辑解释如下： // 1. 检查缓存模块对象是否已经有了&#x27;./src/index.js&#x27;这个键名对应的模块，有则返回它的具体实现，也就是exports对象。 // 2. 入口函数首次并没有被加载过，所以开始执行生成新模块的动作。var module = &#123;moduleId: &#x27;./src/index.js&#x27;, l: false, exports: &#123;&#125;&#125; // 3. 开始执行这个模块也就是&#x27;./src/index.js&#x27;对应的函数。用call的方式来调用，传递了3个参数。在下面的index.js具体实现中可以看到。我们来解读。 return __webpack_require__((__webpack_require__.s = &#x27;./src/index.js&#x27;));&#125;)(&#123; &#x27;./src/index.js&#x27;: /*! no exports provided */ function (module, __webpack_exports__, __webpack_require__) &#123; &#x27;use strict&#x27;; eval( &#x27;__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print */ &quot;./src/print.js&quot;);\\n\\nconsole.log(_print__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;]);\\n\\n//# sourceURL=webpack:///./src/index.js?&#x27; ); // 4. 首先调用定义模块是否是es的函数，将我们的&#x27;./src/index.js&#x27;这个模块对象&#123;moduleId: xx, l: false, exports: &#123;&#125;&#125;在添加一个__esModule: true的属性。的确我们在写代码时也就是用的es模块。 // __webpack_require__.r(__webpack_exports__); // 5. 我们在index.js中引入了print.js，这里使用了模块加载器函数来加载print。加载的逻辑解析，【如上面的1，2，3步骤】。我们认为是6,7,8（开始执行print.js中的具体实现）吧，方便逻辑的继续。 // var _print__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;./src/print.js&quot;); // 13. 啦啦啦，上面这一行，__webpack_require__加载的print.js，接上了第12步扔出来的对象&#123;default: 1, __esModule: true&#125; // 14. 打印了对象的default，也就是1。大工告成。 // console.log(_print__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;]); // 这里因为我们在源码没有在index模块暴露任何东西，可以看到这里转换后的实现，webpack也并没有对index模块的exports做过多的改造。 // 好了index也执行完了，终于也把index模块的&#123;l: false&#125; 设为 true了。可以看到，print先设为true的，index是最后，因为print的调用和执行都在index中做的，属于index函数的一部分哦！ &#125;, &#x27;./src/print.js&#x27;: /*! exports provided: default */ function (module, __webpack_exports__, __webpack_require__) &#123; &#x27;use strict&#x27;; eval( &#x27;__webpack_require__.r(__webpack_exports__);\\nvar res = 1;\\n/* harmony default export */ __webpack_exports__[&quot;default&quot;] = (res);\\n\\n//# sourceURL=webpack:///./src/print.js?&#x27; ); // 9. 将print.js这个模块对象&#123;moduleId: &#x27;./src/print.js&#x27;, l: false, exports: &#123;&#125;&#125;也加一个__esModule: true的属性标记。 // __webpack_require__.r(__webpack_exports__); // 10. 我们print.js源码里写的，可以看最上面的2个文件源码。 // var res = 1; // 11. 源码里我们是export default形式暴露的res。所以这里帮我们将这种暴露挂到了exports.default上。 // __webpack_exports__[&quot;default&quot;] = (res); // 12. 这步实际上就是__webpack_require__函数最后的return，将exports对象扔了出去。&#123;default: 1, __esModule: true&#125; // 这里要注意，模块函数执行完了，此时print模块的 &#123;l: false&#125; 已经变为true了。（模块加载函数中写的module.l = true，别忘了。） &#125;,&#125;);","categories":[],"tags":[]},{"title":"node 查询和关闭进程","slug":"2019/node-process","date":"2019-12-29T16:00:00.000Z","updated":"2021-11-06T07:31:26.651Z","comments":true,"path":"2019/12/30/2019/node-process/","link":"","permalink":"https://690554125.github.io/2019/12/30/2019/node-process/","excerpt":"","text":"手头的 electron 项目，需要查询并关闭另外的程序，程序本身虽然是通过子进程方式启动，但是启动的仅是个壳，壳本身又自己启动了另一个程序 Z，导致无法通过子进程启动后的句柄拿到真正启动的程序 Z。所以无法监控到程序 Z 目前是开启还是关闭的。 解决方法就是 node 子进程模块的 spawn 去执行 windows 的 cmd 命令。该项目只在 windows 电脑运行，所以要用 windows 的命令行而非 liunx 命令。 这里项目本身只在 windows 运行，所以执行的命令应该是 windows 下的，而不是 linux 命令。比如列出当前目录文件，windows 下用的是 dir ，而 linux 下用的是 ls 。两者是不同的，因为我的电脑安装了 cmder ，即可以调用 windows 命令也可以调用 linux 命令。win10 的话有 powershell，可能能支持 linux 命令 直接在 cmd 里面运行查找进程的命令的话，是这样的： 12tasklist | findstr /i chrome.exe// tasklist 查找系统进程后，查找的内容通过管道符 | 传递给另一个命令 findstr ，这个命令接收参数，这里接受了忽略大小写，然后查找chrome.exe关键字，并返回结果。 这里的 /i 意味忽略大小写。 另外要注意的是，查找进程名字如果很长的话，通过上面的命令，查找出来的进程名字会被截取，限制了 25 个字符好像。所以可以加另一个参数给 tasklist， /fo csv 以该模式输出，避免查找出的结果被截取。这样查找后的结果，是自带””的，如： &quot;YoudaoDict.exe&quot;,&quot;5324&quot;,&quot;Console&quot;,&quot;1&quot;,&quot;37,028 K&quot; 开始说正题，node 的子进程模块提供了 exec 和 spawn 2 种方式来调用，其中 exec 会起一个 shell 来执行传入的参数，而 spawn 不会起 shell。所以两种方法调用是有区别的。 exec 方式12345678exec(`tasklist /fo csv | findstr /i YouDaoDict.exe`, (err, stdout, stderr) =&gt; &#123; if (err) &#123; console.log(`tasklist error: $&#123;err&#125;`); return; &#125; console.log(`stdout $&#123;stdout&#125;`); console.log(`stderr $&#123;stderr&#125;`);&#125;); spawn 方式相比上面的写法，略麻烦，注意 tasklist 和 findstr 是 2 个命令，正如上面解释的那样，是 tasklist 运行获取的值给到 findstr 在做的筛选。因此通过 spawn 的方式，需要这么写： 这里涉及到了 stdin stdout 的使用，看起来像个流，简单理解下 stdin 就是函数的入参， stdout 就是函数的返回值。 1234567891011121314151617181920212223242526272829303132333435const &#123; spawn &#125; = require(&#x27;child_process&#x27;);const tasklist = spawn(&#x27;tasklist&#x27;, [&#x27;/fo&#x27;, &#x27;csv&#x27;]);const findstr = spawn(&#x27;findstr&#x27;, [&#x27;/i&#x27;, &#x27;AsmanVR-Win64-Shipping&#x27;]);tasklist.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; // 往findstr的输入中写入 tasklist的输出数据。 findstr.stdin.write(data);&#125;);tasklist.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123; console.error(`tasklist stderr: $&#123;data&#125;`);&#125;);tasklist.on(&#x27;close&#x27;, (code) =&gt; &#123; if (code !== 0) &#123; console.log(`tasklist进程退出，退出码：$&#123;code&#125;`); &#125; findstr.stdin.end();&#125;);findstr.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; // 监听findstr的输出（就是运行返回的结果） console.log(data.toString()); // 这里就是真正获取到查询结果的地方。&#125;);findstr.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(`findstr stderr: $&#123;data&#125;`);&#125;);findstr.on(&#x27;close&#x27;, (code) =&gt; &#123; if (code !== 0) &#123; console.log(`findstr进程退出，退出码：$&#123;code&#125;`); &#125;&#125;);","categories":[],"tags":[]},{"title":"webpack 的各种注入插件","slug":"2019/webpack-inject-plugins","date":"2019-12-29T16:00:00.000Z","updated":"2021-11-06T07:32:32.720Z","comments":true,"path":"2019/12/30/2019/webpack-inject-plugins/","link":"","permalink":"https://690554125.github.io/2019/12/30/2019/webpack-inject-plugins/","excerpt":"","text":"webpack.DefinePlugin 编译阶段，往 JS 注入定义的常量。实际上就是字符串的一个替换而已。所以我们在注入的时候，必须注入的是字符串，而非值本身。例如 123456789plugins: [ new webpack.DefinePlugin(&#123; BUILD_ENV: &#x27;test&#x27;, BUILD_ENV: JSON.stringify(&#x27;test&#x27;), // 如果是布尔值 IS_TRUE: &#x27;true&#x27;, // 不是 true哦！ IS_TRUE: JSON.stringify(true), &#125;),]; HtmlWebpackPlugin 插件，众所周知是方便创建一个配置好各种脚本注入的 HTML 文件的，可以自己提供一个 HTML 模板作为基础，然后在上面进行各种注入，插件支持 EJS ，所以，我们可以在 HTML 模板里使用 &lt;%= HELLO %&gt; 。插件本身支持了 title 字段，也就是 HTML 的 title 可以进行替换。我们也可以使用自定义的其他字段，在 HTML 模板里也可以使用。 123456789plugins: [ new HtmlWebpackPlugin(&#123; inject: true, // 注入JS title: &#x27;文章标题&#x27;, // custom key myName: &#x27;Jack&#x27;, flag: true, &#125;),]; 12345678&lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;% if(htmlWebpackPlugin.options.flag) &#123;%&gt;&lt;script&gt; console.log(&#x27;hello&#x27;);&lt;/script&gt;&lt;% &#125; %&gt; ...&lt;div&gt;&lt;%= myName%&gt;&lt;/div&gt; CRA 脚手架提供了自带的 InterpolateHtmlPlugin ，提供类似上面的方法注入变量，只不过注入后的变量，这么用， %PRO_ENV% 12345678&lt;% if (&#x27;%PRO_ENV%&#x27; !== &#x27;pro&#x27; || &#x27;%NODE_ENV%&#x27; !== &#x27;development&#x27;) &#123;%&gt;&lt;script src=&quot;%PUBLIC_URL%/libs/vconsole/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; if (window.engine.isAttached) &#123; var vConsole = new VConsole(); &#125;&lt;/script&gt;&lt;% &#125; %&gt;","categories":[],"tags":[]},{"title":"React 和 Redux 技术栈快速接入 TS 指南","slug":"2019/ts-react","date":"2019-12-29T16:00:00.000Z","updated":"2021-11-06T07:32:14.482Z","comments":true,"path":"2019/12/30/2019/ts-react/","link":"","permalink":"https://690554125.github.io/2019/12/30/2019/ts-react/","excerpt":"","text":"TS 的基本知识这里不做过多的介绍，请自己参照入门文档：TS 入门文档。 推荐直接使用create-react-app直接生成支持 ts 的项目，然后进行 TS 代码测试，create-react-app myProject --typescript。或者直接使用 TS 官方提供的TS 在线测试。 常用 React 内建常用类型 建议先浏览一遍有印象 React.FC&lt;Props&gt;，定义函数组件用。 React.Component&lt;Props, State&gt;，定义类组件用。 React.ReactNode，用来定义各种 react 节点，比如&lt;div /&gt;, &lt;MyComp /&gt;, this is a just a text, null, 0… React.CSSProperties，用来定义内联style的。 React.HTMLProps&lt;HTMLXXXELEMENT&gt;，获取内建 html 元素的属性。 React.PropsWithChildren，如果需要显示使用 children，使用该类型创建 props，如：React.PropsWithChildren&lt;&#123;a: string&#125;&gt;。 React.ReactEventHandler&lt;HTMLXXXELEMENT&gt;，用来描述元素的事件处理函数。可以自行推导出适合的事件函数描述。 React.ChangeEventHandler&lt;HTMLXXXELEMENT&gt;，最常见的如 input 的 change 事件函数描述，人为的判定类型。区别于上面的，这里的 event 可用 event.target.value，上面的是 event.currentTarget.value。类似还有MouseEventHandler, MouseEventHandler等。 常用的 TS 内建工具泛型和关键字 建议先浏览一遍有印象 typeof关键字，自动推断出类型。如typeof &#123;a: 1, b: &#39;hello&#39;&#125; 得到 {a: number, b: string}。 keyof关键字，类似于Object.keys。keyof &#123;a: string, b: string&#125;得到&#39;a&#39; | &#39;b&#39;。 in关键字，类似于let k in obj，遍历。type Keys = &#39;a&#39; | &#39;b&#39;, type Obj = &#123;[p in Keys]: any&#125;，遍历了 Keys，p 相当于 k，得到的 Obj = {a: any, b: any}。 Partial&lt;T&gt;，将 T 类型全部变为可选。如Partial&lt;&#123;a: stirng, b: number&#125;&gt; 得到 &#123;a: string | undefined, b: number | undefined&#125;。 Omit&lt;P, K&gt;，从 P 中排除 K，返回排除后的结果。如Omit&lt;&#123;a: string, b: number&#125;, &#39;a&#39;&gt; 得到 &#123;b: number&#125;。 Pick&lt;T, K&gt;，从 T 中挑选出 K。如Pick&lt;&#123;a: 1, b: 2, c: 3&#125;, &#39;a&#39; | &#39;b&#39; 得到&#123;a: 1, b: 2&#125;。（这里类型值写的是 number 类型的数字，TS 会推断出 number 类型）。 Exclude&lt;T, U&gt;，从类型 T 中排除不在类型 U 中的。如Exclude&lt;&#39;a&#39; | &#39;b&#39;, &#39;b&#39; | &#39;c&#39;&gt; 得到 &#39;a&#39;，如Exclude&lt;&#123;a: 1, b:2&#125;, &#123;a: 1, b:2, c: 3&#125;&gt; 得到 &#123;a: 1, b: 2&#125;【这里可以这么理解：T 属于 U 的一种具体实现则返回 never，不是则返回 T】。自己实现type Exc&lt;T, U&gt; = T extends U ? never: T。 Extract&lt;T, U&gt;，从类型 T 中提取出可以分配给类型 U 的部分。如Extract&lt;&#39;a&#39; | &#39;b&#39;, &#39;b&#39; | &#39;c&#39;&gt; 得到 &#39;b&#39;，如Extract&lt;&#123;a: 1, b:2&#125;, &#123;a: 1, b:2, c: 3&#125;&gt; 得到 never。【这里可以这么理解：T 属于 U 的一种具体实现，则返回 T，不是则返回 never】。自己实现type Ext&lt;T, U&gt; = T extends U ? T : never。 非 React 技术栈的常见的 TS 用法类型预测is关键字。常用场景，明确一个对象的类型后，会调用该对象的属性或方法。 123function do(str) &#123; return str.length; // 如果 str 是 number类型，就会报错。&#125; 12345// 这样写只能在编译阶段，当你传递的参数不是字符串类型而报错提示。// 如果传入的参数是经过计算或者异步获取，无法保证时，运行时会很大概率报错。function do(str: string) &#123; return str.length;&#125; 123456function do(str: string) &#123; if (typeof str === &#x27;string&#x27;) &#123; // 做好类型判断后编译和运行时都不会报错。但是每次都判断的话，代码变多有点麻烦。 return str.length; &#125;&#125; 通常会封装一个判断函数 12345678910// 一个判断函数function isString(val) &#123; return typeof val === &#x27;string&#x27;;&#125;function do(str: string) &#123; // 调用判断函数 if (isString(str)) &#123; return str.length; &#125;&#125; 1234567// 如果do函数的入参无法确认类型。我们通常会用any。function do(str: any) &#123; // 这里TS已经忽略了入参类型。 if (isString(str)) &#123; return str.length; // 如果无length属性也不会在编译阶段报错，这跟我们使用TS的愿景不一致。 &#125;&#125; 123456789// 使用类型预测 str is string。function isString(str: any): str is string &#123; return typeof val === &#x27;string&#x27;&#125;function do(val: any) &#123; if(isString(val)) &#123; // 这里在运行时阶段也会判断是否是是string，再决定进入if内的执行代码。 return str.length // 这里在编译阶段（书写时）会获得string类型对象的所有属性和方法提示。 &#125;&#125; str is string 能否改为: boolean，即 isString 返回的是一个布尔值？不能。改成单一的布尔类型后，无法获得期望的 string 类型对象的属性和方法推断。 React 常见写法函数组件写法123const FcComp: React.FC&lt;&#123; prop1: string &#125;&gt; = (&#123; prop1 &#125;) =&gt; &#123; return &lt;div&gt;&#123;prop1&#125;&lt;/div&gt;;&#125;; 类组件写法1234567891011interface IProps &#123; name: string;&#125;interface IState &#123; age: number;&#125;class ClsComp extends React.Component&lt;IProps, IState&gt; &#123; state = &#123; age: 18, &#125;;&#125; 默认参数写法1234567891011121314151617interface IProps extends IDefaultProps &#123; name: string;&#125;type IDefaultProps = typeof DefComp.defaultProps; // 获取到默认属性的type签名class DefComp extends React.Component&lt;IProps, State&gt; &#123; static defaultProps = &#123; work: &#x27;docter&#x27;, &#125;; render() &#123; return ( &lt;div&gt; &#123;this.props.name&#125; is &#123;this.props.work&#125; &lt;/div&gt; ); &#125;&#125; 其他写法参照项目中defaultProps文件夹 通用组件写法这里描述一个最常见的情景，一个列表组件。利用泛型（阅读入门 TS 泛型部分）实现。 123456789101112131415161718// 组件定义interface IProps&lt;T&gt; &#123; lists: T[] renderItem: (item: T) =&gt; React.ReactNode // 最好都用ReactNode，而不是JSX.Element。&#125;class List&lt;T&gt; extends React.Component&lt;IProps&lt;T&gt;, &#123;&#125;&gt; &#123; render() &#123; const &#123;lists, renderItem&#125; = this.props return ( &lt;&gt; &lt;ul&gt;&#123;lists.map(renderItem)&#125;&lt;/ul&gt; &lt;/&gt; ) &#125;&#125;// 调用组件。注意：这里List传入了一个类型number，限制了泛型T的类型。&lt;List&lt;number&gt; lists=&#123;[1, 2, 3]&#125; renderItem=&#123;item =&gt; &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;/&gt; 高阶组件（HOC）写法 React 的高阶组件即一个函数，接受一个组件，返回一个新的组件。 这里写一个例子，一个 withState 函数，接收一个没有 count 状态的组件，包装后，返回一个带有 count 状态的组件。 123456789101112131415161718192021222324252627282930313233343536373839404142/* withState.tsx */export interface InjectedProps &#123; count: number, onIncrement: () =&gt; void&#125;export const withState = &lt;P extends InjectedProps&gt;(WrappedComp: React.ComponentType&lt;P&gt;) =&gt; &#123; // 使用Omit结合keyof，实现排除掉IProp和InjectedProps交集的部分(count, onIncrement) type HocProps = Omit&lt;IProp, keyof InjectedProps&gt; &amp; &#123; // 这里可以做HOC的Props的扩展。 initialCount?: number &#125; type HocState = &#123; readonly count: number &#125; return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123; // 组件的名字，方便调试 static displayName = `withState($&#123;WrappedComp.name&#125;)` state: HocState = &#123; count: Number(this.props.initialCount) || 0 &#125; handleInc = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; const &#123; ...restProps &#125; = this.props const &#123; count &#125; = this.state return ( &lt;WrappedComp count=&#123;count&#125; onIncrement=&#123;this.handleInc&#125; // HOC组件，应该透传与HOC无关的Prop给被包裹的组件。这里的写法是因为TS本身的BUG，如果不断言，则类型报错。 &#123;...(restProps as IProp)&#125; &gt;&lt;/WrappedComp&gt; ) &#125; &#125;&#125; 123456789101112131415/* FcCounter.tsx */export const FcCounter: React.FC&lt;Props&gt; = (props) =&gt; &#123; const &#123; label, count, onIncrement &#125; = props; const handleIncrement = () =&gt; &#123; onIncrement(); &#125;; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;:&#123;count&#125; &lt;/span&gt; &lt;button type=&quot;button&quot; onClick=&#123;handleIncrement&#125;&gt;&#123;`Increment`&#125;&lt;/button&gt; &lt;/div&gt; );&#125;; 1234567/* 调用组件 */import &#123; FcCounter &#125; from &#x27;./FcCounter&#x27;import &#123; withState &#125; from &#x27;./withState&#x27;const HocCounterWithState = withState(FcCounter)&lt;HocCounterWithState initialCount=&#123;10&#125; label=&quot;HocCounterWithState&quot; /&gt; 默认 props 的写法123456789101112131415161718192021222324252627282930313233343536373839// 类组件写法interface IProps extends defaultProps &#123; age: number;&#125;// 使用typeof获取到类组件的默认参数类型type defaultProps = typeof DefaultPropsComp.defaultProps;class DefaultPropsComp extends React.Component&lt;IProps&gt; &#123; static defaultProps = &#123; name: &#x27;jack&#x27;, &#125;; echoProps = () =&gt; &#123; // 这里也可以获得TS提示 const &#123; age, name &#125; = this.props; &#125;; render() &#123; return &lt;p&gt;this is how to set default props of class component&lt;/p&gt;; &#125;&#125;// 函数组件写法const defaultProps = &#123; work: &#x27;doctor&#x27;,&#125;;interface IProps extends defaultPropsType &#123; age: number;&#125;type defaultPropsType = typeof defaultProps;function DefaultPropsFC(props: IProps) &#123; // 这里可以获得提示 const &#123; work, age &#125; = props; return &lt;p&gt;&#123;`The $&#123;work&#125; is $&#123;age&#125;`&#125;&lt;/p&gt;;&#125;// 注意：一定要挂载默认属性，否则调用组件的地方默认值也需要传入DefaultPropsFC.defaultProps = defaultProps; 断言简单理解为可以 100%确定是什么类型，让 TS 按照确定的类型来进行 TS 提示，推断等。 JSX 中只支持用 as 断言写法。不支持**&lt;&gt;**写法，如var a = &lt;string&gt;b。跟 jsx 冲突，会当成标签。 123456789101112131415161718192021222324252627type UserA = &#123; name: string, age: number&#125;type UserB = &#123; name: string, sex: string&#125;type IProps = &#123; user: UserA | UserB&#125;class AssertComp extends React.Component&lt;IProps, &#123;&#125;&gt; &#123; render() &#123; // 这里如果不做类型断言，会提示UserA上没有sex属性 // const user = this.props.user const userB = this.props.user as UserB const userA = this.props.user as UserA return &lt;div&gt; &lt;p&gt;this is a user: &#123;userA.age&#125;&lt;/p&gt; &lt;p&gt;this is a user: &#123;userB.sex&#125;&lt;/p&gt; &lt;/div&gt; &#125;&#125; Context 写法用 React 官方 DOC 里的更改按钮颜色主题做例子。 12345678910111213141516171819202122232425/* ctx.tsx */export type Theme = React.CSSPropertiestype Themes = &#123; dark: Theme light: Theme&#125;export const themes: Themes = &#123; dark: &#123; color: &#x27;black&#x27;, backgroundColor: &#x27;white&#x27; &#125;, light: &#123; color: &#x27;white&#x27;, backgroundColor: &#x27;black&#x27; &#125;&#125;// 这里定义Context的签名export type ThemeContextProps = &#123; theme: Theme; toggleTheme?: () =&gt; void &#125;// createContext&lt;T&gt;需要一个类型，把定义好的Context签名传递进去const ThemeContext = React.createContext&lt;ThemeContextProps&gt;(&#123; theme: themes.light&#125;) 12345678910111213141516171819202122/* themeButton.tsx */import ThemeContext from &#x27;./ctx&#x27;// contextType v16.6+支持export default class ToggleThemeButton extends React.Component&lt;&#123;&#125;&gt; &#123; static contextType = ThemeContext // 后面需要通过this.context访问到上下文，所以定义一个类属性 // 这里使用!明确告诉TS，该参数一定有。 // 这里不能使用？，因为context是必选项 context!: React.ContextType&lt;typeof ThemeContext&gt; render() &#123; // 前面context必须这么写，这里才能获取TS提示 const &#123; theme, toggleTheme &#125; = this.context return ( &lt;button style=&#123;theme&#125; onClick=&#123;toggleTheme&#125; &#123;...this.props&#125;&gt; button &lt;/button&gt; ) &#125;&#125; 12345678910111213141516171819202122232425/* provider组件 */import ThemeContext, &#123; Theme, themes &#125; from &#x27;./ctx&#x27;;import ThemeButton from &#x27;./themeButton&#x27;;export default class ThemeProvider extends React.Component&lt;&#123;&#125;, State&gt; &#123; state: State = &#123; theme: themes.light, &#125;; toggleTheme = () =&gt; &#123; this.setState((state) =&gt; (&#123; theme: state.theme === themes.light ? themes.dark : themes.light, &#125;)); &#125;; render() &#123; const &#123; theme &#125; = this.state; const &#123; toggleTheme &#125; = this; return ( &lt;ThemeContext.Provider value=&#123;&#123; theme, toggleTheme &#125;&#125;&gt; &lt;ThemeButton /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125; 多类型参数（重载）假设组件接收 2 种类型的 props。可以传&#123;a: string, config?: number&#125;，或者&#123;b: string&#125;。传递 config 时，说明是用的第一种类型 Props，也一定需要传递 a. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 定义typestype CommonProps = &#123; children: React.ReactNode as: &#x27;p&#x27; | &#x27;span&#x27; | &#x27;h1&#x27;&#125;type NoTrucateProps = CommonProps &amp; &#123; truncate?: false&#125;type TrucateProps = CommonProps &amp; &#123; truncate: true expanded?: boolean&#125;// 定义一个类型判断，运行时可用，这里使用了is技巧。const isTrucateProps = ( props: TrucateProps | NoTrucateProps): props is TrucateProps =&gt; &#123; return !!props.truncate&#125;// 这里是关键，函数重载，约定入参和反参。（并不是具体代码实现）调用组件的地方即可获取正确提示。function Text(props: NoTrucateProps): JSX.Elementfunction Text(props: TrucateProps): JSX.Element// 这里才是Text函数的真正实现。function Text(props: NoTrucateProps | TrucateProps) &#123; console.log(props) if (isTrucateProps(props)) &#123; const &#123; children, as: Tag, truncate, expanded, ...others &#125; = props const classNames = truncate ? &#x27;.truncate&#x27; : &#x27;&#x27; return ( &lt;Tag className=&#123;classNames&#125; aria-expanded=&#123;!!expanded&#125; &#123;...others&#125;&gt; &#123;children&#125; &lt;/Tag&gt; ) &#125; const &#123; children, as: Tag, ...others &#125; = props return &lt;Tag &#123;...others&#125;&gt;&#123;children&#125;&lt;/Tag&gt;&#125;Text.defaultProps = &#123; as: &#x27;p&#x27;&#125; 123// 调用地// 这里传递了expanded，但未传入truncate，会获得提示。^_^&lt;OptionalProps expanded&gt;truncate-able but expanded&lt;/OptionalProps&gt; 零碎，但频率高的 React 用法包括：style 样式定义，接收 React 节点定义，事件函数定义，固定可选参数配置，类属性定义，Ref 定义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* usefulReactProp.tsx */interface IProps extends DefaultProps &#123; descText: string // 基本的类型 style?: React.CSSProperties // 可以在调用组件的地方，获得style的完美提示。 additionDom?: React.ReactNode // 接收任何类型的React节点 renderReactNode?: () =&gt; React.ReactNode // 接收一个以函数方式返回的React节点 onChange: React.FormEventHandler&lt;HTMLInputElement&gt; // 优先推荐这种写法，让TS自己推断。下面的方法定义同样可以。 // onChange: (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void buttonSize: &#x27;small&#x27; | &#x27;middle&#x27; | &#x27;big&#x27; // 可选参数&#125;type DefaultProps = typeof UsefulReactProp.defaultPropsinterface IState &#123; value: string&#125;export default class UsefulReactProp extends React.Component&lt;IProps, IState&gt; &#123; static defaultProps = &#123; initVal: &#x27;输入内容&#x27; &#125; // 定义一个dom引用。使用如下定义方式 static aDom = React.createRef&lt;HTMLDivElement&gt;() // 定义一个类属性，可以在需要时在赋值使用 static classProp?: string // 定义一个类属性，在定义时即复制 static classProp2 = &#x27;hello&#x27; state = &#123; value: this.props.initVal &#125; defaultOnChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123; const &#123; onChange &#125; = this.props this.setState(&#123; value: e.target.value &#125;) this.classProp = &#x27;hello world&#x27; onChange(e) &#125; render() &#123; const &#123; onChange, style, additionDom, renderReactNode &#125; = this.props const &#123; value &#125; = this.state // 如下代码提示只有3种上述定义过的值。 const btnSize = this.props.buttonSize === &#x27;big&#x27; ? &#x27;100px&#x27; : this.props.buttonSize === &#x27;small&#x27; ? &#x27;60px&#x27; : &#x27;80px;&#x27; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.defaultOnChange&#125; /&gt; &lt;p className=&quot;desc&quot; style=&#123;style&#125;&gt; 这是个带样式的提醒 &lt;/p&gt; &lt;div className=&quot;additional&quot;&gt;&#123;additionDom&#125;&lt;/div&gt; &lt;div className=&quot;by-func-rcnode&quot;&gt; &#123;renderReactNode ? renderReactNode() : null&#125; &lt;/div&gt; &lt;button style=&#123;&#123; width: btnSize &#125;&#125;&gt;按钮尺寸：联合类型提示&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 1234567891011121314/* 调用 */// 如下都可以获取类型提示。&lt;UsefulReactProp descText=&quot;一个简单的描述&quot; onChange=&#123;(e) =&gt; &#123; console.log(e.currentTarget.value); &#125;&#125; style=&#123;&#123; fontSize: 14, fontWeight: &#x27;bold&#x27; &#125;&#125; additionDom=&#123;&lt;p&gt;this is additional tag&lt;/p&gt;&#125; renderReactNode=&#123;() =&gt; &#123; return &lt;p&gt;这是通过函数返回的ReactNode&lt;/p&gt;; &#125;&#125; buttonSize=&quot;big&quot;/&gt;","categories":[],"tags":[]},{"title":"React PureComponent 的浅比较","slug":"2019/react-purecompent-diff","date":"2019-12-29T16:00:00.000Z","updated":"2021-11-06T07:31:45.034Z","comments":true,"path":"2019/12/30/2019/react-purecompent-diff/","link":"","permalink":"https://690554125.github.io/2019/12/30/2019/react-purecompent-diff/","excerpt":"","text":"在使用 antd 的 form 组件时，使用到了 getFiledDecorator 去包装了表单组件，其中一个表单组件是颜色选择器，颜色选择器这个表单组件是按 antd 自定义表单组件的方式，同时该组件也是用 PureComponent 声明的。 然后我在使用 setFiledValue 去修改另一个表单组件 A 的值时，发现，也会触发颜色选择器组件的 render 。原以为只会触发我修改的 A 的渲染才对。 测试发现，如果不使用 getFiledDecorator 的话，是不会给组件添加额外的 props 的，此时你去修改 A 组件的值，颜色选择器配合 PureComponent 声明的方式，接收到的新旧 props 都是 &#123;&#125; 。如果使用了 getFieldDecorator 进行包装的话，即便是 PureComponent 也会渲染组件，得到的新旧 props 如下： 然后找了下 PureComponent 组件默认的浅比较方式，发现的确会出现以上描述的情况。 自带的浅比较函数如下，其中 is 函数是 Object.is 的实现，只不过处理了 2 个特殊的情况，即让 +0 === -0 , 让 NaN !== NaN 。 12345678910111213141516171819202122232425262728293031323334353637383940414243if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123; // 先判断组件是否继承的PureComponent return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);&#125;function shallowEqual(objA: mixed, objB: mixed): boolean &#123; if (is(objA, objB)) &#123; // 先用React实现的Object.is去比较2个参数，基本是同类型，同值，同引用的比较，如果不同，在往下比较。 return true; &#125; // 如果有一个参数的类型是对象，则肯定是不相等的（仔细理解第一个if的比较，同类型同值同引用，如果引用不同，肯定不等，那对象和JS的基本类型更不可能相等） if ( typeof objA !== &#x27;object&#x27; || objA === null || typeof objB !== &#x27;object&#x27; || objB === null ) &#123; return false; &#125; // 浅比较对象引用，获取2个参数的键名长度，不一致肯定不等。一致的话，在下面进行对象的第一层比较 const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) &#123; return false; &#125; for (let i = 0; i &lt; keysA.length; i++) &#123; if ( // 比较A的键名是否存在于B对象中，用的是hasOwnProperty。 !hasOwnProperty.call(objB, keysA[i]) || // 如果存在，看看A和B同键名的值是否引用相同（如果是对象），这里用is函数来搞定。 !is(objA[keysA[i]], objB[keysA[i]]) ) &#123; return false; &#125; &#125; // 浅比较结束，这里返回trur, 认为两者相等。 return true;&#125; 所以在解释开篇提到的场景，两个 &#123;&#125; 的比较，比较到了最后一步，for 循环时，没有长度，里面没法走，直接到最后 return true 了。 然后包装后，Props 变多了，然后就进到了 for 循环里比较，发现深层的对象引用不一致。（这里有个疑惑，可能在第一步 is(A,B)就已经判断出来引用不同了，具体看 antd 的传参 Props 是怎么写的，是一个变量还是一个手写{}）","categories":[],"tags":[]},{"title":"Vue中原生操作Select","slug":"2018/about-select-element","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:21:37.793Z","comments":true,"path":"2018/12/30/2018/about-select-element/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/about-select-element/","excerpt":"","text":"Vue中鼓励数据驱动，从而避免跟以前一样使用jQuery来操作DOM的方式操作select。业务开发中经常碰到select操作，所以写一篇记录下原生操作select相关的。 实际开发遇到的情况因为option选项展示给用户看是一个文案，而跟后端约定传值，是对应的code。如果根据selectData的值做一个判断，少的话还行，如果是城市选择，相信大家都有过经验，传递的是城市对应的code，这个时候，如果一个个判断，是不可能的。如下情况： 12345&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectData&quot;&gt; &lt;option v-for=&quot;item,index in options&quot; v-text=&quot;item.t&quot; :value=&quot;item.v&quot;&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345678910let vm = new Vue(&#123; data: &#123; selectData: &#x27;2&#x27;, options: [ &#123;t: &#x27;one&#x27;, v: 1&#125;, &#123;t: &#x27;two&#x27;, v: 2&#125;, &#123;t: &#x27;three&#x27;, v: 3&#125;, ] &#125;&#125;) 获取对应value的思路依赖了原生操作dom的方式，先获取到select，然后获取其selectedIndex属性值，该值返回的就是select中选中的那个option的数组下标。 这里有几个平时经常会弄错的地方。 关于v-model的绑定应该绑定的是select，而不是循环结构里的option。 关于@change事件的绑定也是需要绑定在select上，而不是option。 下面看下原生方式获取对应option的text 123&lt;select v-model=&quot;selectData&quot; @change=&quot;changeEvent&quot; ref=&quot;selectDom&quot;&gt; &lt;option v-for=&quot;item,index in options&quot; v-text=&quot;item.t&quot; :value=&quot;item.v&quot; ref=&quot;options&quot;&gt;&lt;/option&gt;&lt;/select&gt; 12345678910&#123; methods: &#123; changeEvent() &#123; let selectIndex = this.$refs.selectDom.selectedIndex; // 获取选中的index let selectOptionTxt = this.$refs.options[selectedIndex].textContent; console.log(selectOptionTxt); // 打印出对应的option的text &#125; &#125;&#125; 还有一种方法可以获取，查看了下***$refs.options，实际上就是option的dom元素集合。每一个元素（option）有很多属性，其中有一个selected属性，选中的opiton，其selected属性值为true。所以我们可以遍历下option，查看其selected***属性，如果是true，则锁定该option。 123456789101112// 示意代码let selectOption = null;[].forEach.call(document.querySelectorAll(&#x27;option&#x27;), function(item, index)&#123; if (item.selected) &#123; selectOption = item; // 确定了选择的option &#125;&#125;)console.log(selectOption.textContent);// 顺提一下获取select最终选择的值。Vue中，通常是v-model绑定了data中的一个属性console.log(document.querySelector(&#x27;select&#x27;).value); 总结因为本人经常碰到此类情况，每次又不能顺利的搞定该问题，不是绑错了v-model，就是其他问题，因此记录该文。如果哪位有更好的方案（比如用Vue的方式），不吝赐教啊~","categories":[],"tags":[]},{"title":"异步和同步","slug":"2018/async-sync","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:21:43.735Z","comments":true,"path":"2018/12/30/2018/async-sync/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/async-sync/","excerpt":"","text":"同步函数 调用即可立即得到结果，不用等待 123function syncFn() &#123; console.log(&#x27;我是同步，立刻得到结果&#x27;)&#125; 异步函数 调用后不能立即得到结果，需要等待一段时间或者是下一轮tick(事件循环的一轮叫做一个tick)这里需要注意的是：异步函数的代码通常有2个部分组成，现在运行的代码和将来运行的代码，异步函数并不是整体都是异步的。 点击事件12345function asyncFn1() &#123; document.querySelector(&#x27;.oDiv&#x27;).addEventListener(&#x27;click&#x27;, function()&#123; console.log(&#x27;别惊讶，点击事件也算异步&#x27;); // 将来运行的代码 &#125;)&#125; 定时器事件12345function asyncFn2() &#123; setTimeout(function()&#123; console.log(&#x27;定时器，绝对的异步函数&#x27;) // 将来运行的代码 &#125;, 0)&#125; ajax事件1234567891011121314function asyncFn3() &#123; // 假设引入了jQuery $.ajax(&#123; url: &#x27;xxx&#x27;, type: &#x27;post&#x27;, dataType: &#x27;json&#x27;, success: function()&#123; console.log(&#x27;ajax异步请求&#x27;) // 将来运行的代码 &#125;, fail: function()&#123; console.log(&#x27;wrong&#x27;) &#125; &#125;)&#125; Promise12345678910111213// ES6中新增的Promisefunction asyncFn4() &#123; return new Promise(function(resolve, reject) &#123; // do something // 将来运行的代码 start ↓ if(true)&#123; resolve(data); &#125;else &#123; reject(error); &#125; // 将来运行的代码 end ↑ &#125;)&#125; 同步和异步函数也是事件循环中不可缺少的重要概念，对事件循环的运行机制有很大帮助。所以一定要清楚辨认哪些是异步，哪些是同步。","categories":[],"tags":[]},{"title":"事件循环","slug":"2018/event-loop","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:22:42.994Z","comments":true,"path":"2018/12/30/2018/event-loop/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/event-loop/","excerpt":"","text":"为什么会有事件循环Event Loop?因为JS是单线程的（执行JS代码的只有1个线程，通常会说主线程）。一个线程，执行过多任务或者任务过复杂，就会出现阻塞，因此有些如ajax耗时函数则交由其他线程处理，一旦有结果则会将为其事件条件满足设置的回调函数加入到任务队列中，EventLoop是一个机制，当当前执行栈清空后，则从任务队列中查询任务，拉出来执行，重复执行该过程。 图形话EventLoop图片摘自掘金作者【奉献】的事件循环文章 图中有2个新的概念Macrotask和Microtask Macrotask通常所说的任务队列，也就是Task。在ES6提出Promise之前，应该只有Task这个队列，后来规范规定清楚了2种队列，Task就成了Macrotask，也叫宏任务队列。满足条件的事件，则进入该队列，如定时器函数（setTimeout, setInterval, setImmediate等），ajax回调函数，UI交互事件（click等） Microtask微任务队列，也叫Job，粒度比Task小。存放Promise.nextTick，Promise.then()之流的任务。 两个队列的优先级和插入执行时机微任务处理优先于宏任务处理。只有处理完清空了微任务队列，EventLoop才会从Macrotask取一个宏任务进行处理。微任务会插入到下个Tick之前执行 事件循环的一轮怎么界定？这个问题困扰我比较久，查了很多资料，从【这波能反杀】作者写的事件循环机制中找到了明显的答案，结合参考了其他多篇事件循环不错的博文，如掘金的【王下邀月熊】和【奉献】2位作者的文章。 事件循环的开始：JS全局代码（算宏任务）入栈。 事件循环的结束：全局代码执行完，检查Micro是否有微任务，如果有，将微任务队列中函数放入执行栈依次执行完。清空微任务队列。至此第一轮事件循环结束。第二轮，即从下一个Macro任务开始，如此循环。图片摘自掘金【王下邀月熊】的事件循环文章 代码上理解 纯文字解释不容易理解，结合代码 12345678910111213141516171819202122var beginEventFlag = &#x27;开始事件循环&#x27;; console.log(beginEventFlag);setTimeout(() =&gt; &#123; // 异步 console.log(&#x27;500s执行&#x27;)&#125;,500)var p = new Promise(function(resolve, reject)&#123; resolve(5);&#125;)p.then(function(r)&#123; console.log(r); var p2 = new Promise(function(resolve, reject)&#123; resolve(&#x27;又是5&#x27;) &#125;) p2.then(function(d) &#123; console.log(d) &#125;) setTimeout(() =&gt; &#123; console.log(&#x27;又是500s执行&#x27;) &#125;,1000)&#125;) Chrome中打印结果为：’开始时间循环’，5，又是5，500s执行，又是500s执行。 结合概念中来分析此段代码： 全局代码（同步函数，宏任务）入栈，打印‘开始事件循环’。 遇到setTimeout（第一个），计时交由浏览器对应的定时器线程，并将其回调塞入宏任务队列中。 执行new Promise代码，立刻决议这个p。并将其p.then放入微任务队列中。 没有其他同步代码了，检查微任务队列，执行，打印‘5’。遇到p2，立刻决议，将p2.then塞入微任务队列。遇到setTimeout（第二个），塞入宏任务队列。 继续检查微任务队列，发现刚塞入微任务队列的p2.then，执行，打印‘又是5’。至此微任务队列清空完毕。 下一轮事件循环开始，宏任务队列中第一个setTimeout的回调执行，打印‘500s执行’。 检查微任务队列，没有Job需要执行。 再下一轮事件循环开始，宏任务队列中的第二个setTiemout的回调执行，打印‘又是500s执行’。 总结本文参考了很多博文，简化不少东西，笔者主要是为了记录并方便自己的理解，如果有问题，欢迎指正。","categories":[],"tags":[]},{"title":"webpack中的less引入","slug":"2018/less-module-in-webpack","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:21:50.841Z","comments":true,"path":"2018/12/30/2018/less-module-in-webpack/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/less-module-in-webpack/","excerpt":"","text":"项目本身是用vue-cli搭建的模板。使用了less写样式。考虑到充分使用less的特性，所以肯定会有如mixin.less，base.less之类的公用less模块。 12@import &#x27;../../common/style/base.less&#x27;;@import &#x27;../../common/style/mixin.less&#x27;; 当然可以这么写，完全的相对路径。经测试是没问题的。 但是既然是webpack，当然应该充分利用其特性。我也是在看了如慕课网的实战教程后，才了解过还有这种写法。 12@import &#x27;~common/style/base.less&#x27;@import &#x27;~common/style/mixin.less&#x27; 平时一直这么写，没有关注过~这个符号到底代表的是什么。直到有一次写到一个背景图片的less通用函数，出了问题，如下 123456789/*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/.bg-set(@img) &#123; background-image: url(@img); background-repeat: no-repeat; background-size: 100%;&#125;/*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/.bg-set(&#x27;./arrow.png&#x27;) 结果报错，webpack提示大致意思是找不到Module：arrow.png。看了下报错详细，引用的arrow.png路径尽然是src/common/style/arrow.png，而不是理想下的src/page/index/arrow.png。 这个问题的确不好描述，网上搜索过相关问题，基本没有。后来在慕课网中发现有人回答了该问题。 123456/*mixin.less中函数改写为*/.bg-set(@img) &#123; background-image: ~&#x27;url(@&#123;img&#125;)&#x27;; background-size: 100%; background-repeat: no-repeat;&#125; 这里的关键其实就是多了个，因此顺腾摸瓜，从webpack官网查找相关的，在官方中文文档的LOADERS列表中，关于less-loader中有介绍，~利用了webpack的高级特性，将查询参数（这里应该就是传递的图片路径）传递给webpack resolver，告诉webpack以模块查找的方式对待该路径。有点懵逼，没关系，看下例子。 先看下js模块的的导入规则12345678910&lt;!-- 引用Vue模块，优先会从Node核心模块查找，找不到的话，就从node_modules查找 --&gt;var vue = require(&#x27;vue&#x27;)import Vue from &#x27;vue&#x27;&lt;!-- 如果传入的是一个相对路径，则按相对路径查找 --&gt;var util = require(&#x27;./utils&#x27;)import util from &#x27;./utils&#x27;&lt;!-- webpack中可以配置alias（别名），假设@指代src/ --&gt;import main from &#x27;@/common/main&#x27; // 这里加载的路径就是src/common/main.js 从上面大概能了解，webpack中，对js的引入，就是模块导入。webpack官方网站在less-loader和sass-loader中有这么一段相同话。 只要加一个 ~ 前缀，告诉 webpack 去查询模块。 因此，我们在css模块，或者html中只要在路径前面加一个~，实际上就是告诉webpack，按照模块加载方式来寻找对应的资源。以下代码我们还是假设@是src的别名。 1234567891011&lt;!-- 因此问题迎刃而解 --&gt;/*mixin.less中声明的该less函数，路径是在src/common/style/mixin.less*/.bg-set(@img) &#123; background-image: url(@img); background-repeat: no-repeat; background-size: 100%;&#125;/*在src/page/index/index.vue中使用该函数，图片存放在src/page/index/arrow.png*/.bg-set(&#x27;~@/page/index/arrow.png&#x27;) // 可以 遇到~，模块方式加载，将@/page/index/arrow.png 解析为 src/page/index/arrow.png。.bg-set(&#x27;~./arrow.png&#x27;) // 可以 遇到~，模块方式加载，将./arrow.png 按相对路径访问加载该模块资源，即在当前index文件夹中找到arrow.png。因此没问题。 至于改动less函数的方法。原理差不多 12&lt;!-- 对&#x27;url(@&#123;img&#125;)&#x27;以模块方式搜索，因该函数被导入到当前less中，当传入./arrow.png时，以&#x27;~./arrow.png&#x27;的方式进行路径解析，跟上面第二种方式一致。 --&gt;background-image: ~&#x27;url(@&#123;img&#125;)&#x27;; 至此，webpack中的~，大家应该都清楚不少。如果有不对的地方，欢迎指正。","categories":[],"tags":[]},{"title":"简单的实现Promise","slug":"2018/promise","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:22:01.339Z","comments":true,"path":"2018/12/30/2018/promise/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/promise/","excerpt":"","text":"promise 作为 es6 中的重点核心内容，除了只会用之外，还要弄明白其中的原理和规范。本文结合参阅的其他 Promise 实现的文章，还有 PromiseA+的规范，结合自己的理解，记录下如何实现 Promise。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import &#x27;babel-polyfill&#x27;// 简单实用promise的例子。// var promiseA = new Promise(function(resolve, reject) &#123;// setTimeout(() =&gt; &#123;// resolve(1)// &#125;, 2000)// &#125;)// then方法可以无限调用，返回一个新的Promise，如果then中没有传递任何参数，则应该将上一个Promise的值传递到后面去// promiseA.then().then().then().then(r =&gt; &#123;// console.log(r)// &#125;)// then方法接受另一个promise，则等待接收的promise决议，其链式调用的then是接收的promise的回调// promiseA.then(function(r) &#123;// return new Promise(function(resolve, reject)&#123;// setTimeout(() =&gt; &#123;// resolve(r + 1)// &#125;,2000)// &#125;)// &#125;).then(r =&gt; &#123;// console.log(r)// &#125;)function MyPromise(fn) &#123; let callbackFn = [] let result = null let status = &#x27;pedding&#x27; this.then = function(fullfilledFn) &#123; // 前一个promise的then return new MyPromise(function(resolve) &#123; // 后一个新返回的promise handle(&#123; fullfilledFn: fullfilledFn || null, resolve: resolve &#125;) &#125;) &#125; function handle(callback) &#123; // 如果未决议，塞入回调中 if (status === &#x27;pedding&#x27;) &#123; callbackFn.push(callback) return &#125; // 根据PromiseA+的规范，如果fullfilled不是一个函数，且promise1执行成功，Promise2必须成功执行并返回相同的值。 // 让Promise2成功执行，就是调用返回的新promise中的resolve方法，并传递相同的值，这里即result（在promise1的resolve阶段，已经执行了result = asyncReturnValue） // 如果已经决议，且then中未注册fullfilled函数，应该将值，带入返回的那个新promise的resovle中，继续传递下去 if (!callback.fullfilledFn) &#123; callback.resolve(result) return &#125; // 如果已经决议，且then中有注册fullfilled函数，执行前一个promise.then中的fullfilled。 var ret = callback.fullfilledFn(result) // 处理的结果，应该传递给新返回的promise的resolve中。 callback.resolve(ret) &#125; function resolve(asyncReturnValue) &#123; setTimeout(() =&gt; &#123; result = asyncReturnValue status = &#x27;fullfilled&#x27; callbackFn.forEach(item =&gt; &#123; item(asyncReturnValue) &#125;) &#125;, 0) &#125; fn(resolve)&#125;window.a = new MyPromise(function(resolve) &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 2000)&#125;)window.a .then(value =&gt; &#123; console.log(value) &#125;) .then(value =&gt; &#123; console.log(value + 1) &#125;)","categories":[],"tags":[]},{"title":"Vue的render函数","slug":"2018/render-in-vue","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:22:04.135Z","comments":true,"path":"2018/12/30/2018/render-in-vue/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/render-in-vue/","excerpt":"","text":"工作和学习中大部分的vue工程都是通过vue-cli脚手架生成的，所以很少关注到vue实例创建那块，偶尔自己手写则会出现各种报错，比如该版本不包含编译器，请下载完整版本（带有编译器）的。因此趁着这个机会，详细了解了下vue的版本区别以及render函数的使用。 先认识下Vue提供的版本完整版包含了编译器的Vue代码。 关于runtime版本创建Vue实例，渲染并处理虚拟DOM等的代码，不包含编译器 编译器是什么负责将模板字符串变异成Js渲染函数的代码 123456789101112// 创建Vue实例，传入一个模板作为HTML渲染结构。需要编译器，在客户端进行模板编译的。new Vue(&#123; template: &#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;&#125;)// 通过render函数进行渲染，在构建时预编译为Js代码，最终生成的bundle中不在需要编译器。new Vue(&#123; render(h) &#123; return h(&#x27;div&#x27;, this.title) &#125;&#125;) 可以看出来，runtime版本和完整版本，最终都是编译为Js渲染函数代码。差异就是编译一个在开发人员代码构建时（打包器打包阶段），一个在客户端上调用时编译。 使用vue-cli构建的vue工程，可以看到vue实例的创建是这样的 1234567891011121314&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;v-nav&gt;&lt;/v-nav&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import vNav from &#x27;v-nav.vue&#x27; export default &#123; name: &#x27;App&#x27; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456789import App from &#x27;App.vue&#x27;// 这里的h实际上是createElement函数new Vue(&#123; el: &#x27;#app&#x27;, render: (h) =&gt; &#123; return h(App) &#125;&#125;) 但是如果你尝试使用template来挂载模板，会报错。提示你需要完整版本 123&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt; 123456789import vComp from &#x27;./v-comp.vue&#x27;new Vue(&#123; el: &#x27;#app&#x27;, template: &#x27;&lt;div&gt;&lt;v-nav&gt;&lt;/v-nav&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&#x27;, components: &#123; vComp &#125;&#125;) 这是因为，采用webpack2+，或者parcel这类打包工具，都是引用的运行时版本node_modules\\vue\\dist\\vue.runtime.esm.js。如果你一定要使用template的话，可以配置一个别名，引用vue的完整版本即可。如webpack: 12345678module.exports = &#123; // ... resolve: &#123; alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27; &#125; &#125;&#125; 关于render渲染函数某些环境中代码更简练 这里引用官方文档的一个例子 1234567891011121314151617181920&lt;!-- 一个vue单文件 --&gt;&lt;template&gt; &lt;div&gt; &lt;h1 v-if=&quot;level === 1&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-if=&quot;level === 2&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-if=&quot;level === 3&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-if=&quot;level === 4&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-if=&quot;level === 5&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;/div&gt;&lt;/template&gt; 123456789export default &#123; name: &#x27;title&#x27;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125; 这个组件实际就是根据传递的level来决定使用的到底是h1到h5中的哪一个。虽然思路清晰，但是代码冗长。采用render函数的来重写的话。 123456789101112131415161718Vue.component(&#x27;heading&#x27;, &#123; render: (createElement) =&gt; &#123; console.log(createElement( &#x27;h&#x27; + this.level, // h标签 this.$slots.default // 插槽内容 )) return createElement( &#x27;h&#x27; + this.level, // h标签 this.$slots.default // 插槽内容 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 注意的是，createElement函数返回的是一个虚拟DOM节点（这个组件只是整个页面的一小部分），即VNode。而虚拟DOM则是对Vue组件树建立起来的整个VNode树的称呼。上面代码中的console会打印出如下类似内容。 注意：createElement的参数有三个。 参数1必填，可以是String（HTML字符串）, Object（组件选项对象）, Function（解析上述类型任何一种的异步函数）。 参数2选填，Obejct，包含模板相关属性的数据对象，例如class, title等等。涉及的东西很多，查看官方文档data对象 参数3选填，Array，String。子节点VNodes，由createElmenet()函数返回一个VNode对象，或者是字符串形式的文本节点。 在上例的代码中，我们只传递的2个参数，第二个传入的参数就是createElement函数的第三个参数，一个数组，数组中是多个对象，都是由createElement()函数返回的VNode节点。类似如下 VNodes(子节点)必须是唯一的这里的唯一是指，createElement返回的VNode对象是唯一的，使用上也是唯一的，应该看做一个实例对象。而不能当做引用对象使用。官方示例中，如下代码，同一个对象被多次引用使用，就是错误的。 123456render: function(createElement) &#123; var onlyOneObject = createElement(&#x27;p&#x27;,&#x27;hi&#x27;); // 参数1，p标签。参数2，字符串，子节点 return createElement(&#x27;div&#x27;, [ onlyOneObject, onlyOneObject // 数组中引用同一个VNodes ])&#125; 一定需要重复渲染相同的元素/组件（即VNodes），采用工厂函数来实现。 1234567render: function(createElement) &#123; return createElement(&#x27;div&#x27;, Array.apply(null, &#123;length: 20&#125;).map(function()&#123; // apply第二个参数接受数组或类数组生成一个20个长度的数组，map该数组，返回对应的一个应用map传递函数的20长度的数组内容。即[VNodes, VNodes, ..., VNodes] return createElement(&#x27;p&#x27;, hi) &#125;) )&#125; Js代替模板引擎常用的功能实现v-if和v-for1234&lt;ul v-if=&quot;items.length&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 123456789101112131415161718// render函数中写法Vue.component(&#x27;forComp&#x27;, &#123; render: (createElement) =&gt; &#123; if (this.items.length) &#123; return createElement(&#x27;ul&#x27;, this.items.map((item,index) =&gt; &#123; return createElement(&#x27;li&#x27;, item.name) &#125;)) &#125;else&#123; return createElement(&#x27;p&#x27;, &#x27;No items found&#x27;) &#125; &#125;, props: &#123; items: &#123; type: Array, required: true &#125; &#125;&#125;) v-model1&lt;input type=&quot;text&quot; v-model=&quot;enterVal&quot;&gt; 123456789101112131415161718192021222324// render函数中写法Vue.component(&#x27;oInput&#x27;, &#123; render: (createElement) =&gt; &#123; var self = this; return createElement(&#x27;input&#x27;, &#123; // DOM属性 domProps: &#123; value: self.enterVal &#125;, // 事件监听器，基于on on:&#123; input: function(event)&#123; self.$emit(&#x27;input&#x27;, event.target.value); // 这里派发一个input事件，实际上对应应该是如下Html代码结构 &#125; &#125; &#125;) &#125;, props: &#123; enterVal: &#123; type: [String, Number], required: true &#125; &#125;&#125;) 12&lt;!-- 猜测，本质上v-model应该是vue的语法糖，实现监听input事件，然后得到最新输入的值，更新视图 --&gt;&lt;input type=&quot;text&quot; v-on:input=&quot;&quot;&gt; 插槽123456789101112131415161718192021222324252627282930// 普通的插槽内容render: function(createElement) &#123; return createElement(&#x27;div&#x27;, this.$slots.default)&#125;// 生成带有作用域插槽的组件结构（可以传递数据的slot）props: [&#x27;message&#x27;],render: function(createElement) &#123;= return createElement(&#x27;div&#x27;, [ // $scopedSlots.default是一个函数，返回VNodes this.$scopedSlots.default(&#123; text: this.message &#125;) ])&#125;// 向子组件中传递作用域插槽。rende: function(createElement) &#123; return createElement(&#x27;div&#x27;, [ createElement(&#x27;child&#x27;, &#123; scopedSlots: &#123; default: function(props) &#123; return createElement(&#x27;span&#x27;, props.text) &#125; &#125; &#125;) ])&#125; 12345678910111213141516&lt;!-- 上面3段渲染函数关于插槽的写法，对应的template结构应该是 --&gt; &lt;div&gt; 这里是slot的内容 &lt;/div&gt; &lt;div&gt; &lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div&gt; &lt;child&gt; &lt;span slot-scope=&quot;props&quot;&gt;&#123;&#123;props.text&#125;&#125;&lt;/span&gt; &lt;/child&gt; &lt;/div&gt; 总结本文主要是方便自己理解render函数究竟是做什么的，区分不同vue构建版本中使用render方式的差异，后半部分结合官方文档，了解了下render函数的其他简单用法。文章内容还是比较浅，建议大家去官方文档学习。","categories":[],"tags":[]},{"title":"进程，线程","slug":"2018/thread-process","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:22:06.703Z","comments":true,"path":"2018/12/30/2018/thread-process/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/thread-process/","excerpt":"","text":"本篇主要先了解浏览器的进程和线程，为事件循环的内容做铺垫。 进程简单点理解，可以独立运行的程序一次执行的过程。看作是一个工厂，工厂之间一般都是独立的，各干各的。 线程归进程管辖，也能拥有资源，独立运行。进程里可以有多个线程。看作是工厂里的工人，很多工人。 内存按我自己的理解，电脑硬盘只负责存储内容，如果开个游戏，会把游戏内容读取出来放到内存里面去跑，这样我们才能玩。 三者关系一个工厂（进程）有自己的的地盘（分配的内存空间），工厂里有很多工人（线程），工人们在同一个工厂干活，可以共享这个工厂的大部分公共空间，比如厕所，食堂，宿舍。 浏览器的进程浏览器是多进程的，一个tab就是个进程，还有插件，一个激活使用的插件也占一个进程。因为进程之间相互独立，所以某一个崩了，不会影响其他的进程。 浏览器最重要的进程——浏览器内核内核也是多线程的，一个tab选项卡有一个自己的内核（Chrome应该是指V8引擎）。内核有一般有如下常驻线程： GUI渲染线程 Javascript引擎线程（通常说的单线程指的就是它） 定时器触发器线程 事件触发线程 异步Http请求线程 GUI渲染引擎渲染浏览器界面的HTML元素，当界面需要重绘和回流时，该线程就会执行。该线程和Javascript引擎线程互斥。 Javascript引擎线程（主线程）解释JS脚本的。通常说的JS是单线程的，就是由此而来。为啥是单线程？为了简单！假设有这么个情况（多线程），两个人（JS引擎线程假如有2个）同时拿枪指着你的脑袋（DOM元素），一个让你站着（插入），一个让你趴着（删除），你到底听谁的？该线程和GUI渲染引擎互斥。 GUI渲染线程和Javascript引擎线程为什么互斥？因为前者是渲染HTML（DOM和CSS），后者是可以操作DOM和CSS的。如果同时运行，会造成GUI渲染线程绘制元素数据前后表现不一致。所以这2个线程，一定是一个被挂起，另一个在运行。JS操作时，GUI渲染挂起，更新的内容保存在一个队列中，等JS空闲了再执行GUI渲染。 JS会阻塞页面加载，2个线程互斥，大量且复杂的JS代码，会让JS引擎运行时间变长，导致GUI渲染挂起，一直等待JS引擎空闲才回去渲染。 定时触发器线程浏览器的定时器setTimeout和setInterval，JS引擎线程并不负责定时器的计时，可想而知，JS引擎如果一直在倒计时数数，其他代码就无法运行了，阻塞整个代码的运行。事实上，定时器是异步的，就是因为JS引擎线程并没有管他们，而是交由定时触发器线程在计时。 事件触发线程比如click事件，当点击事件触发时，该线程会把事件处理函数放到消息队列的队尾，等待JS引擎按顺序处理点击事件的回调函数。 个人以为是只响应DOM事件，不过看网上大多数文章（基本都是同样内容copy，没啥深入的），时间出发线程还管辖了ajax事件和定时器事件的触发。有个疑问，已经有了定时触发器线程和异步Http请求线程，为啥事件触发线程还会跟ajax事件和定时器事件挂钩？（8月17日自答，考虑下Node里面的Event核心模块，Node是基于事件的，其他模块基本都继承了Event模块。类比这里，ajax事件和定时器事件也应该交由（继承自）事件触发线程来统一处理） 异步http请求线程顾名思义，发送XMLHttpRequest连接的，连接发出后，浏览器新开一个线程来管理发出的请求，当请求回来或者挂掉，状态变更，如果设置了回调函数，该线程就会产生状态变更事件放到JS引擎的处理队列的队尾等待处理。","categories":[],"tags":[]},{"title":"Vue的钩子","slug":"2018/life-circle-in-vue","date":"2018-12-29T16:00:00.000Z","updated":"2021-11-06T07:21:56.570Z","comments":true,"path":"2018/12/30/2018/life-circle-in-vue/","link":"","permalink":"https://690554125.github.io/2018/12/30/2018/life-circle-in-vue/","excerpt":"","text":"单页面应用通常都会用到vue-router，在一个组件或者页面被展示或销毁时，生命周期钩子和路由守卫协作搭配，能够时刻控制组件和页面在不同阶段触发我们自己的函数。然而，分清楚生命周期和路由守卫各自的使用场景很重要，不能混为一谈。未区分清楚，就容易犯错，如下场景案例，都是我犯错的真实案例。 错误案例如下实际工作中用错的案例。 错用场景1A页面(组件)中打开了A-1页面(组件)，然后由A-1页面返回到A页面，在A页面的activated钩子中写了函数，期待能够在A-1返回至A时触发，事实是没有触发，因为没有弄清楚activated钩子函数的触发场景，这里实际应该用路由守卫来触发。 错用场景2Home页面中打开A页面，A页面返回Home页面。Home页面中打开B页面，B页面返回Home页面。以上操作，需要在进入A,B页面时根据页面更改title为A或B，均需要在返回Home页面时，在把title改为home。我在Home，A，B三个组件中写了beforeRouteEnter守卫，挂载了修改title的函数。然后只有A，B有效，Home只有在初次进入时有效。没有弄清楚操作行为B-&gt;Home，A-&gt;Home不属于beforeRouteEnter，路由变化是这样的: /home/A-&gt;/home。解决方式：Home组件中使用beforeRouteUpdate，判断to.path === &#39;/home&#39;触发修改title。A,B组件中使用beforeRouteLeave判断to.path === &#39;/home&#39;触发修改title。或者在beforeEach中对路由的各个操作做判断。 生命周期钩子生命周期钩子是比较常用的，不管是在根实例还是在单文件组件中。都经常会用到。 写法注意所有钩子函数，自动绑定this（实例本身）。所以不能使用箭头函数，箭头函数绑定的this是父作用域。 1234567891011121314151617181920// 注意，这里是最简单的引用vue.js后，然后直接在全局实例化Vue// 因此var vm 等同于window.vmvar vm = new Vue(&#123; // right created() &#123; &#125; // 上面写法等同于如下写法 created: function() &#123; // this指向Vue实例本身 &#125; // error 这种写法错误 created: () =&gt; &#123; // 箭头函数绑定的是父作用域，这个例子中this指向window // 因此箭头函数的话this指向并不是你期待的 &#125;&#125;) 生命周期函数beforeCreate：实例初始化之后，实例还没有创建完成，因此访问this的话，是undefined。 created：实例创建完成，但是未完成DOM挂载。因此this.$el是访问不到的。这里可以执行watch，methods等方法了。常用来挂载页面数据初始化（不涉及到DOM操作）。 涉及到dom挂载，挂载后的重新打补丁渲染，销毁等钩子，都不会在服务端渲染阶段被调用。可以理解，因为服务端只会对页面做一次初始化，按照初始渲染，生成HTML，发送到客户端（浏览器端）。这块猜测如此，后期学习ssr方式后验证。 beforeMount：在挂载DOM到之前的一个钩子函数。能访问到this.$el，就是需要挂载的元素DOM（原始模板）。注意：$el即挂载的根节点，如&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，如单文件组件&lt;template&gt;&lt;div&gt;&lt;/div&gt;&lt;/template&gt;中的div根节点。如果是单文件的方式，在组建中beforeMount不一定能获取到$el，官方文档在mounted钩子函数中有说明。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。 mounted：el选项被新创建的$el替换，且$el挂载到实例上之后（即vm.$el），调用该钩子。通常会在该钩子阶段，操作DOM。这里可以访问到ref标记的DOM结构。 beforeUpdate：数据发生变化时，在虚拟DOM打补丁之前调用。可以访问数据更新前那个状态下的DOM。 updated：数据发生变化且虚拟DOM补丁打完之后。DOM更新成功，可以执行一些依赖DOM的操作。不应该在该钩子重新更改状态，考虑用watch和computed。类似mounted，不保证所有组件都重绘完成。如果需要确认所有组件重绘完成，使用$nextTick。 beforeDestroy：实例销毁之前调用。实例销毁，如v-if，vue-router中切换视图等都会触发该钩子。 destroyed：实例销毁之后调用，完全销毁，包括子实例也会销毁，同触发该钩子函数。 activated：组件相关的钩子，只有keep-alive包裹的组件，重新激活时会触发。通常我们会在&lt;router-view&gt;&lt;/router-view&gt;外套一层&lt;keep-alive&gt;&lt;/keep-alive&gt;，单页面应用，频繁切换视图，减小重新渲染开销。如果使用了keep-alice，会触发activated钩子，但是由于组件被缓存在内存中，没有销毁，也没有重新创建，因此从第二次渲染同样组件时不会触发beforeCreate,created,beforeMount,mounted等钩子，这点应该很好理解。而beforeDestroy,destroyed则永远不会被触发。 deactivated：组件相关的钩子，只有keep-alive包裹的组件，被停用时触发，类似于destroyed，但是不是真的销毁，而是存到内存放到一边，暂时不用这个组件，keep-alive形式的组件切换会触发该钩子。 路由守卫分为3种类型守卫：全局型，单个路由独享型，组件内调用型。通常回调函数有3个参数to, from, next。to，from均为对象，存放路由跳转目的地的参数和来源地的参数，而next为函数，类似于管道操作，进入到下一个钩子，不执行的话，通常会导致路由中断。 全局型beforeEach全局前置路由。进入某路由之前触发。 beforeResolve全局解析路由。导航确认之前，同时在所有组件内调用型路由守卫和异步路由组件被解析之后，该解析守卫就会被调用。这里涉及的执行条件需要理解的是，1是导航确认之前，导航的确认是指全部的钩子执行完，导航状态就是确认的(confirmed状态)。2是组件内路由守卫和异步路由组件都被解析，指的是路由内调用型的3个守卫beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave，异步路由组件解析后(懒加载，通过Import()函数或require方式，用到的时候会去加载再解析，没用到就不存在加载解析一说)。简单来说，等组件内调用型守卫执行完了，异步组件也加载完了，才会执行beforeResolve。 afterEach全局后置钩子。没有next参数，可以理解，毕竟都已经后置了。在路由操作流程的最后触发。需要注意的是，这个钩子看起来是最后一个执行的钩子没错，但是在组件内调用守卫beforeRouteEnter的参数next中的回调函数，才是最后执行的，此时实例已创建好，所以可以在回调中访问到vue实例！！！ 123456789101112131415161718var router = new VueRouter(&#123; routes: []&#125;)router.beforeEach((to, from, next) =&gt; &#123; console.log(&#x27;我是老大，第一个执行&#x27;) next();&#125;)router.beforeResolve((to, from, next) =&gt; &#123; console.log(&#x27;我是保姆，大家都加载好，我在加载&#x27;) next();&#125;)router.afterEach((to, from, next) =&gt; &#123; console.log(&#x27;我是看起来的最后一名，不过好像有一个哥们比我还靠后，这哥们是beforeRouteEnter的回调参数next&#x27;) next();&#125;) 没有路由地址的情况下，上述3个全局路由会被各自执行一遍！。 单个路由独享守卫beforeEnter在路由配置里面单独配置的。 123456789101112var router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/name&#x27;, componet: Name, beforeEnter: (to, from, next) =&gt; &#123; console.log(&#x27;进入name时调用，在组件内调用的守卫之前&#x27;) next(); &#125; &#125; ]&#125;) 组件内调用守卫beforeRouteEnter在渲染当前路由组件对应路由被完全确认(confirm)前调用。因为此时，组件实例还未被创建。所以拿不到this即组件实例。但可以通过next的回调函数拿到实例 123456789101112131415161718export default &#123; name: &#x27;comp&#x27;, beforeRouteEnter(to, from, next) =&gt; &#123; console.log(&#x27;进了当前组件且在路由确认前调用&#x27;) next((vm) =&gt; &#123; console.log(vm) &#125;) &#125;, beforeRouteUpdate(to, from, next) =&gt; &#123; console.log(&#x27;进了当前组件，或在当前组件打开子路由组件父组件仍存在，但内容已经不一样了，需要更新，会调用&#x27;) // 如 home中打开A组件，/home -&gt; /home/A。 回到home组件，/home/A -&gt; /home next(); &#125;, beforeRouteLeave(to, from, next) =&gt; &#123; console.log(&#x27;离开当前路由组件对应的路由时调用&#x27;) next(); &#125;&#125; 导航完整的解析流程导航触发，肯定是从一个路由地址跳往另一个。我们这里考虑这种情况/home/A -&gt; /home/B，涉及到所有守卫; 触发A的beforeRouteLeave 触发全局的beforeEach 触发Home组件中的beforeRouteUpdate 触发B的独享路由守卫beforeEnter 解析异步组件 触发B的组件级守卫beforeRouteEnter 触发全局的beforeResolve 导航确认 触发全局的afterEach 触发DOM更新 组件实例创建完成，调用beforeRouterEnter中传递给next的回调函数，回调函数可传vm，即实例对象。","categories":[],"tags":[]}],"categories":[],"tags":[]}